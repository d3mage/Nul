{"noir_version":"1.0.0-beta.5+0000000000000000000000000000000000000000","name":"GuardianBlocking","functions":[{"name":"add_guardian","hash":"2954216841963877448","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"address_note::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"guardian","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"address_note::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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","names":["add_guardian"],"brillig_names":["discover_new_messages","random","notify_created_note_oracle_wrapper","store_in_execution_cache_oracle_wrapper","notify_enqueued_public_function_call_wrapper","directive_invert"]},{"name":"approve_blocking","hash":"10302659072362419142","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"address_note::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"user","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"address_note::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"855401245733623969":{"error_kind":"string","string":"Obtained invalid key validation request"},"1186437190978851533":{"error_kind":"string","string":"Non-zero hint for zero hash"},"1433889167918961673":{"error_kind":"fmtstring","length":17,"item_types":[]},"1589673740894288059":{"error_kind":"string","string":"Hint values do not match hash"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5641381842727637878":{"error_kind":"string","string":"Got more notes than limit."},"5672954975036048158":{"error_kind":"string","string":"Collapse hint vec length mismatch"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7506220854563469239":{"error_kind":"string","string":"Dirty collapsed vec storage"},"7764445047318889914":{"error_kind":"string","string":"Public data tree index doesn't match witness"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"9199403315589104763":{"error_kind":"string","string":"Proving public value inclusion failed"},"10583567252049806039":{"error_kind":"string","string":"Wrong collapsed vec order"},"11499495063250795588":{"error_kind":"string","string":"Wrong collapsed vec content"},"11553125913047385813":{"error_kind":"string","string":"Wrong collapsed vec length"},"11873158822563704285":{"error_kind":"string","string":"Mismatch return note field."},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13488305543605632947":{"error_kind":"string","string":"Already blocked"},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"15431201120282223247":{"error_kind":"string","string":"Out of bounds index hint"},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17022728796570737336":{"error_kind":"string","string":"Not a guardian"},"17595253152434889169":{"error_kind":"string","string":"offset too large"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"18313900523101689315":{"error_kind":"string","string":"Note contract address mismatch."}}},"bytecode":"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","debug_symbols":"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x6rBsWpwrBocqwbHqsGxanCsGhyrBseqwbFqcKwaHKsGx6rBsWpwrBocqwbHqkFfNeirBn3VoK8a9FWDvmrQVw36qkFfNeirBn3VoK8a9FWDvmrQVw36qkFfNeirBn3VoEcNPlo8PGowoC3oC2gBL5AFusAWjAVLmZYyLWVaymcN6nECL5AFusAWjAV+wVmDE9qCvmAp81LmpcxLmZcyL2VeyrKUZSnLUpalLEtZlrIsZVnKspRlKetS1qWsS1mXsi5lXcq6lHUp61LWpWxL2ZayLWVbyraUbSnbUralbEvZlvJYymMpj6U8lvJYymMpj6U8lvJYymMp+1L2pXzWoPIJtIAXyAJdYAvGAp/QjrMIL2pJPYmSTnkLkiRNsqSR5IvOcryoJfUkSkqPlh4tPVp6tPRo6dHTo6dHT4+eHj09enr09Ojp0dOjpwelB6UHpQelB6UHpQelB6UHpQelB6cHpwenB6cHpwenB6cHpwenB6eHpIekh6SHpIekh6SHpIekh6SHpIemh6aHpoemh6aHpoemh6aHpoemh6WHpYelh6WHpYelh6WHpYelh6XHSI+RHiM9RnqM9BjpMdJjpMdIj5Eenh6eHp4enh6eHp4enh6eHp4evjzacSS1pJ5ESZwkSZpkSSMpPbLOW9Z5yzpvWect67xlnbes85Z13rLOW9Z5yzpvWect67xlnbes85Z13rLOW9Z5yzpvWect67xlnbes85Z13rLOW9Z5yzpvWect67xlnbes85Z13rLOW9Z5yzpvWect67xlnbes85Z13rLOW9Z5yzpvWect67xlnbes85Z13rLOW9Z5yzpvWect67xlnbes85Z13rLOW9Z5yzpvWect67xlnbes85Z13rLOW9Z5yzpvWect67xlnbes85Z13rLOW9Z5yzpvWect67xlnbes85Z13rLOW9Z5yzpvWect67xlnbes85Z13rLOW9Z5zzrvWec967xnnfes85513rPOe9Z5zzrvWec967xnnfes85513rPOe9Z5zzrvWec967xnnfes85513rPOe9Z5zzrvWec967xnnfes85513rPOe9Z5zzrvWec967xnnfes85513rPOe9Z5zzrvWec967xnnfes85513rPOe9Z5zzrvWec967xnnfes85513rPOe9Z5zzrvWec967xnnfes85513rPOe9Z5zzrvWec967xnncegITuCfNFZ5xe1pJ5ESZwkSZpkSelh6THSY6THWefWgyiJkyRJkyxpJPmis84vaknp4enh6eHp4enh6eHp4csjBhVd1JJ6EiVxkiRpkiWNpPRo6dHSo6VHS4+WHi09Wnq09Gjp0dKjp0dPj54ePT16evT06OnR06OnR08PSg9KD0oPSg9KD0oPSg9KD0oPSg9OD04PTg9OD04PTg9OD04PTg9OD0kPSQ9JD0kPSQ9JD0kPSQ9JD0kPTQ9ND00PTQ9ND00PTQ9ND00PTQ9LD0sPS4+ocwriJEnSJEsaSb4o6nxSS+pJ6THSY6THSI+RHiM9Rnp4enh6eHp4enh6eHp4enh6eHr48oiBSxe1pJ5ESZwkSZpkSSMpPVp6tPRo6dHSo6VHS4+WHi09Wnq09Ojp0dOjp0dPj54ePT16evT06OnR04PSg9KD0oPSg9KD0oPSg9KD0oPSg9OD04PTg9OD04PTg9OD0yPq3IJ8UdT5pIfHOIJ6EiVxkiRpkiWNJF901vlF6aHpoemh6aHpoemh6aHpoelh6WHpYelh6WHpYelh6WHpYelh6THSY6THSI+RHiM9RnqM9BjpMdJjpIenh6eHp4enh6eHp4enh6eHp4cvjxgcdVFL6kmUxEmSpEmWNJLSo6VHS4+WHi09Wnq09Gjp0dKjpUdLj54ePT16evT06OnR06OnR0+Pnh49PSg9KD0oPSg9KD0oPSg9KD0oPSg9OD04PTg9OD04PTg9OD04PTg9OD0kPbLOJetcss4l61yyziXrXLLOJetcss4l61yyziXrXLLOJetcss4l61yyziXrXLLOJetcss4l61yyziXrXLLOJetcss4l61yyziXrXLLOJetcss4l61yyziXrXLLOJetcss4l61yyziXrXLLOJetcss4l61yyziXrXLLONetcs84161yzzjXrXLPONetcs84161yzzjXrXLPONetcs84161yzzjXrXLPONetcs84161yzzjXrXLPONetcs84161yzzjXrXLPONetcs84161yzzjXrXLPONetcs84161yzzjXrXLPONetcs84161yzzjXrXLPONetcs84161yzzjXrXLPONetcs84161yzzjXrXLPONetcs84161yzzjXrXLPONetcs84161yzzjXrXLPONetcs84161yzzjXrXLPONetcs84161yz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","names":["approve_blocking"],"brillig_names":["discover_new_messages","get_notes_internal","get_collapse_hints","field_less_than","decompose_hint","lte_hint","get_public_keys_and_partial_address","get_key_validation_request","notify_nullified_note_oracle_wrapper","storage_read","get_public_data_witness","store_in_execution_cache_oracle_wrapper","notify_enqueued_public_function_call_wrapper","directive_invert","directive_integer_quotient","directive_to_radix"]},{"name":"check_block_user","hash":"2527408137032590380","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"user","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7049597037775588060":{"error_kind":"string","string":"Function check_block_user can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17595253152434889169":{"error_kind":"string","string":"offset too large"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["check_block_user"],"brillig_names":["check_block_user"]},{"name":"constructor","hash":"17192357828608188479","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"parameters":[{"name":"portal","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2236649814169388962":{"error_kind":"string","string":"PublicImmutable already initialized"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1bS28jRRDu8SPx2MnaPH8AAokDQmPHXmcvKChZdvcCEhw4wGViT8BSNlklXsSChMwBceGGtEhISPwJDpw4ceGExP9BpLNd9ufP5fGMM7M2kkuKPDNdXc+urupHPDMBz/2W6N0oOAfuN7gZNDOkFaiCxoHg/OMefPdegPZihsr6xDdL+vtBO/QV/TKUf893NPO0j9DMgX6w7eg8GE3osy4Wdt07jiHpU7n62zGT55fcs0998vBtjrYPXlLkL4BuFg5HufDeE/pHQN9kqJvQv5uP/GP67zn6ech+Lx/bjOek+/nYplkzz+LkX0fPxk7DPYdfPPzgUe+8H73b719El5cYbzzW42DXTMcv9pG4waSW5dj1iJ8x0/OXIf5Vk+sc1/SIn8jD9hHbWn+87p7H/rgXDQ/Pz4YXYW/44OxyGJ71oqPo0en5k+gCdUI+BUXnAvBjH2q+jfO58Csv0EvGcd3M+l36+vSesQ9aIut2jKzIX2TdgrbtmH7oW8YvKPhCt0z93yB75JV3XwS6xui5dhO7y8Xu2+45LnYfnA2Gg/B08FU4HJyf3Q8vP191FC/SkKMY6ZWI1lYMLS3KsP9WTD/Um2lpUSZ0y9S/7X7XIco0X+YsVytplMm3qsm10h1HWZHkYftglL3insdRdhienvbDYXh4/ugJB5OmHLYjeMRMQEpVAQkIdiA7LS7ACgq9upk/kItGn37xmWkz7xVO74kH3jpP76kGXklRDtsR5g08GRj8nnTgxc3GSC9uNvaVfgfuN0gHLf4gtGsk/5L0GXoy4HfMLEjbLvGWZ4YivaPcdk1V8iZ0GY95Ym25S20VaLtFbbhnVae2KrQ1qE0L+CQBaUHGWsOYubUs65UFH7RRhfhUMuSD9vaJj58hH/Sd+MqndwsH7je4EbR66xpb0nYL2ngc1aGNfd+ANvbXC4qNl4nl1xLEsq/wydC+x7skFwLbXrMv2p7ti7Zn+6Lt2b5o+7iDCc2+YqeNfSdtfAaBsMiGn6bIN+gr0SnDvL7HHzZ5fZPX5/HZ5PUbQX+T1yfPDJu8PmlbNq/HnfNkmddz2lEKed5EYNtr9kXbs33R9mxftD3bF22ftm4SO6W1b04bOWtl36Q2FFukrZtwjNYIV/jIDjOeXxWoTXD/ADkee9P0uA+eV8lZtrWdjKXxJtRH0Vl/chTI4mkmYkATMXumhe8VRXyNluD/Cf2+dILxdGDhwP0GS8Le8Z2wFwZNa66XHa2JuYbnF+Fn0YdR2E9qM8aLmyLj9LcgruTjv7/MxDZfk20yKNGnoH+lu7qf6Wzz8cVgGBmCwhwjGBKS9zAFMnR0kz8IbR60S9Jn2NfqUwGthk+bQ0XutOsNHLCcc3D+r1IbzlU1asP6fIfatBMr/jUmWd0cd9crr3VNifiUMuSj3W1ge2fBB33He/TouwzHf1f0wJxkSEctGWixwb7GOpv9g3UE2xTrCM2WAlq8iZ3S1lTrNr9oNmT7og3ZvmhDHFcMi+asNDUVjlHRKY8iwEEz80TnKXgIfPk0Q2VaN1bGo/ctBQ8hzQ3BuChkmq8yzbsPB8P3H5+eDk4G0QX3SMrJjnUZU6XRBCerWO3uB4HwLDr6ZTMbH8i/TPhFR4D3MSQ+D5aU86QbNk/2wpOwE/b77V7IN1AsFMBOeA90hTdS2knyIPJftxspWr0lfbk2sCALAE9pKyrfCs+Z1goviXSSjoV1vSSi1dfSl+s3C+w/7T5tWeHzf6GFczX/H4dWxyRdE9wdTbehf45cG89x2r1evr0oNY12DwZp8ybJm04piY8K6XHg3oMbgnarsBKjXzFGv6Ki3+Ec/Q4dQ4v7lreYX536o9/rio0K1Ia1LvtI8mY5oQ6CLxeMLd9vqF6V3Iwy51lHXEHbyvEtyIGyXss/mtYb9x+LCj7Gjv3bUfBxLSA2axC+Fr9a/KPN75OsYsMtBR/p8Th7B3z0kzctH475KsmOuleorajw1dbsPsj8CcXzuqyreS7Nck3oKTIsWjv/THFkFFraPMFzwbaihzZP4Pr1Wr7RrFyriFs8T+a4xRgtKvgct4viXHJfw8z6ksc3xoxPbch3m9q0O6JazIhvMGbm5V2tJhIZxXfaHpqFo9Gz3zLhH1Oc5rQ/o+ZdzBOsX4a8b2t3MAR2zfw8m8e+XNI5QmyRdo7Q6kZt/uA5Qjus0mKA4wNjgPMh5g2OD6w3742mZcY1YlyurJtZ+XB9nvn+QPtq86IZ3u7c6e+1uu3Wov2BrPk3T64WeEGz1Q5a7VYrilbAP2z1W91+b7+13w2fu/69zu3jXrsTBtH18dVC/nLOuzWatGO+s7Dt3qWeZ3w8U0b87xwBOy6/p/gsK/ws3tMYPG/O7zUN5VtpNP3NH83iF0ez+MK7OpqVUdpq0Ia52MKOe0d7IS2Ro0z4PzoC4pMK9JH+DYV/hfhPya1843PDmoJfU/Ctf35wncbrI+Cd9Z7INU+ij99YtqdQG2QdV1ch1e2F3WbzTrsZtZudZfY9sdaQ+srK/Ys3oYXzOK49sS+vPQX/N4i3X2Escc7jvKatmVgWY/Q8swbnhm1tfeMR75z2ShLvJQr/qsm1hhzvJVZIHh5DBbKPn5NvRB5tfbKtyGPvYN4ysz7T7r9q+2dpazzeS9LWgWlrvHnrHK3+09Y5NZNun02bJ3geQfzfYZ7425tvG14zamNKmwsE31fw0b78X9oYEz61afsTcWOrEiNX3NpXkwvHHt/Pq9J7nA7a+iFuL3KF+w8dbf8Bdce8b//i9gEtsA92FXxtb7BB+GhzLS55X067W5lm7YW+wXiJy484z8o6TDuz2QK6UgP8BwPxGqadTQAA","debug_symbols":"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","names":["constructor"],"brillig_names":["constructor"]},{"name":"decrement_guardian_count","hash":"12106667003729952726","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"user","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"15111608787814000058":{"error_kind":"string","string":"Function decrement_guardian_count can only be called internally"},"17595253152434889169":{"error_kind":"string","string":"offset too large"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1dPYgkaRn+qrp7Znp6Znp21wNThYNDk6r+n0Rbd/b+5M7TC4QD8fpXFvfuZG9PDSswMjAzFQNNDDQQDAQVRBBMBJODSw4UNDExNDh0a6femaeffqq6arpqZne9D4bqqu/93v/3/X6rxnMXxUuudbp3AmacXIPtSlgirkAymlUM5s3a2bWZ3PtQXytR2CbRLRP/KOjNmkK+EvnvNhOcVerHcFaAP9hN8HwpusDPssTlMLlHH7I2ew//DtzF72eS301qU4VtK9R9cEvw74NscbkdVUK7a/hPAb8rUTbDf6ca/s/xP5/gr4L3F6rRzXlOerEa3Zzjf6ka/D3D/3JUtu57vZY7i/E3EqUfutU8gfbgq3OrecyKxdSxwHUardKpl0gHcT1PdBol0LH8tAN14+QabFc6x8Qn0jlIZIzL5Dtvffnbs3fmiy/M5/cX777rkVy7gn9ViuDcK4Dzk4zz1ffu3bu7vLu4f+d7d999sIa7KXDbb99p2ZgvhMPSIBrPJte43ZveBc9t5vn1xdvzxf3HSbWORGkInvaozmA/k1zj+llCqOnWVTpOrsF2pW+4D4C3EtPh3EL60K0Xqzsi2ljXhro61R1DXYPqbkDdLtXdBB4sTVvdLWinUo6VGt2jDmPbLSFFM5wjftCvjqgOQ65NdftQd0x1LagzXcT8fSL5fe7rX7z3zuxbr7731nQ9htAnskrNrduR/clgDoWsiAPbHRKOplu3e3m+GobsO1jYd9BuyneaVPcJqNunumegDu3GRfmc6SLm5V8FfA51e5Pq0I63qA7jEWXinKbsaW19t+7be25VTvZvjBH0J3zeJBiPnvspuA9Jjn0Br2KU5UbekRfD13Tar8fJfbBdWbD9sCj7ca7FuOJci/mUcy3GBOfaW8AD51r2H+fy+73psGiuLTOfWh36OOqC5WJfigtOc9AmO/AbYXjcYDDz5BrXv5KMsXjccN19O+dE9EXOieiLLapDX8zqo5Tf7IKeiuRLnGpwH43rk+xTOEUwmWQ//PqDd+5Pvrn46mIy91J49jL4zNKFyknsE1n51IlnnsBjbbPGq515fxGcjKajznTSHU573enJySTshoMwHC3nnWDe6yz74WAwO1mcLMPuctpfTAb9yclgHi6CyWDOtPwM2Yr0Iypfp+HgfsZ+t0g3abpU/Lcy+D9M4R9hsP2h4P8whU/k6SiDf2vTdOs5bJxcu0G3u5h0eoNFPxgsRiejxclw2R8Gs8lyOR8+XDOcBtNpbxB0Y7sOO8G0c7IIuyeL/ix8NAAzWjxOOBLym1yYJ7hvU+PSY7eum+MUHaBtb5Bu2qIN3/uiLdu2nUIbYXaFjGk4VK5Q/B+JNnn4Z/3fSOE/LafcEPwr+xoOXzwvooNaCq9Mh33ed9k2Ur5ZJO5qbrMPIF9Hgi/Endm3ZMzxEEdWMZo3U9qiPBhPNwUOxTfLa88bKe14TL1PeMbJfbBd6TeIn58m13h89mOSS41ZWC7zQd9tzj9Yl+aP+wSv+i70ex7X+gJXLNvPCUdWfOXldY94bQv4GwVlU/k/r2zMB+JFX/MJ/hhwKXjDx77zi+Qa6+E1fxWnD20UThtH+nSPbfPwj3HqC/xsU6SrcGMfifd+Cp2603Ij7w2Bvybood2ahD8u4+QabFU6QcXz9uWhkMeKmg/tUN2NFP1y2TSPft2/wMtwzI+a1zAPamzOWzt8XxN4eBs+LuPkGmxVeue25TF9OfjLtS3qhouyrclU1LboQ2xbjG/u53h7kO/zxjWOp5tu3U/GyTXYqvRGTSHDda6PsO3bKbrjomxvMhW1PcYBz2u4D0Kb8fyWt6TrAk91OXswqjiuS7Vt0Zx92bhGH2Lbcs7GMd5lcraKa1wzqM72w4DXKJ4m25tMRW2P9txke7QZrw1wXDcEnppbl02N83hczTx7RCsuTaf7knFyH2xXeh7RM37xGdLfJ15L5if03HrM1dy6fnzS3Y7g9Zjq4mJHbzxRVxPP/CvGVWL/3+UHh4Iu+1lFeyf9vH5m9Pfdul2r8LNd4ifNZursgrU9duv5nn1D7ZnuCTpPCi70Ue5vrV5djQ4/YzqY7zyi45VIB9txv7VTIh3EdSdapcN9jrrmpYO4TqOz6+M2PmC/wfEB2zrvXDHtzJPJ6tyq3qxsGnN8P8eY4/9dv9uM6T7W72b94riRS5n6fVzmjlXqN68Occ75uwLzjqyzjZ5oW/H4Pve462kY3xuvDvBddkzOeW1bXH6JuPgcJu4T2dgihn/FW6Wp9lyw7UvRRT3Cf8W7wPla8rvl9LwW8dkznkPjuR3WC66PZPlFlh/VBT9tQc/axvzYmVQ+n/S1+3cfLBwVf4OAvoBzBOM5vUiACrSDcGxobIuGtqRVj1Z5GyfPgy3KcBQEZohagt8ciUsd6hH+GwkClMOu9S34XA4n4bI7WU76k/m8N5vcJPwO9NWqgP50ES66y+Wyu5j0loPlldOfh9Nhd9QJpoN+t9OfbqSv3qlqASx3ThW9LJF78cno7xOvVXVOB8QP64c7p0PB6zHVxYUn31kHaJDOVeFie8dlnFyDYqXDD9QgkP2MDwNdkjaX3IMgo7/v1u1ahZ+pF0KUzdRA2NoeU11c2DeyDpAhnScFF/ooH0q3enU1OvyM6WC+48PYrRLpqEOsWXFyWTqIywaIPPEqgw7iOo3OrhbbfFh1nNwHW5Uw4IkglqwD9GqizbbGF5zYPvgyB0/08AWnoosjpqeik3ekc50HOli/qHvWrzpcqXTP+kXd48SIi9Kv6amofivaiHis9JtXh6aLoosj6qBNde+t90LWi01s1XvsfN8gnuNi/VeD8H6YCBu3/aW3KlerfLm6xutBhlwss8G+D7z+yluVPU1PcXk5Rfa/AL5fVy/7YBvZ/wS8/qZ6Xofb8Pp74q+isWjAc0Wmhfxi/GLcnEZavj8kSOM88T7kifjxLtHAOlxE5TGwehlJrY8YrzGf//TKkefPT5k8f33K5PngKZPnb4+ZPKof5xdZMY/wphYuvvIitjpcmbZWdQ0HWHKvVX18gOVqcHEcGH51NTr8LO3wBOpQHW65E51dY5iPKNYNP26yYFv7hluD4D/nX+A0xtouPabseY1kRPi42B6C2gCxthV/96/DeVDxivSNV3WI2trsZOCKy22SW43582zMVhS/ufOJ0b+qjdlNeuV8omJGxRP6XVre2hV0FK56ibjML9opuPG32pysZ9DxBM8Vb/gPVB9ppcjYIS74IQ4ual3AZIpxfHDJdQHjTcUt20PlE3yWZQ9+KaOiOB+qforl5xdFsS7t4wtcNq3TFLEH6pw/clFRH1HYb4uuq9ZAF/8uoAvV91a85lpYFw3Bf5Yu6pfUhXpRoiZ44DGGOpihYtcXPBoOlSu4L1JjG8W74cBDLF4Kb0xL8Wdti37oBmkyPUWb4dSYDudccbGzFwhX5TmRh6UX+9V/aL6KftiIVnWgxhwIz2MHNX/IOiCm8qsaC/DhMU/QQd/g8zmqr8I5QtnnPjqj0eCkM3240jifLee97lWfO+n1J8PZZBiGJ71w0Qv7lzl3UsY3dqt7aTYI+fu9auxQ0ZpDRx18LlO2POsp1RwK7oR5bIz0r2o9pUn8sH7Y56r5EEsniPf1zPdUfmfbqI9+VfvCdydQfQx+9C4udajDl7TbtVUe/Wp4DKuN0U6g+jfrF2K/uetf0EXb4PoQ+r0P9Qj/NqwP3ctYH8KxTdut5w/Ot/ixUIblflN9RCqr/8SP0ChZd0lWg3+QyIcfd2ScqL+9HDi/Czg/XVvFiXt/WTFv8FnnA5GftluPzQNqh7yrw9P4cVaOeY9gWwSbhpt54rHLHsHyx/vUxwHT7pVeVJ/KcqkxnooxNb63thh/OPYwu2Qd9jc/yrtnY/A/SOhV/NKS3Ldlv8t6MQLlUz5/O0W+n0Ee+qG/mV7brecJj+rUfpXVoV+wjVQuyJLB4H8kcoHqy3C+H5d6tCrfOHkebFfkfAnjtRGtyq3yFcIXzVe8bovnH3lOo+btqHP+wK/pcMdlz9XYz34CNrKPh6l1vH3iXe0x8v/6QLpZuSjm87cUz0/COiGvi/AYFevUB408wcOm9cVnKY6cwKXyBOcCtWeQNY5RcWv4ryNusf/juFUf9EN4jttNcX4nOruq88Ts3xgzTapT8wuOmbi8SPTQX7DPtZjhOb9a0097yS5trfA0Ors2CP6PFKcVzcllv8vrwo/73o7KEUXPheTNEbgnVCRHqLU0lT84R6j5SNb+j4oB7g/VnIVjIC4vRKs845pxVl+p5nFVrtsFnflssOgMR8FwEHZO5kXW7Ty3nhd4/R5l89yqnnacXu83fHzu9kMxDmCc+B7i7WgdJ/OMPoz2O41WeTD4vwMPX69pnA2n9XA7Bec/MuajZb8EyzGixkF5zkJUs0Zzdj7EEW21Fmj0r+oshIpfZYesvSnVV5psRWIL6eY505O1tmTP1d5XVlwrWLVPirnD3mvYiQBvdAEbl93kvg70ER7XxBD+I5iL/hfGYY9gBb0Y7qiWDuelXB/hEM/q0eqzZrQOX4vW4Y32frTOo9W1oK5BdA6Se9QX4jI+GgTfSoDP3zGCNtb+WNDfI/orfItnvF/ZEvAtAR/bp54AnM/tgXbZMf6IJuHHZ8yb+U7s182U9uNy+DvPiSZ/DfirA39G3/wGbWpwxmuzGl4D9gvsjzEmTBaf4Pl3g559CvpHlBFthnLn8T+MS+NR5apWVAzXHuHa3QKX8aVicveSfClcO4RL5TF8hjFxC2Ki7HHqrD+Yzh5uMgeLR/8wpXOZ/eW0c7vP0ZgL3/tSe/08jjP4z9cucH4W8iu2V2MwtQbGvDiXvR+R9X9Zr/Gs/BP1sUd1XrDitfue8ZN3rzneCz5y6zZT/3AJ5w4vRWfXPHNqNW/OWne7ijk10sb9zDz7GiqOOc4R/jbE8RsUx1kfcso6i+QEvLK5+qimskuT6tR6sP3ez6Cj+Mpaa1R84XoRfxOB9xqzZMjyO7X3c43rvX213ouy41g1/sv7HRmDPxTwai+Gv+uAOldxyfsgSLdFdXnjEvdI3kjpS1GOvOfmdgDvczQXKGtcsex1Fov+qDedPvwVzsNN44r/AaBNnJmlhQAA","debug_symbols":"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","names":["decrement_guardian_count"],"brillig_names":["decrement_guardian_count"]},{"name":"increment_approval_count","hash":"8926538693968809450","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"user","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"11556553965573010925":{"error_kind":"string","string":"Function increment_approval_count can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17595253152434889169":{"error_kind":"string","string":"offset too large"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["increment_approval_count"],"brillig_names":["increment_approval_count"]},{"name":"increment_guardian_count","hash":"1577580652284543761","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"user","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14970808627057722807":{"error_kind":"string","string":"Function increment_guardian_count can only be called internally"},"17595253152434889169":{"error_kind":"string","string":"offset too large"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["increment_guardian_count"],"brillig_names":["increment_guardian_count"]},{"name":"initiate_blocking","hash":"11302885704381989846","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"address_note::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"user","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"address_note::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"855401245733623969":{"error_kind":"string","string":"Obtained invalid key validation request"},"1186437190978851533":{"error_kind":"string","string":"Non-zero hint for zero hash"},"1433889167918961673":{"error_kind":"fmtstring","length":17,"item_types":[]},"1589673740894288059":{"error_kind":"string","string":"Hint values do not match hash"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5641381842727637878":{"error_kind":"string","string":"Got more notes than limit."},"5672954975036048158":{"error_kind":"string","string":"Collapse hint vec length mismatch"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7506220854563469239":{"error_kind":"string","string":"Dirty collapsed vec storage"},"7764445047318889914":{"error_kind":"string","string":"Public data tree index doesn't match witness"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"9199403315589104763":{"error_kind":"string","string":"Proving public value inclusion failed"},"10583567252049806039":{"error_kind":"string","string":"Wrong collapsed vec order"},"11091894166229312484":{"error_kind":"fmtstring","length":20,"item_types":[]},"11499495063250795588":{"error_kind":"string","string":"Wrong collapsed vec content"},"11553125913047385813":{"error_kind":"string","string":"Wrong collapsed vec length"},"11873158822563704285":{"error_kind":"string","string":"Mismatch return note field."},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13488305543605632947":{"error_kind":"string","string":"Already blocked"},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"15431201120282223247":{"error_kind":"string","string":"Out of bounds index hint"},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17022728796570737336":{"error_kind":"string","string":"Not a guardian"},"17595253152434889169":{"error_kind":"string","string":"offset too large"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"18313900523101689315":{"error_kind":"string","string":"Note contract address mismatch."}}},"bytecode":"H4sIAAAAAAAA/+xdBXwURxe/EA8WoEANCjVKdTcXuVSpUqNKXaNUKF7BA6R4cUpL3d3d3d1b6i11V+r9Ztrdy2SY27tk/+++efTm93vk2Nn973vzZObNzuxmRf4tX3WMRDZr/+/vLEHZ3t82gnppx/y/6u9cw3ltDcfaG451NBzrZDjWTVA/7dg6hvN6GY71Nhxb13Csj3dMLVne337e36hTXlpaV1FS50bdKqeksjpW5pSWVZfH3JhbFiurLYlFo3Wx0lhFZXVlhVPplkbr3Pqyymi9829pn92E5YQqJTWUfHaA8ek4lHx2bD2fJfoByVtnQTkKr1Jff3m/N4o0/e6gHO/o/favKxb/7ySos6Au2U3H/dJGawMnXHH7ANtzNZzeXdW3JG4v4nZQeQ/bDl2J2qGr1w45WhuoJQvcLlkRGl+OYPmsMmHDA0Y3nGKjpoDRrRUBo7v4/+qC1hC0phcwJBUr8lMaSHdgsFf5XSubkOE4ONA4cjxe20X4NXrniLmg+GWG69DglhDhNrVDFgEuCItK9gxuBjeDuwriArFdf7aA8B4ZPWZwM7gZ3FUWlwm2y5Pv+voM3+nk+98xgSzy7zDv99oir+4hqKegdeRsm6DegtYVtJ6g9QVtIGhDQX0EbSSor6CNBW0iaFNBmwnaXNAWghxBrqASQVFBpYLKBJULqhAUE1QpaEtBWwnaWtA2grYVtJ3M8QVtL2gHQTsK2knQzoJ2EdRf0K6CdhO0u6A9BO0paICgvQTtLWgfQfsK2k/Q/oIGCjpA0IGCDhJ0sKBDBB0q6DBBhws6QtCRgo4SdLSgKkHVgmoE1QqqE1QvaJCgYwQdK+g4QccLGizoBEFDBA0VNEzQcEEjBI0UNErQiYJOEnSyoFMEjRY0RtBYQeMEjRc0QdBEQQ2CJgmaLGiKoEZBpwqaKmiaoOmCZgiaKWhWdqT5IxmpTP1xk1RmgXZsPcN5GxnO29hw3haG81zDeeWG82KG87YxnLed4bydDOftYjhvD8N5Awzn7Wc4b6DhvEMM5x1mOO9ow3nVhvMGGc471nDeEMN5wwznnWg472TDeeMM500wnDfFcN6phvNmeudle5QJKKtIQIn8O5veJtI0uaZ2GBHlmCz9vL9OuOJKuwFhOVQ89mDAY08GPK7DgMdeDHjszYDHdRnwuB4DHtdnwOMGDHjckAGPfRjwuBEDHvsy4HFjBjxuwoDHTRnwuBkDHjdnwOMWDHh0GPDoMuCxhAGPUQY8ljLgsYwBj+UMeKxgwGOMAY+VDHjckgGPWzHgcWsGPG7DgMdtGfC4HQMe+zHgcXsGPO7AgMcdGfC4EwMed2bA4y4MeOzPgMddGfC4GwMed2fA4x4MeNyTAY8DGPC4FwMe92bA4z4MeNyXAY/7MeBxfwY8DmTA4wEMeDyQAY8HMeDxYAY8HsKAx0MZ8HgYAx4PZ8DjEQx4PJIBj0cx4PFoBjxWMeCxmgGPNQx4rGXAYx0DHusZ8DiIAY/HMODxWAY8HseAx+MZ8DiYAY8nMOBxCAMehzLgcRgDHocz4HEEAx5HMuBxFAMeT2TA40kMeDyZAY+nMOBxNAMexzDgcSwDHscx4HE8Ax4nMOBxIgMeGxjwOIkBj5MZ8DiFAY+NDHg8lQGPUxnwOI0Bj9MZ8DiDAY8zGfA4C8ij+vb9o73fswX+aYLmCJoraJ6g+YIWCFooaJGgxYJOF7RE0BmCzhS0VNBZgs4WdI6gcwWdJ+h8QRcIulDQRYIuFnSJoEsFXSbockFXCLpS0FWCrhZ0jaBrBV0n6HpBNwi6UdBNgm4WdIugWwXdJuh2QXcIulPQXYLuFnSPoHsF3SfofkEPCHpQ0EOCHhb0iKBHBT0m6HFBTwh6UtBTgp4W9IygZwU9J+h5QS8IelHQS4JeFvSKoFcFvSbodUFvCFom6E1Bbwl6W9A7gt4V9J6g9wV9IOhDQcsFfSToY0GfCPpU0GeCPhf0Rfa/Ovgy+1+dFHs6+Ur8/2tB3wj6VtB3gr4X9IOgHwX9JOhnQSsE/SLoV0G/Cfpd0B8e5p/ZkeYv7ZKK1V/udbrh2NmGYxcajl1uOHat4djNhmN3Go7dbzj2qOHY04ZjLxqOvW449o7h2HLDsc8Nx6RSemnHvjYc+8Zw7FvDse8Mx743HPvBcOxHw7GfDMd+NhxbYTj2i+HYr4ZjvxmO/W449ofh2J/eMbV4tgoLlsAXiTV7MVDYr2X8BeQrEsF3MvJFJH9lr4wbVu6/cXI7qi39bbClNmDeNwbqX75VD6n//5r/ZOVgB2pc/Of6tnbLLe1a6gYt9w1t8QNzk7+E5bMN0K+BunaB7UfS38iXz7QhsJvsHJr+RuL2ijQv6P7GBcbLnDT1N2H5zF31/Yck7lL5z42Wyy3tOpdA7puY9Dd5QH8B6tq9yfL+Rr5wKI/AbvKJ+pv8NPQ3MWB/U8Ckvylc9f2HJO5S+c/Nlsst7bqQQO5bmPQ3RUB/AeravcXy/ka+ZKqIwG7aEvU3bdPQ32wH7G/aMelv2q/6/kMSd6n851bL5ZZ23Z5A7tuY9DcdgP4C1LV7m+X9jXyxWAcCu+lI1N90TEN/swuwvylm0t90WvX9hyTuUvnP7ZbLLe26E4HcdzDpbzoD/QWoa/cOy/sb+TK5zgR204Wov+mShv5mALC/WY1Jf9N11fcfkrhL5T93Wi63tOuuBHLfxaS/6Qb0F6Cu3bss72/kCwS7EdhNd6L+pnsa+puBwP5mdSb9zRqrvv+QxF0q/7nbcrmlXa9BIPc9TPqbNYH+AtS1e4/l/Y18aeSaBHazFlF/s1Ya+pvDgP3N2kz6mx6rvv+QxF0q/7nXcrmlXfcgkPs+Jv1NT6C/AHXt3md5fyNfFNqTwG7WIepv1klDf1MN7G96Melveq/6/kMSd6n8537L5ZZ23ZtA7geY9DfrAv0FqGv3Acv7G/ly2HUJ7GY9ov5mvTT0N8cC+5v1mfQ3G6z6/kMSd6n850HL5ZZ2vQGB3A8x6W82BPoLUNfuQ5b3N/KFwBsS2E0fov6mTxr6m2HA/mYjJv1N31Xff0jiLpX/PGy53NKu+xLI/QiT/mZjoL8Ade0+Ynl/I18CvTGB3WxC1N9skob+5mRgf7Mpk/5ms1Xff0jiLpX/PGq53NKuNyOQ+zEm/c3mQH8B6tp9zPL+Rr74e3MCu9mCqL/ZIg39zQRgf+Mw6W/cVd9/SOIulf88brnc0q5dArmfYNLflAD9Bahr9wnL+xv5svcSAruJEvU30TT0N6cC+5tSJv1N2arvP47JVpxwJe4/KDxpL2UE/vhlNk0cR7fnl0Df+xMos3zhfSdFXrVYqCvX/2FgF4attkW590WAipxI85d1l3vGrB6ryEn+Am9kI7YSq8TDcstzcHxV5OAU0BKjdMIV9yuAM9X/W9JmlDHPKCt1o4wZjLIyBaN0wpVmjRjWKGNAo6zMwSoXbXzSAWMEvWIsB9srZuQOx1/dvzZUJf1Eyg4eXVR8BRxdbAlswzZKrFELUkcU9rlljv08boXm8b9o7FsDUxyuxr41A2Pfhouxg0dWUGNHDve3xSmkhKvjbMvAcbbLOE5oHuuRjtMPp5AoV8fpx8Bxts84Tmge65COswNOIaVcHWcHBo6zYyYvCW/sO+EasYyrse/EwNh3zvQSoXmsQfYSu+AUUs7VcXZh4Dj9bXUcNVneCt9LNHvm5oQrzaYAQ3+ANYJfcDLbCz7IttuGQCezgT03eqYKbdenZTc9u0biPmv5QkIp83b4jtA9DWg7wMka91niBUZhZZ1DEBu2J4gNc4D63d7y2DCXKDa8yCA27EgQG+YCbQeYVrsvWh4b5hHEhp0JYsM8oH7RmSRaJ/MJdNKfQCfzgTrpn2N33PLH1xEsLgmvpzHidQ4jXucy4nUeI17nE/HKdMG1a2AXhd1sbeuuXpvvpq9t3Y3Z4updgZMzu+EWV7vpXFz9NcPF1bt7BriHboC7GxZX75GGxdVfA41yd6BR7mH54mrpgLsTZLO7Wz4q5Cp32Edd0k92JXiu+zUwo9gzs7ja3TPHfh4H2P5cl4Ox75VZXO3uxcDY9+Zi7OhFDEhjRw7398ksrnb3YeA4+2YcJ/ziaqTj7JdZXO3ux8Bx9s84TvjF1UjHGZhZXO0OZOA4B2TykvDGfmBmcbV7IANjPyjTS4RfXI3sJQ7OLK52D2bgOIfYvrhaGuUAgsUfuwJnnAZYvrh6gRd8kG23N4FOFgB7bvRMFVonCwl0si+BThYCdbKv5TpZRKCT/Ql0sgiok/0t18liAp0cQKCTxUCdHGC5Tk4n0MlBBDo5HaiTgyzXyRICnRxCoJMlQJ0gB6+mtU4UGwXlblh0myK3kwPWYaX9zauHeuuwDtPXYR1qWId1mLIOC61gfwt1DhMFh10jdigw8Tksh8bw0IEWKfPhwIBtsmcnXPln54Vp1goRCFFYyFmrIyzXh7SXI3LwcesI8OCGKq7a3HEeaflaT38SKILFJeF1ISNeFzHidTEjXk9nxOsSIl6Z7gAqMbBLMvA/ymvzo/WB/1GGgf/RzHYFHQUc2ByNG1yXpHNX0DcMdwVVeUZZrRtllcEoq9OwK+gboFFWAY2y2vJdQdIBqwhG21WWjxS5yh12jYb0k6MIFiR9A8wyajK7gtyaHPt5rLV9QRIHY6/L7Apy6xgYez0XY0evvkMaO3K4PyizK8gdxMBxjsk4TvhdQUjHOTazK8g9loHjHJdxnPC7gpCOc3xmV5B7PAPHGZzJS8Ib+wmZXUHuCQyMfUimlwi/KwjZSwzN7ApyhzJwnGG27wqSRllLsCDkKOCMUy3QcSRGG3AbnuEFH2Tb1RPo5Axgz42eqULr5EwCnRxDoJMzgTo5xnKdLCXQyXEEOlkK1MlxluvkLAKdDCbQyVlAnQy2XCdnE+hkCIFOzgbqZIjlOjmHQCfDCHRyDlAn8MGrV9C6QSZWw4kXriMW/O9KsKRkBFBu07o2tM5lGyDedO3zLPGOJPBH5Dt0AGv40r6jbKS3hm+UvoZvpGEN3yjCHWX+e2PQuN9b/p0l37DRcv/QlqZzyAPLT+WAYdd/jgR2WqOAwRtozy7ARtKyExGpixMt3/kmBzgjCOLBSZavxZV6OYmB3FQ2Phxo4yeDbdwvOWCdI2P/KatujI0XCr+Tk84n5zTp2GZez2TE61JGvJ7FiNezGfF6DhGvLdmYZtFuyaiBXZKkdrTX5mP0pHa0IakdoyS1frF5t+Ro4EBhDG63ZDSduyW/ZbhbcqxnlON0oxxrMMpxadgt+S3QKMcCjXJcDla5aOOTDjiWIFMZa3mGxlXusGvXpJ+MJlio+S0w+xmf2S3pjs+xn8cJti/U5GDsEzO7Jd2JDIy9gYuxo1clI40dOdyflNkt6U5i4DiTM44Tfrck0nGmZHZLulMYOE5jxnHC75ZEOs6pmd2S7qkMHGdqJi8Jb+zTMrsl3WkMjH16ppcIv1sS2UvMyOyWdGcwcJyZtu+WlEY5gWCV8GjgjNMEoONIDPRCpHO94INsuwYCnZwL7LnRM1VonZxHoJPJBDo5D6iTyZbr5HwCnTQS6OR8oE4aLdfJBQQ6mUqgkwuAOplquU4uJNDJdAKdXAjUyXTLdXIRgU5mEujkIqBO4INXr6B1g0ysZlm+W9Lf7IBe2oTcJToCqI/ZQBtMZRenE678046ILxP4eHIx7CkES4gA6wHTvvPyNG894Bx9PeBphvWAcwJ2Xjrhyj9fTRhOoJSsdtiAi5abyhjbtKPpaHLBfCLXf54GDJJzgMEbaIMuQK9p2S2J1MVc4gGEE664coAzm8CH51m+FlfqZR4DualsfBbQxueDbdwv6E0kC1bduBgvFL4iJ4rn5zTpxWZez2PE6/mMeL2AEa8XMuL1IiJeW7KZzKIdjqUGdkmSx4Vemy/Sk8eFhuRxkZI8+sXmHY4LgZ37ItwOx9J07nD8juEOx8WeUZ6uG+Vig1GenoYdjt8BjXIx0ChPz8EqF2180gEXE2QXiy3PqrjKHXa9mfSThQSLK78DPr5Zktnh6C7JsZ/HM2xfXMnB2M/M7HB0z2Rg7Eu5GDt6JTHS2JHD/bMyOxzdsxg4ztkZxwm/wxHpOOdkdji65zBwnHMzjhN+hyPScc7L7HB0z2PgOOdn8hLA+urMDkf3AgbGfmGmlwi/wxHZS1yU2eHoXsTAcS62fYejNMozCFbaLwTOOJ0BdByJgV48dLEXfJBtt5RAJxcDe270TBVaJ5cQ6ORsAp1cAtTJ2Zbr5FICnZxLoJNLgTo513KdXEagk/MJdHIZUCfnW66Tywl0ciGBTi4H6uRCy3VyBYFOLibQyRVAncAHr15B6waZWF1i+Q5Hf4MCemkTcmfnbKA+LmW2w1G2I+JrAj6eXAy7gGAJEWA9YNp3OF7mrQe8XF8PeJlhPeDlhDscpYJnESil2PKdD1TG2InJDkfk+s/LgEHycmDwBtqg24nJDkekLq4gHkA44YorBziXEvjwlZavxZV6uZKB3FQ2fgnQxq8C27hf0JtIrl5142K8UPiKnCi+KqdJLzbzegkjXi9lxOtljHi9nBGvVxDx2pLNZBbtcCwzsEuSPF7jtfm1evJ4jSF5vFZJHv1i8w7Ha4Cd+7W4HY5l6dzh+D3DHY7XeUZ5vW6U1xmM8vo07HD8HmiU1wGN8vocrHLRxicd8DqC7OI6y7MqrnKHXW8m/eQagsWV3wMf39yQ2eHo3pBjP4832r64koOx35TZ4ejexMDYb+Zi7OiVxEhjRw73b8nscHRvYeA4t2YcJ/wOR6Tj3JbZ4ejexsBxbs84TvgdjkjHuSOzw9G9g4Hj3JnJS8Ib+12ZHY7uXQyM/e5MLxF+hyOyl7gns8PRvYeB49xr+w5HaZQ3Eqy0vwY443Qj0HEkBnrx0JVe8EG23c0EOrkS2HOjZ6rQOrmKQCe3EujkKqBObrVcJ1cT6OR2Ap1cDdTJ7Zbr5BoCndxJ0Z8AdXKn5Tq5lkAndxPo5FqgTu62XCfXEejkXgKdXAfUCXzw6hV4DAOOD++zfIejv0EBvbQJubPzUqA+7me2w1G2I+JrAj6eXAx7NcESIsB6wLTvcHzAWw/4oL4e8AHDesAHCXc4SgVfQqCUdSzf+UBljL2Y7HBErv98ABgkHwQGb6ANur2Y7HBE6uIh4gGEE664coBzP4EPP2z5Wlypl4cZyE1l4/cBbfwRsI37Bb2J5NFVNy7GC4WvyIniR3Ka9GIzr1cx4vVqRrxew4jXaxnxeh0Rry3ZTGbRDsdyA7skyeNjXps/riePjxmSx8eV5NEvNu9wfAzYuT+O2+FYns4djj8w3OH4hGeUT+pG+YTBKJ9Mww7HH4BG+QTQKJ/MwSoXbXzSAZ8gyC6esDyr4ip32PVm0k8eI1hc+QPw8c1TmR2O7lM59vP4tO2LKzkY+zOZHY7uMwyM/Vkuxo5eSYw0duRw/7nMDkf3OQaO83zGccLvcEQ6zguZHY7uCwwc58WM44Tf4Yh0nJcyOxzdlxg4zsuZvCS8sb+S2eHovsLA2F/N9BLhdzgie4nXMjsc3dcYOM7rtu9wlEb5NMFK+8eAM05PAx1HYqAXD13vBR9k2z1LoJPrgT03eqYKrZMbCHTyPIFObgDq5HnLdXIjgU5eJNDJjUCdvGi5Tm4i0MnLBDq5CaiTly3Xyc0EOnmVQCc3A3XyquU6uYVAJ68T6OQWoE7gg1evoHWDTKzesHyHo79BAb20Cbmz836gPpYx2+Eo2xHxNQEfTy6GfZRgCRFgPWDadzi+6a0HfEtfD/imYT3gW4Q7HKWC7yNQyuaW73ygMsYtmOxwRK7/fBMYJN8CBm+gDbpbMNnhiNTF28QDCCdcceUAZxmBD79j+VpcqZd3GMhNZeNvAG38XbCN+wW9ieS9VTcuxguFr8iJ4ndzmvRiM683MOL1Rka83sSI15sZ8XoLEa8t2Uxm0Q7HCgO7JMnj+16bf6Anj+8bkscPlOTRLzbvcHwf2Ll/gNvhWJHOHY4/Mtzh+KFnlMt1o/zQYJTL07DD8UegUX4INMrlOVjloo1POuCHBNnFh5ZnVVzlDrveTPrJ+wSLK38EPr75KLPD0f0ox34eP7Z9cSUHY/8ks8PR/YSBsX/KxdjRK4mRxo4c7n+W2eHofsbAcT7POE74HY5Ix/kis8PR/YKB43yZcZzwOxyRjvNVZoej+xUDx/k6k5eEN/ZvMjsc3W8YGPu3mV4i/A5HZC/xXWaHo/sdA8f53vYdjtIoPyZYaf8+cMbpY6DjSAz04qFbveCDbLtPCXRyK7DnRs9UoXVyG4FOPifQyW1AnXxuuU5uJ9DJlwQ6uR2oky8t18kdBDr5mkAndwB18rXlOrmTQCffEujkTqBOvrVcJ3cR6OR7Ap3cBdQJfPDqFbRukInVD5bvcPQ3KKCXNiF3di4D6uNHZjscZTsivibg48nFsO8RLCECrAdM+w7Hn7z1gD/r6wF/MqwH/Jlwh6NU8BsEStnG8p0PVMa4LZMdjsj1nz8Bg+TPwOANtEF3WyY7HJG6WEE8gHDCFVcOcH4k8OFfLF+LK/XyCwO5qWz8B6CN/wq2cb+gN5H8turGxXih8BU5UfxrTpNebOb1Nka83s6I1zsY8XonI17vIuK1JZvJLNrhGDOwS5I8/u61+R968vi7IXn8Q0ke/WLzDsffgZ37H7gdjrF07nD8ieEOxz89o/xLN8o/DUb5Vxp2OP4ENMo/gUb5Vw5WuWjjkw74J0F28aflWRVXucOuN5N+8jvB4sqfgI9v/s7scHT/zrGfRzlNCeXxv2jsWbhGZLvDMSvXfh7bcDF29EpipLEjh/vZOIWw3eGYzcBxcjKOE36HI9JxcnEKYbvDMZeB4+RlHCf8Dkek4+TjFMJ2h2M+A8cpyOQl4Y29ENeIbHc4FjIw9qJMLxF+hyOyl2iLUwjbHY5tGThOO1sdR02W5RQbuJdo9szNCVeaTQHauMPxbi/4INuuDYFO7gb23OiZKrRO7iHQSQ6BTu4B6iTHcp3cS6CTPAKd3AvUSZ7lOrmPQCcFBDq5D6iTAst1cj+BTooIdHI/UCdFluvkAQKdtCPQyQNAnbQjGGBT6AaZWLUHPimVGPBv73kbFNBLm5A7O38E6qMD0AbTscPxH/0AdzjKxbC/ESwhAqwHTPsOx47ejrXi3EjztX+yQl8PKE/q5V1I8bmIHwiUsqflOx+ojHEAkx2OyPWfHYGTGsXATgtog+4AJjsckbroRDyAcMIVVw5wOuTifbhzrt2xS+qlMwO5qWy8PdDGu4Bt3C/oTSSrrbpxMV4ofEVOFHfJbdKLzbzew4jXexnxeh8jXu9nxOsDRLwy3eFYaWCXJHns6rV5Nz157GpIHrspyaNfbN7h2BXYuXfLxSk3nTscf2a4w7G7Z5Sr60bZ3WCUq6dglE640qwRwxpld6BRrp6LVS7a+KQDdifILrpbnlVxlTvsejPpJ13xj28qfgY+vlkD2IZtIjzXiK2Raz+Pa9q+uJKDsa+V2eHorsXA2NfmYuzolcRIY0cO93tkdji6PRg4Ts+M44Tf4Yh0nHUyOxzddRg4Tq+M44Tf4Yh0nN6ZHY5ubwaOs24mLwlv7Otldji66zEw9vUzvUT4HY7IXmKDzA5HdwMGjrOh7TscpVGuSbDSvitwxmlNy3c4PugFH2TbrU2gkweBPTd6pgqtk4cIdNKTQCcPAXXS03KdPEygk14EOnkYqJNeluvkEQKdrEugk0eAOlnXcp08SqCT9Ql08ihQJ+tbrpPHCHSyIYFOHgPqBD549QpaN8jEqo/lOxz9DQropU3InZ0dgPrYiNkOR9mOiK8J+HhyMexqBEuIAOsB077Dsa+3HnBjfT1gX8N6wI0JdzhKBbcnUMphlu98oDLGw5nscESu/+wLDJIbA4M30Abdw5nscETqYhPiAYQTrrhygLMRgQ9vavlaXKmXTRnITWXjfYA2vhnYxv2C3kSy+aobF+OFwlfkRPFmuU16sZnXhxjx+jAjXh9hxOujjHh9jIhXpjscqwzskiSPW3ht7ujJ4xaG5NFJYTOZTTsctwB27g5uh2NVOnc4rmC4w9H1jLJEN0rXYJQladjhuAJolC7QKEtyscpFG590QJcgu3Atz6q4yh12vZn0ky0IFleuAD6+iWZ2OLrRXPt5LLV9cSUHYy/L7HB0yxgYezkXY0evJEYaO3K4X5HZ4ehWMHCcWMZxwu9wRDpOZWaHo1vJwHG2zDhO+B2OSMfZKrPD0d2KgeNsnclLwhv7Npkdju42DIx920wvEX6HI7KX2C6zw9HdjoHj9LN9h6M0ylKClfZbAGecSoGOIzHQi4ce94IPsu3KCXTyOLDnRs9UoXXyBIFOYgQ6eQKok5jlOnmSQCdbEujkSaBOtrRcJ08R6GRrAp08BdTJ1pbr5GkCnWxLoJOngTrZ1nKdPEOgk34EOnkGqBP44NUraN0gE6vtLd/h6G9QQC9tQu7s3Aiojx2Y7XCU7Yj4moCPJxfDbk6whAiwHjDtOxx39NYD7qSvB9zRsB5wJ8IdjlLBfQiUcpzlOx+ojPF4Jjsckes/dwQGyZ2AwRtog+7xTHY4InWxM/EAwglXXDnA2YHAh3exfC2u1MsuDOSmsvHtgTbeH2zjfkFvItl11Y2L8ULhK3KiuH9uk15s5vUJRrw+yYjXpxjx+jQjXp8h4pXpDsdqA7skyeNuXpvvriePuxmSx91T2Exm0w7H3YCd++64HY7V6dzh+AvDHY57eEa5p26UexiMcs807HD8BWiUewCNcs9crHLRxicdcA+C7GIPy7MqrnKHXW8m/WQ3gsWVvwAf3wzI7HB0B+Taz+Neti+u5GDse2d2OLp7MzD2fbgYO3olMdLYkcP9fTM7HN19GTjOfhnHCb/DEek4+2d2OLr7M3CcgRnHCb/DEek4B2R2OLoHMHCcAzN5SXhjPyizw9E9iIGxH5zpJcLvcET2Eodkdji6hzBwnENt3+EojXIvgpX2uwFnnPYCOo7EQC8eetYLPsi224dAJ88Ce270TBVaJ88R6GQ/Ap08B9TJfpbr5HkCnQwk0MnzQJ0MtFwnLxDo5EACnbwA1MmBluvkRQKdHEygkxeBOjnYcp28RKCTQwl08hJQJ/DBq1fQukEmVodZvsPR36CAXtqE3Nm5A1AfhzPb4SjbEfE1AR9PLobdlWAJEWA9YNp3OB7hrQc8Ul8PeIRhPeCRhDscpYK3J1DKaMt3PlAZ4xgmOxyR6z+PAAbJI4HBG2iD7hgmOxyRujiKeADhhCuuHOAcTuDDR1u+Flfq5WgGclPZ+GFAG68C27hf0JtIqlfduBgvFL4iJ4qrcpv0YjOvzzHi9XlGvL7AiNcXGfH6EhGvTHc41hjYJUkea7w2r9WTxxpD8libwmYym3Y41gA791rcDseadO5w/JXhDsc6zyjrdaOsMxhlfRp2OP4KNMo6oFHW52KVizY+6YB1BNlFneVZFVe5w643k35SQ7C48lfg45tBmR2O7qBc+3k8xvbFlRyM/djMDkf3WAbGfhwXY0evJEYaO3K4f3xmh6N7PAPHGZxxnPA7HJGOc0Jmh6N7AgPHGZJxnPA7HJGOMzSzw9EdysBxhmXykvDGPjyzw9EdzsDYR2R6ifA7HJG9xMjMDkd3JAPHGWX7DkdplMcQrLSvAc44HQN0HImBXjz0shd8kG13HIFOXgb23OiZKrROXiHQyWACnbwC1Mlgy3XyKoFOhhDo5FWgToZYrpPXCHQyjEAnrwF1MsxynbxOoJMRBDp5HaiTEZbr5A0CnYwi0MkbQJ3AB69eQesGmVidaPkOR3+DAnppE3Jn5+FAfZzEbIejbEfE1wR8PLkYtppgCRFgPWDadzie7K0HPEVfD3iyYT3gKYQ7HKWCDyNQynTLdz5QGeMMJjsckes/TwYGyVOAwRtog+4MJjsckboYTTyAcMIVVw5wTqLYpWz5WlyplzEM5Kay8ROBNj4WbON+QW8iGbfqxsV4ofAVOVE8NrdJLzbz+gojXl9lxOtrjHh9nRGvbxDxynSHY62BXZLkcbzX5hP05HG8IXmckMJmMpt2OI4Hdu4TcDsca9O5w/E3hjscJ3pG2aAb5USDUTakYYfjb0CjnAg0yoZcrHLRxicdcCJBdjHR8qyKq9xh15tJPxlPsLjyN+Djm0mZHY7upFz7eZxs++JKDsY+JbPD0Z3CwNgbuRg7eiUx0tiRw/1TMzsc3VMZOM7UjOOE3+GIdJxpmR2O7jQGjjM94zjhdzgiHWdGZoejO4OB48zM5CXhjX1WZoejO4uBsc/O9BLhdzgie4nTMjsc3dMYOM4c23c4SqOcTLDSfjxwxmky0HEkBnrx0DIv+CDbrpFAJ8uAPTd6pgqtkzcJdDKVQCdvAnUy1XKdvEWgk+kEOnkLqJPpluvkbQKdzCTQydtAncy0XCfvEOhkNoFO3gHqZLblOnmXQCdzCHTyLlAn8MGrV9C6QSZWcy3f4ehvUEAvbULu7DwJqI95zHY4ynZEfE3Ax5OLYccRLCECrAdM+w7H+d56wAX6esD5hvWACwh3OEoFn0iglCWW73ygMsYzmOxwRK7/nA8MkguAwRtog+4ZTHY4InWxkHgA4YQrrhzgzCPw4UWWr8WVelnEQG4qG58LtPHFYBv3C3oTyemrblyMFwpfkRPFi3Ob9GIzr28y4vUtRry+zYjXdxjx+i4Rr0x3ONYZ2CVJHpd4bX6GnjwuMSSPZyjJo19s3uG4BNi5n4Hb4ViXzh2OvzPc4XimZ5RLdaM802CUS9Oww/F3oFGeCTTKpblY5aKNTzrgmQTZxZmWZ1Vc5Q673kz6yRKCxZW/Ax/fnJXZ4eielWs/j2fbvriSg7Gfk9nh6J7DwNjP5WLs6JXESGNHDvfPy+xwdM9j4DjnZxwn/A5HpONckNnh6F7AwHEuzDhO+B2OSMe5KLPD0b2IgeNcnMlLwhv7JZkdju4lDIz90kwvEX6HI7KXuCyzw9G9jIHjXG77DkdplGcTrLRfApxxOhvoOBIDvXjoPS/4INvuXAKdvAfsudEzVWidvE+gk/MJdPI+UCfnW66TDwh0ciGBTj4A6uRCy3XyIYFOLibQyYdAnVxsuU6WE+jkUgKdLAfq5FLLdfIRgU4uJ9DJR0CdwAevXkHrBplYXWH5Dkd/gwJ6aRNyZ+c8oD6uZLbDUbYj4msCPp5cDHs6wRIiwHrAtO9wvMpbD3i1vh7wKsN6wKsJdzhKBc8lUMqllu98oDLGy5jscESu/7wKGCSvBgZvoA26lzHZ4YjUxTXEAwgnXHHlAOdKAh++1vK1uFIv1zKQm8rGrwDa+HVgG/cLehPJ9atuXIwXCl+RE8XX5TbpxWZe32fE6weMeP2QEa/LGfH6ERGvTHc41hvYJUkeb/Da/EY9ebzBkDzemMJmMpt2ON4A7NxvxO1wrE/nDsc/GO5wvMkzypt1o7zJYJQ3p2GH4x9Ao7wJaJQ352KVizY+6YA3EWQXN1meVXGVO+x6M+knNxAsrvwD+PjmlswOR/eWXPt5vNX2xZUcjP22zA5H9zYGxn47F2NHryRGGjtyuH9HZoejewcDx7kz4zjhdzgiHeeuzA5H9y4GjnN3xnHC73BEOs49mR2O7j0MHOfeTF4S3tjvy+xwdO9jYOz3Z3qJ8Dsckb3EA5kdju4DDBznQdt3OEqjvJVgpf0NwBmnW4GOIzHQi4c+9oIPsu1uJ9DJx8CeGz1ThdbJJwQ6uZNAJ58AdXKn5Tr5lEAndxPo5FOgTu62XCefEejkXgKdfAbUyb2W6+RzAp3cT6CTz4E6ud9ynXxBoJMHCXTyBVAn8MGrV9C6QSZWD1m+w9HfoIBe2oTc2XklUB8PM9vhKNsR8TUBH08uhr2eYAkRYD1g2nc4PuKtB3xUXw/4iGE94KPKekC0kqWCkQ7jKxm9iBa5XvERoFM/mktjfOiOBSnzY8QdixOuuLLje5gg0Dxu+RpNqZfHGcqNmLR6KBffnh9n2y33J0Ryf2K53J8Syf2p5XJ/RiT3Z5bL/TmR3J9bLvcXRHJ/AZbbL2j5d82xe5wh8cpz8GPdLCCPc4EJ3IttsQls50jzp7Vo+5G6OS0br/fTiPwnAuWzhA7b/ddGfZ318n4/IWLVk4KeEvS0oGcEPSvoOUHPC3pB0IuCXhL0sqBXBL0q6DVBrwt6Q9AyQW8KekvQ24LeEfSuoPcEvS/oA0EfClou6CNBHwv6RNCneiItmSnQjj1pOPaU4djThmPPGI49azj2nOHY84ZjLxiOvWg49pLh2MuGY68Yjr1qOPaa4djrhmNvGI4tMxx703DsLcOxtw3H3jEce9dw7D3DsfcNxz4wHPvQcGy54dhHhmMfG459Yjj2qXdMLTne337e3zBLbqTLPZWLwPrXfZ8OjxWfTHkGOLFwJ9HroSC6KI3z6T4bTmZHkdl9LgxWSbP2c58H6uIuO3XhaHy6L7RS5vL6lWR2X2wdVszQfu5LQF3cbZsuYkY+3ZdbLnNFApndV1qKVZGw/dxXgbq4xx5dlATw6b7WEpkrAmV2X08dqyZJ+7lvAHVxrw26qEjKp7ssNZmdFGR230wFy0mp/dy3gLq47/+ri7IU+XTfTiZzacoyu+8EYpXWt6D93HeBurj//6WLihbx6b6XWOZYC2V230+AVVnf4vZzPwDq4oH068JpBZ/uhyaZnVbJ7C5fGcttZfu5HwF18WA6dVHbaj7dj5vLHA0hs/uJglVSH6r93E+BuniISBcdNF044Uqzyb6wMj8ByeH/ebeR+yTwIfyzuIldF5jDu8Ac1AXmUC4wB3CBY1gXOAZzgWMIF9gHusAY7iJjkOwDiiNNDxvUAn9QDYsjta7K72e5hAxLcNSqJp/5z4BB8HNg50bVhp8DV/f4bfh5LtYJ0vUayE9hfNeSPilT2+ILz8G+1J9WfZG78rLPLw1PFdBrpT8Fjki+ADrQl0TKRS+rRMr8FTCYRSJ4h5OP02WwQC93KM8BLhUC6uNry/Uh7eVrYIdAIHdaR0WfwGJZZa3K7ze5hAx/Ax8VVdZ+AzTcby0fFck2/BY+Kqqs/RboBBRyy6D5teXB+Gug7XwHDsZ+QQ8IkP7yPVDmdI7MP4HxXVljYJdkZP6DF+R/1EfmPxhG5j+mYWSO680c9wegUf5IpFy0IyJl/snykaAMjt8TjAR/trwTlHr5mYHcVDaO7KxXWG7jX3u6Rg94kIOUn4FYv4A7/3RlYR/D+q3qqMrvr7mEDP8Kz8Kqo78CFfib5VmYbMPf4FlYdfQ3yzsgGTR/IeiAfmfSASHt8g+m2c7HML6rSwzskmQ7f3rB9C892/nTkO38lYZsB9drOO6fQKP8i0i5aEdEyvy35SNBGRz/IAi6kTy7OxupF8mj7XJT2bjKZ+gttnm0No7ISkzZjhOuuMhnWshspw2x7yHsRfJos01n52EHUOnKGD+C9f2xepXfnDxChnPy0BljrD4HqMBcoGFRtWFuHjpjjNXnWt6Jy4wxm6ATz2PSiSPtMh8c8NKVMX4E64RjdQZ2STLGAi+YFuZFmmeHBXkrZ4zyJOqM8SNgxlgANMrCPBrloh0RKXMR8WjaCVdcGRzzCYJuW8s7G6mXtgzkprLxtkAbb2e5jSfKUJxwxUVmKO0tz/Kkjtvn2W2HHZhmecth/XWJo/LbMY+Q4Y7wLK/E6QhUYLHlWZ5sw2J4llfiFDPI8joQdLydmHS8SLvszDTLWw7L8tx6A7skWV4XL5iupmd5XQxZ3mppyPKWA7O8LkCjXC2PRrloR0TK3NXyEbAMjp0Jgm43yzsbqZduDOSmsvFuQBvvbrmNJ8pQnHDFRWYoq1ue5Ukdr55ntx2uwTTL+xD3ZoJmWd6aeYQMrwnP8mqdNYEKXMvyLE+24VrwLK/WWYtBlrcGQce7NpOOF2mXPZhmeR/CsryatGV5Pb1guo6e5fU0ZHnrpCHL+xCY5fUEGuU6eTTKRTsiUuZelo+AZXDsQRB0e1ve2Ui99GYgN5WN9wba+LqW23iiDMUJV1xkhrKe5Vme1PF6eXbb4fpMs7wPYP11ebP3z22QR8jwBvAsr9zdAKjADS3P8mQbbgjP8sqbye2ELBRyyyxvfYKOtw+TjhdplxsxzfI+gGV55Wl712BfL5hurGd5fQ1Z3sZpyPI+AGZ5fYFGuXEejXLRjoiUeRPLR8AyOG5EEHQ3tbyzkXrZlIHcVDa+KdDGN7PcxhNlKE644iIzlM0tz/KkjjfPs9sOt2Ca5b2Pe5YXU/l18ggZdvDP8mIOUIGu5VmebEMX/ywv5jLI8rYg6HhLmHS8SLuMMs3y3se9dLzCwC5JllfqBdMyPcsrNWR5ZWnI8t4HZnmlQKMsy6NRLtoRkTKXWz4ClsExShB0KyzvbKReKhjITWXjFUAbj1lu44kyFCdccZEZSqXlWZ7UcWWe3Xa4JdMs7z1Yf11aqfK7VR4hw1vBs7zSyq2ACtza8ixPtuHW8CyvtHJrBlnelgQd7zZMOl6kXW7LNMt7D5bllcYM7JJkedt5wbSfnuVtZ8jy+qUhy3sPmOVtBzTKfnk0ykU7IlLm7S0fAcvguC1B0N3B8s5G6mUHBnJT2fgOQBvf0XIbT5ShOOGKi8xQdrI8y5M63inPbjvcmWmW9y7uqwzNVmzukkfI8C7wLK/a3QWowP6WZ3myDfvDs7zqZnI7IQuF3DLL25mg492VSceLtMvdmGZ57+Je3J+2FZu7e8F0Dz3L292Q5e2RhizvXWCWtzvQKPfIo1Eu2hGRMu9p+QhYBsfdCILuAMs7G6mXAQzkprLxAUAb38tyG0+UoTjhiovMUPa2PMuTOt47z2473IdplvcOLsurUfndN4+Q4X3xWV7NvkAF7md5lifbcD98llezH4Msbx+Cjnd/Jh0v0i4HMs3y3sFledUGdkmyvAO8YHqgnuUdYMjyDkxDlvcOMMs7AGiUB+bRKBftiEiZD7J8BCyD40CCoHuw5Z2N1MvBDOSmsvGDgTZ+iOU2nihDccIVF5mhHGp5lid1fGie3XZ4GNMs723cis1qld/D8wgZPhy/YrP6cKACj7A8y5NteAR+xWb1EQyyvMMIOt4jmXS8SLs8immW9zZuxWaVgV2SLO9oL5hW6Vne0YYsryoNWd7bwCzvaKBRVuXRKBftiEiZqy0fAcvgeBRB0K2xvLOReqlhIDeVjdcAbbzWchtPlKE44YqLzFDqLM/ypI7r8uy2w3qmWd5buK+iN/uSwqA8QoYHwbO8mDMIqMBjLM/yZBseA8/yYs4xDLK8eoKO91gmHS/SLo9jmuW9BcvyKuoN7JJkecd7wXSwnuUdb8jyBqchy3sLmOUdDzTKwXk0ykU7IlLmEywfAcvgeBxB0B1ieWcj9TKEgdxUNj4EaONDLbfxRBmKE664yAxlmOVZntTxsDy77XA40yzvTaIsb0QeIcMjCLK8EUAFjrQ8y5NtOJIgyxvJIMsbTtDxjmLS8SLt8kSmWd6bDLO8k7xgerKe5Z1kyPJOTkOW9yYwyzsJaJQnM8nykDKfYvkIWAbHEwmC7mjLOxupl9EM5Kay8dFAGx9juY0nylCccMVFZihjLc/ypI7H5tlth+OYZnnLYP11VbN3bI7PI2R4PDzLq6ocD1TgBMuzPNmGE+BZXlXlBAZZ3jiCjncik44XaZcNTLO8ZbAsrypt79ic5AXTyXqWN8mQ5U1OQ5a3DJjlTQIa5eQ8GuWiHREp8xTLR8AyODYQBN1GyzsbqZdGBnJT2Xgj0MZPtdzGE2UoTrjiIjOUqZZneVLHU/PstsNpTLO8N3BZXqnK7/Q8Qoan47O80ulABc6wPMuTbTgDn+WVzmCQ5U0j6HhnMul4kXY5i2mW9wYuy4sa2CXJ8mZ7wfQ0PcubbcjyTktDlvcGMMubDTTK0/JolIt2RKTMcywfAcvgOIsg6M61vLORepnLQG4qG58LtPF5ltt4ogzFCVdcZIYy3/IsT+p4fp7ddriAaZb3Ou6r6M2e5S3MI2R4ITzLq61cCFTgIsuzPNmGi+BZXm3lIgZZ3gKCjncxk44XaZenM83yXsd9FT1tz/KWeMH0DD3LW2LI8s5IQ5b3OjDLWwI0yjPyaJSLdkSkzGdaPgKWwfF0gqC71PLORuplKQO5qWx8KdDGz7LcxhNlKE644iIzlLMtz/Kkjs/Os9sOz2Ga5b0G669r6lR+z80jZPhceJZXU3cuUIHnWZ7lyTY8D57l1dSdxyDLO4eg4z2fSceLtMsLmGZ5r8GyvJpaA7skWd6FXjC9SM/yLjRkeRelIct7DZjlXQg0yovyaJSLdkSkzBdbPgKWwfECgqB7ieWdjdTLJQzkprLxS4A2fqnlNp4oQ3HCFReZoVxmeZYndXxZnt12eDnTLO9VWH/tNnuWd0UeIcNXwLM8t/IKoAKvtDzLk214JTzLcyuvZJDlXU7Q8V7FpONF2uXVTLO8V2FZnpu2Z3nXeMH0Wj3Lu8aQ5V2bhizvVWCWdw3QKK/No1Eu2hGRMl9n+QhYBserCYLu9ZZ3NlIv1zOQm8rGrwfa+A2W23iiDMUJV1xkhnKj5Vme1PGNeXbb4U1Ms7xXcF9Fb5bl3ZxHyPDN8CyvuvJmoAJvsTzLk214CzzLq668hUGWdxNBx3srk44XaZe3Mc3yXsF9FT1tWd7tXjC9Q8/ybjdkeXekIct7BZjl3Q40yjvyaJSLdkSkzHdaPgKWwfE2gqB7l+WdjdTLXQzkprLxu4A2frflNp4oQ3HCFReZodxjeZYndXxPnt12eC/TLO9l3JcUYiq/9+URMnwfPMuLxe4DKvB+y7M82Yb3w7O8WOx+BlnevQQd7wNMOl6kXT7INMt7GZblxSoM7JJkeQ95wfRhPct7yJDlPZyGLO9lYJb3ENAoH86jUS7aEZEyP2L5CFgGxwcJgu6jlnc2Ui+PMpCbysYfBdr4Y5bbeKIMxQlXXGSG8rjlWZ7U8eN5dtvhE0yzvJdg/XVpsyzvyTxChp+EZ3mlsSeBCnzK8ixPtuFT8CyvNPYUgyzvCYKO92kmHS/SLp9hmuW9BMvyStOW5T3rBdPn9CzvWUOW91wasryXgFnes0CjfC6PRrloR0TK/LzlI2AZHJ8hCLovWN7ZSL28wEBuKht/AWjjL1pu44kyFCdccZEZykuWZ3lSxy/l2W2HLzPN8l6E9deVrsrvK3mEDL8Cz/Iq3VeACnzV8ixPtuGr8CyvspncTshCIbfM8l4m6HhfY9LxIu3ydaZZ3ouwLK/SMbBLkuW94QXTZXqW94Yhy1uWhizvRWCW9wbQKJfl0SgX7YhImd+0fAQsg+PrBEH3Lcs7G6mXtxjITWXjbwFt/G3LbTxRhuKEKy4yQ3nH8ixP6vidPLvt8F2mWd4LsP66wlH5fS+PkOH34FlehfMeUIHvW57lyTZ8H57lVTjvM8jy3iXoeD9g0vEi7fJDplneC7Asr7zewC5JlrfcC6Yf6VneckOW91EasrwXgFnecqBRfpRHo1y0IyJl/tjyEbAMjh8SBN1PLO9spF4+YSA3lY1/ArTxTy238UQZihOuuMgM5TPLszyp48/y7LbDz5lmec/j3r7S7EsKX+QRMvwFPMurrvsCqMAvLc/yZBt+Cc/yquu+ZJDlfU7Q8X7FpONF2uXXTLO853FvX0nblxS+8YLpt3qW940hy/s2DVne88As7xugUX6bR6NctCMiZf7O8hGwDI5fEwTd7y3vbKRevmcgN5WNfw+08R8st/FEGYoTrrjIDOVHy7M8qeMf8+y2w5+YZnnPwfrrkmbP8n7OI2T4Z3iWV+L8DFTgCsuzPNmGK+BZXomzgkGW9xNBx/sLk44XaZe/Ms3ynsN9SaHewC5JlvebF0x/17O83wxZ3u9pyPKeA2Z5vwGN8vc8GuWiHREp8x+Wj4BlcPyVIOj+aXlnI/XyJwO5qWz8T6CN/2W5jSfKUJxwxUVmKH9bnuVJHf+dZ7cdRvJ5ZnnP4vrrGpXfrHxChiU4NssTzAMV2Cbf7ixPtqHkEZvlOTVt8u3ueGWWF8nHB6jsfB4dL9Iuc8ABL11Z3rOwLM+pNrBLkuXlesE0Lz/SPKPLzV85y5MnUWd5wF7DzQUaZV4+jXLRjoiUOR/oiJEI3uFkcMwhCLoFlnc2Ui8FDOSmsvECoI0XWm7jiTIUJ1xxkRlKEbG/IHRclG+3HbZlmuU9A+uvy5ut2GyXT8hwO3iWV17XDqjA9pZnebIN28OzvPK69gyyvLYEHW8HJh0v0i47Ms3ynsHty0vbis1iL5h20rO8YkOW1ykNWd4zwCyvGGiUnfJplIt2RKTMnS0fAcvg2JEg6HaxvLOReunCQG4qG+8CtPHVLLfxRBmKE664yAylq+VZntRx13y77bAb0yzvaVh/7TZ7x2b3fEKGu8OzPNftDlTg6pZnebINV4dneW4zuZ2QhUJumeV1I+h412DS8SLtck2mWd7TuBWbaXvH5lpeMF1bz/LWMmR5a6chy3samOWtBTTKtfNplIt2RKTMPSwfAcvguCZB0O1peWcj9dKTgdxUNt4TaOPrWG7jiTIUJ1xxkRlKL8uzPKnjXvl222FvplneU7gFTM325a2bT8jwuvl43PUsz8yk3OvlNzUwCJcsm+pN0MGtz6SDQ9rSBsQdHEInGxDYZTqD4JNEQXDDfEKGNyQIgn0sD4JS7j5MgqB0jD6WB8F0OtkTubg2UPndKJ+Q4Y0Ihp0bASN6X8sdVrZhXwIn6Gt5yiKdtC9B2rc+UN8bWz5NIm1nY6Jg7xe0b28M1M8mlk9tJErLnXDFRablm1pu41LHmxK0IdION2Pw7G4zgj5mRS5NzOkAlh8p8xPAxzdPAgd8mwNj4Z3tcFh3AbHuBmLdA8S6F4h1HxDrfiDWA0CsB4FYD+Gw0prsAf21WbK3RT4hw1sQzKg4lidoUm6HaPpOri1oE6E3NiTfKp+9wHw+gRpQuI4DmrJ05T+QZ0Duv38Ai2hc/0fobRdu08+QG/Vd9T+hXu3mNv9viJeBu/qBVn8+yl35UCs/OOyaDr7UGizXfPjllmO5iSpeaSmWm7jq1ZZhuUGVr7UEyw2ufj11rCRIjvNGqlhJkRxnWWpYKSA5zpupYKWE5DhvJcdKEclx3k6GlTKS47wTjNUCJMd5NwirRUiO815irBYiOc77ibBajOQ4H5ixWoHkOB+asFqF5DjLV8ZqJZLjfKRjtRrJcT5ujhUCyXE+UbFCITnOp0SPZl051kfPGMmBtJw1opjhQjaCvyDYVRIeitkzh2BmcwVwVqkE/Cg1J2LOrnuB2yCTSLQEKZNItAwpk0i0DCmTSLQMKZNItAwpk0g4LSyZRKJlJZNItKz4Y1pZot7keakpoXDCFVcOUF0m6x0lnyUEj+HLLF9+IA2gjEDucvAjND/pk7gNHi66LUqJ2qKCqC0qAtoiLM9UdvFVO1p/SMJfTRL+yGzga7DcvcC2L5NyWKzyEnMQXjw5h+ApCToAr1mSHhpPS9RD4q2UrIfCMyTsIfCMSXur8RIk7q3ES5i8twovIIFvBV5gEt9ivCSJfAvxkibzLcJLIaFvAV5KSX3KeCkm9inipZzcp4TXggQ/BbwWJflJ8VqY6CfBa3GyH4jXioQ/AK9VSX9CvFYm/gnwWp38G/FCTAAY8EJNAqyEF3IiQMMLPRnQDA8wIVBG8IAKOD53vwYv/xQiR9TJC72keq9kOYCKSZFvo9pEfVgXU3IWONNlYKb9BDYW8AQ3CUxS95E8xwgSub/AiZxfclqos5ZMPIWVuTLfzgCD1IVql5XKxEpr9ZOszZH62VLBcqNR4Ru1FW59bX20rKKypNotj5aX15fWV5THSmvry0qraivq3NKqaEllXYVT78bq6irKojUV5fWVtTXl9WrQdmuj0dLayuoat6ykvKraidVGq5z60opoiVNVG62orY3GysurotHa8lh9rDJWUlJVH405ZRUVlU55SbSyhEo/W3r6CVq1YPMybbUT28qbIN+aSwCn4m8rgmC9DVHHtQ3hLLRsi60J2mJborbYlnAWmsouIu3tnoWmsoGs9nbHAYlBkdUA9e0i23BVyWq2IspqtuOY1WxHnNVsRxAY2oADg19szmr65dsZYJC6UO2yH7OsZntgVqMG7bBZDZV+tleymkSdgs3TUZR8UnUwO3DsYHYg7mB2IOhgsok6mFwwn8gAtiMQCzlthuyssomC4Y4pdFZh23SnfFyn0GzazKLOiko/O61CU3A7e1Nwu1Dsqku0sNQJV9wScM9NJXcbQrnD8tjf8mlRaZj9CTrjXYkGJrsSTovuQtQWuxG1xW6E06JUdpFn+bQolQ3kM5gW7U8QS4H6dvMz06J6+Sd+o9pEHWDtTpm19icKiLsTZq2S590JAkMBk2nR/sBB0R75dgaYAqJMZo80TIsi9bMncFo0H5hpUulnzxQyzV4t1FeSknlFRYuQMq+oaBlS5hUVLUPKvKKiZUiZV1S0DCnzigqnhSXzioqWlcwrKlpW1MR/gDc7vxeXpJeKvwEECe7eRMn+3oQzwbIt9iJoi32I2mIfwplgKrvoa/lMMJUNbAyWuxfY9mViCotVXnIKwosnqBA8JUkF4DVLVEPjaclqSLyVEtZQeIakNQSeMXFtNV6C5LWVeAkT2FbhBSSxrcALTGRbjJckmW0hXtKEtkV4KSS1LcBLKbFNGS/F5DZFvJQT3JTwWpDkpoDXokQ3KV4Lk90keC1OeAPxWpH0BuC1KvFNiNfK5DcBXqsTYCNeiCTYgBcqEV4JL2QyrOGFToib4QGSYoon98Dxubtx5sm9XtwBRE/u9+X45H5f4if3+xIkclv+B5/c75dvZ4DZkujJ8H7MntzvD3xyvzHwyT2Vfvb/P2xoQi65ouSTqoMZyLGDGUjcwQwk6GC2YrKhCRnADgBiIZeGITurrYiC4QFp2NB0IHBDU7OlYRZ1VlT6OVDRT2+wXiQG8CtY/zwFgOF5TwFAePGnABA85SkAAK/ZU4DQeNpTgJB4Kz0FCIVneAoQAs/4FKDVeAmeArQSL+FTgFbhBTwFaAVe4FOAFuMleQrQQrykTwFahJfCU4AW4KX0FCBlvBSfAqSIl/JTgJTwWvAUIAW8Fj0FSIrXwqcAK8DL3laAl76tAC9/WwFeArcCvAxuBXgp3ArwcrgV4CVxK8DL4laAl8at8BO7SHomKMKOWQ9Cvh2JkM+DW89nmX5A8tY50pSXyf/LdvjL+z07u+n3acrvg71z/OsOEf8/VNBhgg7Pbzrul2ysHbhzsnFYhwBz/COIJuPQ7dcd2H6HAtvvSPB8m27bRyi2faTy+zDl9+GabR8l/n+0oCpB1flN27KKI+l5Cci87PDtW1f/T6lT+a3JJ2S4xvAIOCzzNcAAXQs0Wqo2rAVO4vptWJvPozOuw/FZSslnfev5jOoHTAGrTglMc5UO+CjleL0WsAaJ/x8j6FhBx+U3x0PaqBzgIW3Ub9PjLd+aIH3zeALfPJ648+um2M985fegAFsaLP5/gqAhgoYG2FJYnfu2hF42pCY1YXkcZrldds3+N+myuQ2HEz1Qlbi9PFy0/DLWAnXvSj8fTBA3RwDblukAt17ldyTlAHckfoBbPxJoZKMYDHBH4TvR+lGWB2kZTEcQOP+JxIOHRAPREwMGDyeJ/58s6BRBo4kHoqMI2nQMg4HoGAIfGkNsS4kGoicF2NJY8f9xgsYLmkA8EB1l+UB0Irijz4ukp6M/DTfr6LRX+GzwOvpJ3t/J3t8p3t9G7++p3t+p3t9p3t/p3t8Z3t+Z3t9Z3t/ZlEsMgctkmo2IJ3tMq8dONRybbjg2K39lg0A72mkwI46SzvDMaT2ftfoBUzA8TQl6DcrvScrvOVownCv+P0/QfEEL0vC4ZTJwYDoXODBdSDSbiW6/KcD2mwdsv0VM2q8R2H7zge23mHigtFCJAYuU34uV3wu02HC6+P8SQWcIOjMNseFUoG5OB+pmKRPbngpsvyXA9juLSftNA7bfGcD2O5s4NixVYsBZyu+zld9narHhHPH/cwWdJ+j8NMSG6UDdnAPUzQVMbHsGsP3OBbbfhUzabyaw/c4Dtt9FxLHhAiUGXKj8vkj5fb4WGy4W/79E0KWCLktDbJgF1M3FQN1cTqybyxUdXKL8vlT5fZmmmyvE/68UdJWgqw26Qee81+DaoN7UBtcosl6h/J4dMAF4rfj/dYKuF3RDftMyrHR9i+laoF20Ufi80ZtkuonLJBMVfzcSzODfDHZmf4JM4jYQ6uomgra4hagtbsmne9sjlV0Ms/xtj1Q2MNzy7/5Iua8lePoC1Lc7PPP2IL24N4Jji19u5fjkRWW6hTwn3XYjeb6VIDCMYPL2IORj1Nvy7QwwI4g2/N+WT//2IKR+blf0E/aFDMOBL2Sg0s/tnn7k74JIU8bdEv0kKe5fwXglNfVutEy0nFNeVVpWWx4tqS2pcGpLy+pdobSSylKhsvqa0lhtrCRaX1JRUuNna+U5//71OzL5+0Ylm7vJ+32H+HunoLvyI82KPrsQ1naQT9zuAM4u3J2PHTyka43m3UQd/D35hAzfk4/HvRdoDFRy36s4Fwg3cJo2bDsgH+/eCdTPfUyd9T4iZ70/n5Dh+wmc9QHLnVXK/UCandUJV5r1hk64Ag2mD4KNvtDT94PKKOZO5bc/4pE0RTneaDjnIXHsYUGP5NP4jxx130UwbSL5R+nnUSL93JFAP4/mN+kn2TmPib+PC3qCSD/3en6OztqfBD+HpbDLJwnkfopYbsS09ZP5di8ifxrchmhZZcwE8uhKH3+KwBafYeCDdxHI/SwDH6SQ+zmgTVL4jeyzH8rH2s8zBO34PAO/OZVA7hcY+A2F3C9a7jdyDA+Maa6ME88TtONLlvfbcqwNtHFX2s1LBO34MgM/fJlgDAnchOc+2xab0+nrxBLth5ocsE7sFfH/VwW9Juj1/Ja/rius3l5R7Kqkqqy2rrSirjbqOFXieUl1hXiuUlXlllaUl4jHKOL5UllNfY1bXlMbc93yuuryaqey2qkvKS+N1lSVVFeq/L6RT8jwGwZDC8v8G8AgsIx4Ig/RhssMQSpsGy4Dz0BLG2oTSe4ETrjivgIOrnpBtolf3vQc7C3v79ve33ekXtEGIxUrIzyXNS1vK7NpepR+U4nGbym/3w6I0u+K/78n6H1BH+TTbudfZvlMzIfEIzpEcAPy6L7r4UWwOiEZzcp3aqmz4E64wuIdXcuJgjfatz+C8Rkto7Ad+Woc4Ks6XPlalrEEmdDHls/EvOPFC7Tcn4CfSOn94kdK//ex8vuTgH7xU/H/zwR9LuiLfNpXJi23vF/8Mp9mLCNxe3ltrq+zixC196eW+5h8v+HHRH0yVZtS9FP/2R1YvgGgg+xX+TyM6ctsnMxBfIbF/hrXnhWmTutrpXPaKNL0u4PynraO2c07rW/ENd8K+k7Q962YcnPCFfcbcEfhlx/yCRn+wRBtwxqHbPROkfRM8awWoXHsCIbP+E4atS1+9Nr8p3yvQfwhgax4Rzv2kzdMUAt6Md1q4ZVf4u/v+hE4R/oTUdRGT00gZf7ZIHNrMVU7+tmzrXQ+hPgRLItfVuQTMrwiIB9pLf4KYP79i+UPIWQb/pKfONK3Fv8Xy584/+TJjdTzL8jc2Pu+A9J+fiXKjX9VcuPCSHpy46wITWdj8zCTkk9k512g8PmbF/x/9/7+4f390/v7l/f3b7+T8C7OKog0H1n95hmZeux3w7E/DMf+VB5E+cf+Mpz3t+E8yZB+XlbByqO8fLBC/mipQgK2gf/ZMqzADeV/td5QVsL9u7VYBg6lnkK2fRw1qwAXdNsUYIOunntL/L8UH/lL8Y1EE8bZ4pocQbmC8groXw2VD2sDt0LlEz0o+AbY2Rbg9B416T1f0fs/8cz7W1CQWO+Foq5IUFtB7Qqa5lyKIulJ/39i0hkWAn02T+Gzvde5dfD+dvT+Fnt/OxU0zaHJ0ln8v4ug1QR1FdRNUHdBqwtaQ9CagtYStLagHoJ6ClpH9k2CegtaV9B6gtYXtIGgDQX1EbSRoL6CNha0iaBNBW0maHNBWwiSPbgrqERQVFCpoDJB5YIqBMUEVeoddKeCplFguibxOoCDq1+2LCBkeMsCPO5WwB6LSu6tlHEhCDetO6Q7Ehnb1gWEDG9NYGzbWG5sUu5tmBtbMZGxbVtAyPC2BMa2neXGJuXejsDYKHjdynMM9Pi+XwFPJ+tE5GTbFxAyvD2Bk+1guZNJuXdg4mT/BCwCJ9uxACt3IqcKy+dOreezVD9gSnw7KAluR+V3J+X3TgXNE9+dxf93EdRf0K4F9O8pB/be7s5A39yNeDJqN0UHuyi/+yu/d9V0s7v4/x6C9hQ0oIBuVb+MHzsS+OVeQF3neG2ajico7YniSQTKZ0mMDtspyVLadiPv996iXfYRtK+g/QTtL2igoAMEHSjoIEEHCzpE0KGCDhN0uKAjBB0p6ChBRwuqElQtqEZQraA6QfWCBgk6RtCxgo4TdLygwYJOEDRE0FBBwwQNFzRC0EhBowSdKOgkfdJl74KVn1jsYzi2r+HYfoZj+xuODTQcO8Bw7EDDsYMMxw42HDvEcOxQw7HDDMcONxw7wnDsSMOxowzHjjYcqzIcqzYcqzEcqzUcqzMcqzccG2Q4dozh2LGGY8cZjh1vODbYcOwEw7EhhmNDDceGGY4NNxwbYTg20nBslOHYiYZjJynB3S99vb/9vL9OuNIsaIbtOPYGYPlf390Hh1W7Lw6rcj8clrs/DKvOHQjDqnEPgGHF3ANhWI57EAqrznEPRmHVOO4hKKyY4x6KwhK+fRgIq05gHQ7CqhFYR4CwYgLrSBCWjIVHYbDqJNbRGKwaiVWFwYpJrGoM1j99Rw0Eq+4frFoIVs0/WHUQrNg/WPUQrH/72kEIrLp/sY5BYNX8i3UsAiv2L9ZxCCxvbHI8AMv7+rQ7GIBV7WGdAMCq8LCGhMeKr30fGh7L9bGGhcaK1ftYw8NjVftYI8Jjxb8FMzI0VkUca1RorLI41omhsdw41klEkyL6SiUbcgcf62SczP+8ZA09USUnCPcimLg7Baxr9Go0ufpnb6BupJ5PIWjH0QzaEWnjexO14xhgO0re9Ml5qSd/En5MQWq7NMeK88YJGi9oQgHdqwXkKrd9CNr07P/vN/uS8idlHksg9zmWfJorSXHHAvuxiUAfB9qNy0UXXYC6aCig8WGb/MIUYycqcbUhxRg7SZw3WdAUQY2EMVauIt6XINaca3mMlTJPIpD7PCZ+PQnoi6cCYyzQblwuulgNqIupBTQ+bJNfmGLsqUpcnZpijJ0mzpsuaIagmYQxVu7S2I8g1pxveYyVMk8jkPsCJn49DeiLs4AxFmg3LhdddAXqYnYBjQ/b5BemGDtLiauzU4yxp4nz5giaK2geYYyVu+D2J4g1F1oeY6XMpxHIfRETvz4N6IvzgTEWaDcuF110A+piQQGND9vkF6YYO1+JqwtSjLELxXmLBC0WdDphjJW7jAcSxJqLLY+xUuaFBHJfwsSvFwJ9cQkwxgLtxuWii+5AXZxRQOPDNvmFKcYuUeLqGSnG2DPFeUsFnSXobMIYK9/icABBrLnU8hgrZT6TQO7LmPj1mUBfPAcYY4F243LRxerIOdQCGh+2yS9MMfYcJa6em2KMPU+cd76gCwRdSBhj5VtyDiSINZdbHmOlzOcRyH0FE78+D+iLFwFjLNBuXC66WAM59iyg8WGb/MIUYy9S4urFKcbYS8R5lwq6TNDlhDFWvoXsIIJYc6XlMVbKfAmB3Fcx8etLgL54BTDGAu3G5aKLNYG6uLKAxodt8gtTjL1CiatXphhjrxLnXS3oGkHXEsZY+ZbHgwlizdWWx1gp81UEcl/DxK+vAvridcAYC7Qbl4su1gLq4voCGh+2yS9MMfY6Ja5en2KMvUGcd6OgmwTdTBhj5Vt0DyGINddaHmOlzDcQyH0dE7++AeiLtwBjLNBuXC66WBuoi1sLaHzYJr8wxdhblLh6a4ox9jZx3u2C7hB0J2GMlW8pP5Qg1lxveYyVMt9GIPcNTPz6NqAv3gWMsUC7cbnoogdQF3cX0PiwTX5hirF3KXH17hRj7D3ivHsF3SfofsIYK78CcRhBrLnR8hgrZb6HQO6bmPj1PUBffAAYY4F243LRRU+gLh4soPFhm/zCFGMfUOLqgynG2IfEeQ8LekTQo4QxVn5l53CCWHOz5TFWyvwQgdy3MPHrh4C++BgwxgLtxuWii3WAuni8gMaHbfILU4x9TImrj6cYY58Q5z0p6ClBTxPGWPkVsyMIYs2tlsdYKfMTBHLfxsSvnwD64jPAGAu0G5eLLnoBdfFsAY0P2+QXphj7jBJXn00xxj4nznte0AuCXiSMsfIrkUcSxJrbLY+xUubnCOS+g4lfPwf0xZeAMRZoNy4XXfQG6uLlAhoftskvTDH2JSWuvpxijH1FnPeqoNcEvU4YY+VXeI8iiDV3Wh5jpcyvEMh9FxO/fgXoi28AYyzQblwuulgXqItlBTQ+bJNfmGLsG0pcXZZijH1TnPeWoLcFvUMYY+VXzo8miDV3Wx5jpcxvEsh9DxO/fhPoi+8CYyzQblwuulgPqIv3Cmh82Ca/MMXYd5W4+l6KMfZ9cd4Hgj4UtJwwxq5f0PQdPBU3bJvea3mMlTK/TyD3fUz8+n2gL34EjLFAu3G56GJ9oC4+LqDxYZv8whRjP1Li6scpxthPxHmfCvpM0OeEMXaDgqbviqq4Ydv0fstjrJT5EwK5H2Di158AffELYIwF2o3LRRcbAHXxZQGND9vkF6YY+4USV79MMcZ+Jc77WtA3gr4ljLEbFjR9p1nFDb1Oz/IYK2X+ikDuh5j49VdAX/wOGGOBduNy0cWGQF18X0Djwzb5hSnGfqfE1e9TjLE/iPN+FPSToJ8JY2yfgqbv3qu4Ydv0YctjrJT5BwK5H2Hi1z8AfXEFMMYC7cbloos+QF38UkDjwzb5hSnGrlDi6i8pxthfxXm/Cfpd0B+EMXYjgV1HEGsetTzGSpl/JZD7MSZ+/SvQF/8Exlig3bhcdLERUBd/FdD4sE1+YYqxfypx9a8UY+zf4rxIoagT1KaQLsb2FfepJ4g1j1seY6XMfxPI/QQTv/4b6IvZhTi+gHbjctFFX6AucgppfNgmvzDFWGmDfizNKUwtxuaK8/IE5QsqIIyxGwv9DiKINU9aHmOlzLKN0bhPMfHrXKAvFgJjLNBuXC662BgYY4sKaXzYJr8wxdhCJa4WpRhj24rz2glqL6gDYYzdROj3GIIY+7TlMVbK3JYgxj7DxK/bAn2xIzDGAu3G5aKLTYAxtriQxodt8gtTjO2oxNXiFGNsJ3FeZ0FdBK1GGGM3Ffo9liDGPmt5jJUydyKIsc8x8etOQF/sCoyxQLtxuehiU2CM7VZI48M2+YUpxnZV4mq3FGNsd3He6oLWELQmYYzdTOj3OIIY+7zlMVbK3J0gxr7AxK+7A31xLWCMBdqNy0UXmwFj7NqFND5sk1+YYuxaSlxdO8UY20Oc11PQOoJ6EcbYzYV+jyeIsS9aHmOlzD0IYuxLXN4LDfTF3sAYC7Qbl4suNgfG2HULaXzYJr8wxdjeSlxdN8UYu544b31BGwjakDDGbiH0O5ggxr5seYyVMq9HEGNf4bJHHuiLfYAxFmg3LhddbAGMsRsV0viwTX5hirF9lLi6UYoxtq84b2NBmwjalDDGOkK/JxDE2Fctj7FS5r4EMfY1LuuFgL64GTDGAu3G5aILBxhjNy+k8WGb/MIUYzdT4urmKcbYLcR5jiBXUAlhjHWFfocQxNjXLY+xUuYtCGLsG1zGTkBfjAJjLNBuXC66cIExtrSQxodt8gtTjI0qcbU0xRhbJs4rF1QhKEYYY0uEfocSxNhllsdYKXMZQYx9k4lflwF9sRIYY4F243LRRQkwxm5ZSOPDNvmFKcZWKnF1yxRj7FbivK0FbSNoW8IYGxX6HUYQY9+yPMZKmbciiLFvM/HrrYC+uB0wxgLtxuWiiygwxvYrpPFhm/zCFGO3U+JqvxRj7PbivB0E7ShoJ8IYWyr0O5wgxr5jeYyVMm9PEGPfZeLX2wN9cWdgjAXajctFF6XAGLtLIY0P2+QXphi7sxJXd0kxxvYX5+0qaDdBuxPG2DKh3xEEMfY9y2OslLk/QYx9n4lf9wf64h7AGAu0G5eLLsqAMXbPQhoftskvTDF2DyWu7plijB0gzttL0N6C9iGMseVCvyMJYuwHlsdYKfMAghj7IRO/HgD0xX2BMRZoNy4XXZQDY+x+hTQ+bJNfmGLsvkpc3S/FGLu/OG+goAMEHUgYYyuEfkcRxNjllsdYKfP+BDH2IyZ+vT/QFw8Cxlig3bhcdFEBjLEHF9L4sE1+YYqxBylx9eAUY+wh4rxDBR0m6HDCGBsT+j2RIMZ+bHmMlTIfQhBjP2Hi14cAffEIYIwF2o3LRRcxYIw9spDGh23yC1OMPUKJq0emGGOPEucdLahKUDVhjK0U+j2JIMZ+anmMlTIfRRBjP2Pi10cBfbEGGGOBduNy0UUlMMbWFtL4sE1+YYqxNUpcrU0xxtaJ8+oFDRJ0jBJj/dIGrOfiCK496wppbDsbLHMh0LY7ALGOBbaftJviSFNfohZ0f43kW+X3uEJCho8rxOMeDwx0VHIfX9jUwCDcf4xNOmmbCL2xFRbQBBk0nx0KaJxisGK3+Le5AEdNWZ5RZClM53iUjqiEVIBq2Cd4DjREykShgMEEkWkwuGumkrsNodyht9YQt6ETrrjSMIcSpI/DwN27HxQkboOHi26LIURtMZyoLYYHtEXoVxsQtcUX/9/plJok/JHZwJft7Y4DsuMbShBLgfp2kW0oBxS5EfPoM9LCNkhmUyomRfxGtYk6wBoRNGJ0whV3KFFAVJluIc9usvtInkcQBIavLJnba8lAJqzMIwvtDDBftaexy5FKR91a/SRrc6R+RilYbjQqfKO2wq2vrY+WVVSWVLvl0fLy+tL6ivJYaW19WWlVbUWdW1oVLamsq3Dq3VhdXUVZtKaivL6ytqa8Xg3abm00WlpbWV3jlpWUV1U7sdpolVNfWhEtcapqoxW1tdFYeXlVNFpbHquPVcZKSqrqozGnrKKi0ikviVaWUOlnlKefdGaahUSZ5olepnkSlwBOxd+JBMH6ZKKO62TCrEa2xUkEbXEKUVucQpjVUNnFN5ZnNVQ28K3lWU0hUVYD1Lf7bSar0Yt7IlFWM5pjVjOaOKsZTRAYvvsPZjVjCu0MMN8RjZrHMMtqxgKzmm+BWQ2VfsYqWU2iTsHm6ShKPqk6mHEcO5hxxB3MOIIO5nuiDiYXzCcygI0HYiGnzZCd1fdEwXB8Cp1V2DadUIjrFJpNm1nUWVHpZ8IqNAU30ZuCazAt9nDCFTfRoococBVPWCzgwhGXQvF+G2YzacOwWJMs14d0mEkEg4TJRAOmyYTTtQ1EbTGFqC2mEE7XUtnFT5ZP11LZwM8MpmsnEUzXAvXt/pyZrtXLP/Eb1SbqwK+RMpueRBQQGwmzaclzI0FgWMFkunYScFB0aqGdAWYFUYZ1ahqma5H6mQqcrv0ZmAFT6Wfq/yEDptruMM3LgKdzCeBU/E0jCNYziDquGYRZjWyL6QRtMZOoLWYSZjVUdvGr5VkNlQ38xmBpPUVWA9S3+1smq9GLO40oq5nFMauZRZzVzCIIDL//B7Oa2YV2BpjfiUbNs5llNacBs5rfgFkNlX5O+z8sQplYSOP3XDqYORw7mDnEHcwcgg7mDyaLUJABbC4QCzlthuys/iAKhnPTsAhlHnARys/t7eysqPQzz6Af9BoB4KITtxj4Hqn5wLiezvdIzSfqRBcUEjK8oBCPuxAYmKnkXljY1MAg3LS+R6qYyXukConeI7WokPA9UguBqasa1X2mV4WlhYs9Bzq9kOA9UlIBiwgi0yLiBzUoudsQyh2WxyWWP+yShrmEIMU6gyjdPIPwYdfpRG1xJlFbnEn4sIvKLv62/GEXlQ1EOti/hG8JQSwF6ttFtuGq8rBrMVEatZRyLnIJUUBcSjgXKXleShAYssCBwS/oh11LgIOiswrtDDBIXah2eVYaHnYh9XM28GGXGrTDzh9S6efs/8MSvmKiTPMcL9M8l0sAp+LvHIJgfR5Rx3UeYVYj2+JcgrY4n6gtzifMaqjsIpt4dB82q6GygRzLs5pioqwGqG83J5PV6MU9hyiruYBjVnMBcVZzAUFgyP0PZjUXFtoZYHKJRs0XMstqLgJmNTnArIZKPxf9H5bwLS6k8XsuHczFHDuYi4k7mIsJOpg8og4GvYQPGcAuAWIhp82QnVUeUTC8JA1L+C4FLuFrNm1mUWdFpZ9LV6EpuMu8KbjLTYs9nHDFTbToAbmKJywWcOEIyXuL/DZErxGlasOwWFdYrg/pMFcQDBKuJBowXUk4XXs5UVtcRdQWVxFO11LZRaHl07VUNlDEYLr2CoLpWqC+3aLMdK1e/onfqDZRB35XU2bTVxAFxKsJs2nJ89UEgaEtk+naK4CDomsK7QwwbYkyrGvSMF2L1M+1wOnaImAGTKWfa/8PGTDVdofrvAz4ei4BnIq/6wiC9Q1EHdcNhFmNbIvrCdriRqK2uJEwq6Gyi/aWZzVUNtCBwdJ6iqwGqG+3Qyar0Yt7HVFWcxPHrOYm4qzmJoLA0PE/mNXcXGhngOlINGq+mVlWcwswq+kAzGqo9HPL/2ERymWFNH7PpYO5lWMHcytxB3MrQQdTzGQRCjKA3QbEQk6bITurYqJgeFsaFqHcDlyEUtTBzs6KSj+3E86AbCeywB0K8DHoDuJZMETsucOw1sIJV5D9kHsHMKbdabk+5DsF7yToC+8CrzFBr2+SszBIHjt4eBGsXZPMQHX0eEXr/G6grafz3XN3Ew287ykkZPieQjzuvcDARyX3vf9xJ7uPKJtFB1ikLd1veWeSLXSN5FHq+P402XlY2f/M/9cn0Y8zkPbzANOO6a98mo7pwUJChh8k6JgesrxjknI/xKRjkg77AEHH9LDl6y+kfh4mCFQPAG3zEcuzxb8ZBPtHmQb7CNHLfh8rJGT4MYJg/7jlwV7K/TiTYC8d9lGCYP+E5cFe6ucJgkD1KNA2n7S8DX/L55Nt/86I1z8Y8SoHN48QxI+nLLd9qZ+nCOS+13K5ZXx7kkDupxno++n/oL6zCmhikRw4d4qY1/eg++Sf8nH6ygo/CI8vPzGIDsNW2/UZT3/PFnoG4j+/fsYzaPWYPKmXxlRLF8glY5JKIa3EKvFXBz8DHLw9W4g1FIqB/zMEAe05y2cofvLkRq8vQNo00g6fBz52UOPE80qcoAjYyDaQMULioddO/ZSP7WhRWMi2ewGpB8V+XlDsh+KR0zMEyf2fQB9/kcFMLkUb/g1sw5fAbQiWtexvLY454co/E4tSZvR6X0TfVVf/T6n5mygmhuULGRNfxum0NKIU9LIDpMyvgJdYoMezUievEIxnXyXav/Cq1/+ZEmF0HJJ28CfQL2XfJZ9oo96H5vvon/mrrL/7uVxZxFBA2M2S/te8pP91Pel/zZD0vx4wGHPClX+WPrxI4Jhr2r2Nu+xPogT7y45Yuf2CSo44OXNYrK+IdAEa4MUntl4Dyvw6cCAA9GEX6BcuQK/xgJ9KB4/wD3RyaurgnXClDDgIKUMmVogB/b+qqK+OGArIlpp18G94HfwyvYN/w9DBLzPM6qODzBvAILOskGaggOx8beg8VKNDD9xkNvUawQDmzUKaThOdPSPt+S3Ls2epk7cIZvveBLbh25Y/Kpeyvk3gL+8UwgYK9elcr/oO0a65dwsJGX6XYL3qe5avV5Vyv1fY1MAgXBJeX/F4RTvZ+5Y/jvHlRgfoV4C2+YHlj2P+BD+O8We2/ivToB/i2q7MpF/Eoyf047bnCmmm41E6WW63z/2TWQNjqytjzIcE8f8j8KYgjmsb/wg/O5P2tY0fe+OWT/RZkI8NsyCfMFvb+Ed4rPjszMfAoPOJ5WsbZYBdThAkelv+5mA5mPuIQO51LXkxapIC9b1PgZ0W0G7cdS23QRlnPiWwwc+I1mF8RrgOUcbvjwnWGv+Rj9UXSt7PidaKfs6s3/7iPxI7/IKeeUfa5JeWz7xLW/mSIF5+RRQvvwpYt5bIHpxwxf3DMt/0JtPrDaKTJDlfe0nON3qS87UhyfkmDcGSSiFhk5yvgYHjG6ChtMRZLMji/eJ+gUv0XIPoJM7yrecs3+nO8q3BWb5LwVlsVUhYZ/kW6CzfgQ0F3cvKHvZrgl72eyZrGZC6/sHyEZXUyQ8Ej8q+B7bhj5avZZCy/kjgLz8xXcvwE9Fahp8LCRn+mWAtwwrL1zJIuVcUNjUwCJeE1y89XtFO9ovlaxl8udEB+kugbf6apo7dCVegmdhvYN9GyyoHv0DbdqWOfyPwv98tfyYv39uGnBb7Pb/pOSyQz3+eo7dtgm3W0f+h3K9ZZT+QEv/ENVC55K1zpCmzlP+X+H95vzeKNP3ukN30u6P327/uL3HN31LwIlFf1PTp57S9bppoFNSmiJDhODjQOGSjt4vwa/Q8hc9sr11yvL+53t8872++97egKNJ8zkRWFGhCo/PVLGADSoFQDWjy5IPymzxWNqr/O0f5fXB+c08uFHVFgtoKalfUdDyuHK09nXDFzcW1gVtYhNNz+yKaYRa6/YBO6BYB268DsW23V2y4g/K7rfK7XVFz2+4o/l8sqJOgzv+HXiof0L7eHEOdym+XIkKGJTgqiPrMdwE6/WpAo6VqQ8kjahjot+FqxA5Wp3QekuJDP8XB6rXOo6uo6yaou6DVi5rjZdpUtI0yhC5Q2rFrQJuuIerWFLSWoLUJ27RcAC/Px6crfSxfFrYil0bujZgsTZTyo2TuAYzrQLtxgbpo9qpJKW+vSFpelfSPf6q6csKVf/S+IreJ37C43rOPtK2v7+kNetbRs8B1iiIJ10064UpcCehg0ZdBkKSQe+M0BcmwKxJ6AgeZ6wCDJNBuXIQuTEEAbTM9i+z2la7ZNL7SCyi3jJUDIk1x8kQxAJL4co73/0F6QW1cje+PwbVdCdDnStDxDz3b2dFLtFC+IbHWKMIPjjoC4/O6QD9r4/mZXlBy+3joGNa7CN8vo3lcl4DHiMmJnHClWWOGNc71ivDGI4vNWeX6q35WyTZQrMcgUKxPFSjQo5QNVuHMwMdSM/UNlOkThs9g6lV+N6R8BrMh/hlM/YbIqMrgGUwf/POC+j7/p2cw6wY8L9hI1PUVtLGgTYifwXBs00TPYDYKaNNNRd1mgjYXtIXy4Dgvkp6glQNsk/YKn44XtFzvb4n3N+r9LfX+lnl/y72/Fd7fmPe30vu7pfd3K+/v1vrcbEnRyjudygzHYoZjWynHdKWepjiKoyjSVX7P0ZS6jajbVtB2snGL6Fe6lAAD7jbAgLs9k5UuUWD7bQtsvx2YtF8psP22A7bfjsQBf3slBuyg/N5R+d1PWym0k/j/zoJ2EdQ/DbGhDKibnYC62ZWJbZcD229nYPvtxqT9KoDttwuw/XYnjg27KjFgN+X37srv/lps2EP8f09BAwTtlYbYEAPqZg+gbvZmYtuVwPbbE9h++zBpvy2B7TcA2H77EseGvZUYsI/ye1/l915abNhP/H9/QQMFHZCG2LAVUDf7AXVzILFuDlR0sL/ye6Dy+wBNNweJ/x8s6BBBh3q6MWFfo+SSByl4WwdMEBwm6g4XdISgI5UJAv8eekFPEBwGfmbpl6O8RP5oPZGXFQ3asaO9Y2pBG/xhQCM9KnWsmiRY7tFABUijkQvz2kQSl1TvlYzvCKFRHgUOAn6p0o2xqmhlL0M/m2mBMG4yYaqARlxdBDOGZm9Tq07BmcPyfjSwHZBtWtOCNk12L7VNa5SgWaC0p9qmTrji/hWMV1JT70bL6irKnPKq0rLa8mhJbUmFU1taVu8KhksqS0XT1NeUxmpjJdH6koqSmr+w/P1jY35g8zsSv1c92vtdK/7WCaovipDaH3JGsRZof4PAnUm6nq0OIgr4xxQRMnxMER73WKAxUMl9rOJcINzANDRsOyCnr+uA+jmOqbMeR+SsxxcRMnw8gbMOttxZpdyD0+ysTrjSrDd0whVoMD0BbPT+mzxPUEYxdUXN35niP7OOKsdLDecMEceGChrm2biPXZsAu76oCTvZOcPF3xGCRhbR+Oaxno2i9zyMAs+RovmjkvtEoP9ElNIGzGc90DdPAsusy+qEK670T6RepE+OIrCdk4meK6BtpwxoO6dYbjtRL5tF4UlfOZnAdkaDbYfCZmrBdjOaYEyJXLBnekaRaI1bScAzijGibqygcYLGF9EtDH1T3PdDghcqTCAeCzjhivsWkdwTLZf7bSK5G4h9aILiKxOV3w0BPjRJ1E0WNEVQY1Hy57th22AMsM+YBIybpzKd9DgVbFN+mVpEyPBUgg5qmuWTHlLuaQSTHtLYhE9H2qTB2MaAA7dekG3il+lem8/w/s70/s5SbBAe6acBo5z6vG1mUeIdA9OVKD9D+T0zIPrPFnWnCZojaK4S/dHZwhjP+JHtK3lHj8aRvdNscI+SjtcxfQj8fo7cMC3xIiA+0/06pnleoJivL86YV7TyVh55Ui/vQnTU9RWDDlJlDF7RRCF3OZNXNM0DBsz5wMAGtBu3HPyKJopR5TyCaal5lqfAXOT2C7YzjDofAr/1sQAos+xvDhe0j4cnU36Z6ssU/xPBs7zX/+uVVxxJL+jpjoU43ZcB425ZOZPPEyOThkXgRyromCttZRFBzF0MjD9tvPijFxS+j4du28VF9vN4OppHdIY43TNQlGFKrNOL8HyeDuRxCR/nIXslFgfnWUI0sISPCM5Y9UcEJL2jDBZnEPSOZ2Z6R/dMBg6+1PbecQZB77iUoHdcCuTxrEzvyMJ5zuLSO5696veOJRQKlsHibILe8ZxM7+iew8DBz7W9d5xJ0DueS9A7ngvk8bxM78jCec7j0juev+r3jlEKBctgcT5B73hBpnd0L2Dg4BeieUQzOIto6n8b4iUeiF5cKge9W/NCYC9+EfCx0TYdMiMCDgHjIi4jgotX/RFBKYWCZeC5mCDgXpIZEbiXMHDwS6lHBIie8VJ4zxiFLoK4FNjLXpbJlVk4zmVcesbLV+EVrz4WhYJlgLicoGe8ArxRzV95f4W38p5rbylXIdrO45VIp+eqqIPy7efxKqrojI4GV+MYLeFqUFcz6O6vyXi+43ZjEKKvzSjKcesYhOjruITo64FTS1wN6noGIfqGjOc77p+F9vN4Y0ZRjvs1gxB9E5cQfTOO0RhXg7qZQYi+hYtB3YpjtJKrQd3KwKBu42JQt+MYreJqULczMKg7uBjUnThGq7ka1J0MDOouLgZ1N47RGq4GdTcDg7qHi0Hdi2O0lqtB3cvAoO7jYlD34xit42pQ9zMwqAcy8zvigRGD+Z0HuXj+QzBGXbarCR9i4PkPczGoR3AG5XI1qEcYGNSjXAzqMZxBsV3H8RgDg3qci0E9gTOoKFeDeoKBQT3JxaCewhlUKVeDeoqBQT3NxaCewRkU23UxzzAwqGe5GNRzOIMq52pQzzEwqOcz8zuOm19gP48vcPH8F3Gez3b9zosMPP8lLgb1Ms6g2K7feZmBQb3CxaBexRkU2/U7rzIwqNe4GNTrOINiu37ndQYG9QYXg1qGMyi263eWMTCoN7kY1Fs4g2K7fuctBgb1NheDegdnUGzX77zDwKDe5WJQ7+EMqp6rQb3HwKDe52JQH8AYLWG7zugDBgb1IReDWo4zKLbrjJYzMKiPuBjUxziDYrvO6GMGBvUJF4P6FGdQbNcZfcrAoD7jYlCf4wyK7TqjzxkY1BdcDOpLnEGxXWf0JQOD+oqLQX2NMyi264y+ZmBQ33AxqG9xBlXB1aC+ZWBQ33ExqO9xBsV2PdT3DAzqBy4G9SPOoNiuh/qRgUH9xMWgfsYZFNv1UD8zMKgVXAzqF5xBsV0P9QsDg/o1s/jfcdszeBH2b1w8/3ec57NdZ/Q7A8//g4tB/YkzKLbrjP5kYFB/cTGov3EGxXad0d8MDCrSlolBZcEYjbJdZ5TV1n4e23AxqGycQbFdZ5TNwKByuBhULs6g2K4zymVgUHlcDCofZ1Bs1xnlMzCoAiSPXBV1GoOXdxZmFOW4HzFQVBGXEN0WF6LZrotpyyBEt+NiUO1xBsV2XUx7BgbVgYtBdcQZFNt1MR0ZGFQxF4PqhDMotutiOjEwqM5cDKoLzqDYrovpwsCgVuNiUF1xBsV2XUxXBgbVjYtBdccZFNv3BHVnYFCrczGoNXAGxXb9zhoMDGpNLga1Fs6g2K7fWYuBQa3NxaB64AyK7fqdHgwMqicXg1oHxmgp2/U76zAwqF5cDKo3zqDYrt/pzcCg1uViUOvhDIrt+p31GBjU+lwMagOcQbFdv7MBA4PakItB9cEZFNv3BPVhYFAbcTGovjiDYvueoL4MDGpjLga1Cc6g2K6H2oSBQW3KxaA2wxkU2/VQmzEwqM25GNQWOINiux5qCwYG5XAxKBdnUGzXQ7kMDKqEi0FFcQbFdj1UlIFBlXIxqDKcQbFdD1XGwKDKuRhUBc6g2K6HqmBgUDEuBlWJMyi266EqGRjUllwMaiucQbFdD7UVA4PamotBbYMzKLbrobZhYFDbonlsAzakdYsikT64F0O5EmvTopX5dMIVd90inMzbgZWCNppP8iORaUX4oLF9B5rolg3ms19bYJDAyewi20/qtrOgHA9P/l++CuEv77e0Uf93P+V3vXeOf932om4HQTsK2qlt03G/oP2wB9APdwbqOcuzQ/lX4vby2qgg0mSfakH77PbEMSVsW69W9K9NoeXejmjEBF88TfGmSmlgnSJNTkYpwIrc8Fj1/xbHwG5YbNf/obbFLm3//du/rdcgvof29zxULdmEDdZK7ynxvMfdpS3OE/u3pVEkOmLsYvkoSer303y83LsykHs5gdy7MZD7KwK5dwfKLWPYkRLHw5O2JNtV3qNDNj/SC3g0GQXE6Lge9wDqsY2nR72A8F0fD+0jezCYEtmeaMQIT3X2AHb6ewJTHa7GuScD4+xRxMQ49wQa54C2WOOhyl3RbbgdsA33yvQ+7gAGDo7UU8Q0iXeQMomn/t4o0vT7YG0Sb2/B1D6C9hW0n2ESD50a/1GIw9ob6ET7Ew0N0O33F7D99gG230Bg+5lse39lInqg8ntf5fd+bZvb9gHi/wcKOkjQwZ5tS2ovKDeyckE7PFBXFPNmcT796THKe1C18UYR+wP/H0R2gObzACYT6ju3pfUr+GhvZ2CgPYToydUhhnlx9Gj6UADvZeVlTlmdEzN1EvITmH5ncGhb8wBIf4p5mDjvcEFHCDpS6SQ6RBIHRaBtlGRFzA9xEPfw2yqRPp1whST4UvB5GLeAcQgwYBxFFDCOUh51d4ysnDlQKDIr8t82ODSfhzDhMztCwKd02gGRlQv6RujG6MDg+8FHIw2Lq6IOYvB9maqMohz3agafJ63OKMpxuzEIfTUZRTluHYPQV5tRlONezyD01WUU5bh/FtrPY31GUY77NYPQNyijKMe9mUHoOyajKMe9lYGijs0oynFvZ6Co4zKKctw7GSjq+IyiHPduBooanFGU497LQFEnZBTluPczUNSQjKIc9xoGedTQjKIc9yEGHjUsoyjHfYSBooZnFOW4jzFQ1IiMohz3CQaKGplRlOM+xUBRozKKctxnGCjqxIyiHPc5Boo6KaMox80vsJ/HkzOKctwXGXjUKRlFOe7LDBQ1OqMox32VgaLGZBTluK8zUNTYjKIcdxkDRY3LKMpx32KgqPEZRTnuOwwUNSGjKMd9j4GiJqIVRfgumP/0/qiGjKJ47I+alFEUj/1RkzOK4rE/akpGUTz2RzVmFMVjf9SpGUXx2B81NaMoHvujpmUUxWN/1PSMonjsj5qRURSP/VEzM4risT9qVkZRPPZHzc4oisf+qNMyiuKxP2pORlE89kfNzSiKx/6oeRlF8dgfNT+jKB77oxZkFMVjf9TCjKJ47I9alFEUj/1RizOK4rE/6vSMonjsj1qSURSP/VFnZBTFY3/UmRlF8dgftTSjKB77o87KKIrH/qizM4risT/qnIyieOyPOjejKB77o87LKMpxP2CgqPMzinLc5QwUdUFGUY77MQNFXZhRlON+ykBRF2UU5bifM1DUxRlFOe6XDBR1SUZRjvs1A0VdmlGU437LQFGXZRTluN8zUNTlGUU57o8MFHVFRlGO+zMDRV2ZUZTj/sJAUVdlFOW47Rm8EOTqjKIc93cGHnVNRlGO+ycDRV2bUZTj/s1AUde1xfP4T2mjMRp1yktL6ypK6tyoW+WUVFbHypzSsurymBtzy2JltSWxaLQuVhqrqKyurHAq3dJonVtfVhmtV8BRQveN0AiNljkLKPPGTGRuA5R5EyYyZwNl3jRNMjvhirsZsP2Ks2lkRgfbzSM8+NyCCZ8OEz5doK1LDHT8+bgwEvm0EIf3pcD6vRDfjiURHrEtCtTN0W15yFwKlLmKicxlQJmrmchcDpS5honMFUCZa5nIHAPKXMdE5kqgzPVMZN4SKPMgJjJvBZT5GCYybw2U+VgmMm8DlPk4JjJvC5T5eCYybweUeTATmfsBZT6BiczbA2UewkTmHYAyD2Ui845AmYcxkXknoMzDmci8M1DmEUxk3gUo80gmMvcHyjyKicy7AmU+kYnMuwFlPomJzLsDZT6Zicx7AGU+hYnMewJlHs1E5gFAmccwkXkvoMxjmci8N1DmcUxk3gco83gmMu8LlHkCE5n3A8o8MU0y27RubP8IDz0PBLbfakzWEx0Q4cHngUz4PIgJnwcz4fMQJnweyoTPw5jweTgTPo9gwueRTPg8igmfRzPhs4oJn9VM+KxhwmctEz7rmPBZz4TPQUz4PIYJn8cy4fM4Jnwez4TPwUz4PIEJn0OY8DmUCZ/DmPA5nAmfI8B8oudjJxRFItOKcHiLBNaVRfh2HGl5O04kaMerCNpxlOXt2EDQjtcQtOOJ4HbMArejlPvaIvyzjJOAPG7fwW5blHa4AGyL1xHY4skMbPEGArlPYSD3jQRyj2Yg900Eco9hIPctBHKPZSD3bQRyj2Mg9x0Eco9nIPddBHJPYCD3PQRyT2Qg930EcjcwkPsBArknMZD7QQK5JzOQ+2ECuacwkPtRArkbGcj9OIHcpzKQ+0kCuacykPtpArmnMZD7WQK5pzOQ+3kCuWcwkPsFArlnMpD7JQK5ZzGQ+xUCuWczkPs1ArlPYyD3GwRyz2Eg95sEcs9lIPfbBHLPYyD3uwRyz2cg9/sEci9gIPeHBHIvZCD3RwRyL2Ig9ycEci9mIPdnBHKfzkDuLwjkXsJA7q8I5D6DgdzfEMh9JgO5vyOQeykDuX8gkPssBnL/RCD32QzkXkEg9zkM5P6VQO5zGcj9G4Hc5zGQ+w8Cuc9nIPdfBHJfwEDuSFu83BcykLsNgdwXMZA7h0DuixnInUcg9yUM5C4gkPtSBnIXEsh9GQO5iwjkvpyB3O0I5L6CgdwdCOS+koHcxQRyX8VA7s4Ecl/NQO7VCOS+hoHc3QjkvpaB3KsTyH0dA7nXJJD7egZyr00g9w0M5O5JIPeNDOTuRSD3TQzkXpdA7psZyL0+gdy3MJB7QwK5b2Ug90YEct/GQO6NCeS+nYHcmxLIfQcDuTcnkPtOBnI7BHLfxUDuEgK572YgdymB3PcwkLucQO57GcgdI5D7PgZyb0kg9/0M5N6aQO4HGMi9LYHcD4Ll9ksbMJ8PAdvyACbfonkYKPPORDKj7fGRCA8+H2XC52NM+HycCZ9PMOHzSSZ8PsWEz6eZ8PkMEz6fZcLnc0z4fJ4Jny8w4fNFJny+xITPl5nw+QoTPl9lwudrTPh8nQmfbzDhcxkTPt9kwudbTPh8mwmf7zDh810mfL7HhM/3mfD5ARGf6DnKDyO4OcoGJvOyy4EyT2Ii80dAmSczkfljoMxTmMj8CVDmRiYyfwqU+VQmMn8GlHkqE5k/B8o8jYnMXwBlns5E5i+BMs9gIvNXQJlnMpH5a6DMs5jI/A1Q5tlMZP4WKPNpTGT+DijzHCYyfw+UeS4TmX8AyjyPicw/AmWez0Tmn4AyL2Ai889AmRcykXkFUOZFTGT+BSjzYiYy/wqU+XQmMv8GlHkJE5l/B8p8BhOZ/wDKfCYTmf8EyryUicx/AWU+i4nMfwNlPpuJzPLhJErmc5jInAWU+VwmMrcBynweE5mzgTKfz0TmHKDMFzCRORco84VMZM4DynwRE5nzgTJfzETmAqDMlzCRuRAo86VMZC4CynwZE5nbAmW+nInM7YAyX8FE5vZAma9kInMHoMxXMZG5I1Dmq5nIXAyU+RomMncCynwtE5k7A2W+jsn7Frpk8eBzNSZ8dmXCZzcmfHZnwufqTPhcgwmfazLhcy0mfK7NhM8eTPjsyYTPdZjw2YsJn72Z8LkuEz7XY8Ln+kz43IAJnxsy4bMPEz43YsJnXyZ8bsyEz02Y8LkpEz43Y8Ln5kz43IIJnw4TPl0mfJYw4TPKhM9SJnyWMeGznAmfFUz4jDHhs5IJn1sS8ak/Mwv7nCsLKPNW/0GZt2YiczZQ5m3SJLMTrrjbAp8HH8bkGfh2QJkPYfIMvB+TPmF7JnzuwITPHZnwuRMTPndmwucuTPjsz4TPXZnwuRsTPndnwuceTPjckwmfA5jwuRcTPvdmwuc+TPjclwmf+zHhc38mfA5kwucBTPg8kAmfBzHh82AmfB7ChM9DmfB5GBM+D2fC5xFM+DySCZ9HMeHzaCZ8VjHhs5oJnzVM+KxlwmcdEz7rmfA5iAmfxzDh81gmfB7HhM/jmfA5mAmfJzDhcwgTPocy4XMYEz6HM+FzBBM+RzLhcxQTPk9kwudJTPg8mQmfpzDhczQTPscw4XMsEz7HMeFzPBM+JzDhcyITPhuY8DmJCZ+TmfA5hQmfjUz4PJUJn1OZ8DmNCZ/TmfA5gwmfM5nwOYsJn7OZ8HkaEz7nMOFzLhM+5zHhcz4TPhcw4XMhEz4XMeFzMRM+T2fC5xImfJ7BhM8zmfC5lAmfZzHh82wmfJ7DhM9zmfB5HhM+z2fC5wVM+LyQCZ8XMeHzYiZ8XsKEz0uZ8HkZEz4vZ8LnFUz4vJIJn1cx4fNqJnxew4TPa5nweR0TPq9nwucNTPi8kQmfNzHh82YmfN7ChM9bmfB5GxM+b2fC5x1M+LyTCZ93MeHzbiZ83sOEz3uZ8HkfEz7vZ8LnA0z4fJAJnw8x4fNhJnw+woTPR5nw+RgTPh9nwucTTPh8kgmfTzHh82kmfD7DhM9nmfD5HBM+n2fC5wtM+HyRCZ8vMeHzZSZ8vsKEz1eZ8PkaEz5fZ8LnG0z4XMaEzzeZ8PkWEz7fZsLnO0z4fJcJn+8x4fN9Jnx+wITPD5nwuZwJnx8x4fNjJnx+woTPT5nw+RkTPj9nwucXTPj8kgmfXzHh82smfH7DhM9vmfD5HRM+v2fC5w9M+PyRCZ8/MeHzZyZ8rmDC5y9M+PyVCZ+/MeHzdyZ8/sGEzz+Z8PkXEz7/ZsJnpA0PPrOY8NmGCZ/ZTPjMYcJnLhM+85jwmc+EzwImfBYy4bOICZ9tmfDZjgmf7Znw2YEJnx2Z8FnMhM9OTPjszITPLkz4XI0Jn12Z8NmNCZ/dmfC5OhM+12DC55pM+FyLCZ9rM+GzBxM+ezLhcx0mfPZiwmdvJnyuy4TP9ZjwuT4TPjdgwueGTPjsw4TPjZjw2ZcJnxsz4XMTJnxuyoTPzZjwuTkTPrdgwqfDhE+XCZ8lTPiMMuGzlAmfZUz4LGfCZwUTPmNM+KxkwueWTPjcigmfWzPhcxsmfG7LhM/tmPDZjwmf2zPhcwcmfO7IhM+dmPC5MxM+d2HCZ38mfO7KhM/dmPC5OxM+92DC555M+BzAhM+9mPC5NxM+92HC575M+NyPCZ/7M+FzIBM+D2DC54FM+DyICZ8HM+HzECZ8HsqEz8OY8Hk4Ez6PYMLnkUz4PIoJn0cz4bOKCZ/VTPisYcJnLRM+65jwWc+Ez0FM+DyGCZ/HMuHzOCZ8Hs+Ez8FM+DyBCZ9DmPA5lAmfw5jwOZwJnyOY8DmSCZ+jmPB5IhM+T2LC58lM+DyFCZ+jmfA5hgmfY5nwOY4Jn+OZ8DmBCZ8TmfDZwITPSUz4nMyEzylM+GxkwuepTPicyoTPaUz4nM6EzxlM+JzJhM9ZTPiczYTP05jwOYcJn3OZ8DmPCZ/zmfC5gAmfC5nwuYgJn4uZ8Hk6Ez6XMOHzDCZ8nsmEz6VM+DyLCZ9nM+HzHCZ8nsuEz/OY8Hk+Ez4vYMLnhUz4vIgJnxcz4fMSJnxeyoTPy5jweTkTPq9gwueVTPi8igmfVzPh8xomfF7LhM/rmPB5PRM+b2DC541M+LyJCZ83M+HzFiZ83sqEz9uY8Hk7Ez7vYMLnnUz4vIsJn3cz4fMeJnzey4TP+5jweT8TPh9gwueDTPh8iAmfDzPh8xEmfD7KhM/HmPD5OBM+n2DC55NM+HyKCZ9PM+HzGSZ8PsuEz+eY8Pk8Ez5fYMLni0z4fIkJny8z4fMVJny+yoTP15jw+ToTPt9gwucyJny+yYTPt5jw+TYTPt9hwue7TPh8jwmf7zPh8wMmfH7IhM/lTPj8iAmfHzPh8xMiPttofEad8tLSuoqSOjfqVjklldWxMqe0rLo85sbcslhZbUksGq2LlcYqKqsrK5xKtzRa59aXVUbrPew+QJk/TZPMTrjiftYG135HteWh5xxg+33OxLZzgTJ/wUTmPKDMXzKROR8o81dMZC4Ayvw1E5kLgTJ/w0TmIqDM3zKRuS1Q5u+YyNwOKPP3TGRuD5T5ByYydwDK/CMTmTsCZf6JiczFQJl/ZiJzJ6DMK5jI3Bko8y9MZO4ClPlXJjKvBpT5NyYydwXK/DsTmbsBZf6DiczdgTL/yUTm1YEy/8VE5jWAMv/NROY1gTJHsnnIvBZQ5iwmMq8NlLkNE5l7AGXOZiJzT6DMOUxkXgcocy4TmXsBZc5jInNvoMz5TGReFyhzAROZ1wPKXMhE5vWBMhcxkXkDoMxtmci8IVDmdkCZBdQ/a3yWewL3FbSxoE0EbSpoM0GbC9pC3kuQK6hEtoegUkFlgsoFVQiKCaoUtKWgrQRtLWgbQdsK2s6Tf3tBOwjaUdBOgnYWtIug/oJ2FbSboN0F7SFoT0EDBO0laG9B+wjaV9B+gvYXNFDQAYIOFHSQoIMFHSLoUEGHCTpc0BGCjhR0lKCjBVUJqhZUI6hWUJ2gekGDBB0j6FhBxwk6XtBgQScIGiJoqKBhgoYLGiFopKBRgk4UdJKgkwWdImi0oDGCxgoaJ2i8oAmCJgpqEDRJ0GRBUwQ1CjpV0FRB0wRNFzRD0ExBswTNFnSaoDmC5gqaJ2i+oAWCFgpaJGixoNMFLRF0hqAzBS0VdJagswWdI+hcQecJOl/QBYIuFHSRoIsFXSLoUkGXCbpc0BWCrhR0laCrBV0j6FpB1wm6XtANgm4UdJOgmwXdIuhWQbcJul3QHYLuFHSXoLsF3SPoXkH3Cbpf0AOCHhT0kKCHBT0i6FFBjwl6XNATgp4U9JSgpwU9I+hZQc8Jel7QC4JeFPSSoJcFvSLoVUGvCXpd0BuClgl6U9Bbgt4W9I6gdwW9J+h9QR8I+lDQckEfCfpY0CeCPhX0maDPBX0h6EtBXwn6WtA3gr4V9J2g7wX9IOhHQT8J+lnQCkG/CPpV0G+Cfhf0h6A/Bf0l6G9B0tGyBLURlC0oR1CuoDxB+YIKBBUKKhLUVlA7Qe0FdRDUUVCxoE6COgvqImg1QV0FdRPUXdDqgtYQtKagtQStLaiHoJ6C1hHUS1BvQesKWk/Q+oI2ELShoD6CNhLUV9DGgjYRtKmgzQRtLmgLQY4gV1CJoKigUkFlgsoFVQiKCaoUtKWgrQRtLWgbQdsK2k5QP0HbC9pB0I6CdhK0s6BdBPUXtKug3QTtLmgPQXsKGiBoL0F7C9pH0L6C9hO0v6CBgg4QdKCggwQdLOgQQYcKOkzQ4YKOEHSkoKMEHS2oSlC1oBpBtYLqBNULGiToGEHHCjpO0PGCBgs6QdAQQUMFDRM0XNAIQSMFjRJ0oqCTBJ0s6BRBowWNETRW0DhB4wVNEDRRUIOgSYImC5oiqFHQqYKmCpomaLqgGYJmCpolaLag0wTNETRX0DxB8wUtELRQ0CJBiwWdLmiJoDMEnSloqaCzBJ0t6BxB5wo6T9D5gi4QdKGgiwRdLOgSQZcKukzQ5YKuEHSloKsEXS3oGkHXCrpO0PWCbhB0o6CbBN0s6BZBtwq6TdDtgu4QdKeguwTdLegeQfcKuk/Q/YIeEPSgoIcEPSzoEUGPCnpM0OOCnhD0pKCnBD0t6BlBzwp6TtDzgl4Q9KKglwS9LOgVQa8Kek3Q64LeELRM0JuC3hL0tqB3BL0r6D1B7wv6QNCHgpYL+kjQx4I+EfSpoM8EfS7oC0FfCvpK0NeCvhH0raDvBH0v6AdBPwr6SdDPglYI+kXQr4J+E/S7oD8E/SnoL0F/C5KDiixBbQRlC8oRlCsoT1C+oAJBhYKKBLUV1E5Qe0EdBHUUVCyok6DOgroIWk1QV0HdBHUXtLqgNQStKWgtQWsL6iGop6B1BPUS1FvQuoLWE7S+oA0EbSioj6CNBPUVtLGgTQRtKmgzQZsL2kKQI8gVVCIoKqhUUJmgckEVgmKCKgVtKWgrQVsL2kbQtoK2k/OigrYXtIOgHQXtJGhnQbsI6i9oV0G7Cdpd0B6C9hQ0QNBegvYWtI+gfQXtJ2h/QQMFHSDoQEEHCTpY0CGCDhV0mKDDBR0h6EhBRwk6WlCVoGpBNYJqBdUJqhc0SNAxgo4VJL9VL78DL7+xLr9fLr8NLr+7Lb9pLb8XLb/FLL9zLL8hLL/PK799K78rK7/ZKr+HKr81Kr/jKb+RKb8/Kb/tKL+b2CBIfu9PfktPfqdOfgNOfl9NfrtMfhdMfnNLfs9KfitKfodJfuNIfj9IfptHfvdGflNGfq9FfgtFfmdEfsNDfh9DfntCftdBfjNBfo9AvutfvkdfvqNevv9dvltdvrf8fEHyfdvyXdbyPdHyHczy/cby3cHyvbzynbfyfbLyXa3yPajyHaPy/Z3y3ZjyvZPynY7yfYnyXYTyPX/yHXry/XTy3W/yvWrynWXyfWDyXVvyPVbyHVHy/Uvy3UbyvUH3C5Lvu5HvkpHvaZHvQJHvF5Hv7pDvxZDvnJDvc5DvSpDvIZB7/OX+ebk3Xe77lnuq5X5luRdY7rOVe1jl/lC591Lua5R7BuV+PLnXTe4jk3u05P4nubdI7tt5T5DcbyL3csh9EnLMK9f3y7Xzcl26XKct10DLdbxyXatc5ynXPcp1gHJdnFwnJtdNyXVEcl2NXGci113IdQjyubx8Ti2f28rnmPK5nnzOJZ/7yOcg8rmAnCeX88ZyHlXOK8p5NjnvJOdh5LyEzNNl3irzOJnXyHF+m3+HDRG5TlmWvpGm4oUUCftPvVzXK9e5ynWfch2kXBco18nJdWNyHZVcVyTX2ch1J3IdhlyXIJ/Ty+fW8jmufK4pn/PJ517yOZB8LiKfE8h5czmPLOdV5TyjnHfrJai3oHUFybxd5rEyr5N5jlw7v1Fk5SL7UL909v52Xb79GsOfvGxn9bzVAurW8P6e0/mkhj5DpIabytEB1w0KqBsSUHdiQN24gLopAXUzA+rmB9SdEVB3XkDdpQF11wTU3RxQd1dA3b3e31cenT372e8Hnq/W3ef97Zn93PYTqu/cS6173Ps7d90C54qLNnxVrXvC+9smUtzh0IePf0Ste8P7u9Mfx+/8yrGnn6fWLQuoezOg7q2AurcD6t4JqHs3oO69gLr3vb+3nfzBr6uP2uQYte6DgLoPA+qWB9R9FFD3cUDd195fk/6+8f6a9Pe399cku78ByVSXFVDXJqAuO6AuJ6CurVf32oMfjDio+r0Fal17r87ULh0C6joG1BUH1HUKqOscULeWV2fS0dpenUlHmwa0y2YBdZsH1G0RUOcE1LkBdVsH6Gi7gHbpF1C3fUDdDgF1OwbU7RRQNyBAR3sF6OjIgHY5KqDu6IC6qoC66oC6moC6IQE6Gh7QLiMC6kYG1I0KqDsxoO6kgLqJATpqCNDRvIB2mR9QtyCgbmFA3aKAusUBdecH6OiigHa5OKDukoC6SwPqLguouzyg7oYAHd0YoKMHA9rloYC6hwPqHgmoezSg7rGAuhcDdPRKQLu8GlD3WkDd6wF1bwTULQuo+zBAR8sDdPRjQLv8FFD3c0DdioC6XwLqfg0aT3gZiklH+V6dqV0KAuoKA+qKAuraBtS1C6jr6tWZdNTNqzPpaEOvztQufQLqNgqo6xtQt3FA3SYBdeUBOqoMaJctA+q2CqjbOqBum4C6bQPq+gfoaNcAHR0c0C6HBNQdGlB3WEDd4QF1RwTUHROgo+MD2mVwQN0JAXVDAuqGBtQNC6gbHaCjMQE6mhnQLrMC6mYH1J0WUDcnoG5uQN3SAB2dE9Au5wbUnRdQd35A3QUBdRcG1F0VoKOrA3R0d0C73BNQd29A3X0BdfcH1D0QUPd0gI6eC2iX5wPqXgioezGg7qWAupcD6t4O0NE7ATr6OqBdvgmo+zag7ruAuu8D6n4IqPsrQEdy/lgWU7u0CajLDqjLCajLDajLC6jr6NWZdFTs1Zl01MurM7VL74C6dQPq1guoWz+gboOAOserM+koGtAupQF1ZQF15QF1FQF1sYC67QN0tEOAjvYLaJf9A+oGBtQdEFB3YEDdQQF11QE6qgtol/qAukEBdccE1B0bUHdcQN3IAB2NCtBRY0C7nBpQNzWgblpA3fSAuhkBdYsCdLQkoF3OCKg7M6BuaUDdWQF1ZwfUXRKgo0sDdHRrQLvcFlB3e0DdHQF1dwbU3RVQ93CAjh4JaJdHA+oeC6h7PKDuiYC6JwPqnvLqTlrYc+ZH5bs3e+70tFf3Ydd9z5rQdqO/1LqHcv/9e94VPW9Za3mbQ9W6RwLqngmoey6g7sWAupcD6t4KqHsnoO7DgLqPAuo+C6j7IqDuh4C6nwLqfgmo+y2grk1e4rqcgLrCgLq2AXXtvLq3T7j5raJvHrlYrevp1Zmeme4YgLlzQN2AgLq9A+qO8eoGjfmo3SEXPTJCrRvu1V2wetX5H//1Tlu17pQAGcZ6dbcfeuzIS9/f+ku1bqJXZ3puf36+d/1O20QXvn7lRLXuyvzEMlwdUHdzQN2tAXV3BNTdFVD3UEDdIwF1TwbUPR1Q93xA3YsBdcsC6t4KqHs3oO79gLrPAuq+CKj7NqDu+4C6PwLq/gqoyytIXFcQUNc2oK59QF3XgLruAXVrB9T1DKhbN6Bu/YC6TQPqNg+ocwPqogF1WwXUbRNQt0NA3U4Bdbt6dXc+Mvb3C964/3i1bm+v7q7YI7u/flnHbmrd4V7dM/ud9fKBnU8uVuuOCKg7MqDu6IC66oC6moC647w6U7we7NXt+Odb/a9fMHUjtW5EwHULAuoWBWCeEXDd1V7dTffNajyhm3OXWneDV2fqO2726kxjtwcD7ve4V7fsg5f3GzZ0zN5q3YsB130TYEvfBtT9FFC3IqCuqPDfv6Z+urtXZ+qnexYmlm8dr86Uk2xXmFj2ZQF17wbc77uA635OUNfF+zu4979/vdPi+7LkIzc5bO/n/d8JV9xCBReNH3Mq6wsjzQuY/2ihgkmAX+Lj59DgO17XHDmnoTl+RLtve+//ylLS+DV+nRogzvXqCrx6/7e/drNQw6PQu8oTut26GPhvo8gmy44NTXVZEazNybITDX6Jj78zDX7c53ehwS/18fs3UOjedXz8XUnwS2p8/N08/EgzbDcaK4+WxMpLSmrrnKra8or6ymiFE60ui1bWVLtOtKwkVltRFXWcumhdTalTW15ZVltXVVkWra+uqiz3sXc3YkfrqgVUWVV5rNqtryqvd6pLK2LRqvqKitqq2srSuooyp9atKXdrStz6WKyqrKyqpqzSdevrKsvqY3HsPUjapcku96TBj9vlABL8aJmPvxcJfkm1j7+3gg98z3rc7vehwY+3/740+HH72c/DjxC0zf4NFLptivkDafDjMfMAGvz4OOxAEny3wsc/qCGykm7dWLSkpCIq3w8Qq3Xc0tqakpiIntWlTo1TVVNSV1nqVtaXlpRGa2prqmOlsSq33qmvqqmsj/2L7mMfTMJ7NN72hxh4d8IUt4n3QxXecX1tNB7zD0Pz7jjxeHl4YuxWq9bHPsKAXVIVrRFDSKeqLFZVURcrE12pI35Ux+rqy0uqqkWnWlLrum5dqfinpK62tLK6ttytLq+rKCmrFreLt/mRDRT24sbHB0eB8curnMq68vK4Lx0Nxq+uLq+oEu3p41eB8aM15XX10Yp4nK8G41eVldbXl0WrfPwaMH6Z69SVlVTEbbMWjF9Z7ZSVx2Jx+6kD44sxYbS2sio+DqlHt091nVNT61b6+eQgD9+/hyz+vY8B39srlVna/SKR5vlyRLt/kcYresyapd1P5UdtHz839dvu2IaVeS021KkxRq/LNhzz72PCOhqIVQXEqgZi1QCxaoFYdUAs369pfa003o8eS4Ifjfn4x5HgO3U+/vEU+MrYbrCCH8HxH8c/QcHPIsAfQtP+cfyhNO0Tz1eHefgU2MNp2iY+BhtBgx/PC0bS4MfHqKNo8OOx4UQa/Eof/yQa/PgY9WQa/PgY7xQa/PgYdTQNfq2PP4YE3423z1gFHxc7S+KxbRwJfjSOP54GPx7fJpDgl8bxJ9Lgx+dsGmjw4/F5Eg1+PD5PpsGPj32mkOCXxXPkRhL88rj9nEqDH5+jmEqDH58vnkaDH7f/6TT4cfufQYMft/+ZNPjx8cksGvz4+GQ2DX58fHIaDX68f5xDgx8fP8ylwY+PH+bR4Mfj53wa/Hj8XECCXxEfPyykwY/Hz0U0+PH4uZgGPx4/T6fBj8fPJTT48fh5Bg1+PL6dSYMfj29LafDj8e0sGvx4/Dnbw4+0HjuqH5ALGuVara+8lwWa1rgBx3KOv34sp0mUZvP58neuchyYp9WmMp+v3r9I45ViPl+9n8+P3j7qfL6syzPwWmyo03WYZ7hPnuE+xYY6fewXBmshEGsGEGs+EAsp41wg1mwg1jwg1kwg1lggFrLtkT60yFKsRiAW0iaQbY+0r2lALKRvI21iKhALGaOXALFs7R/9MTXt2Mopb2+4t1/8unzl3uqYSi/Z2v9VvuVY9YfOTbj6eX6R7+Lu6P2urxtVc8zAqkGD6mr3HDpoZCTgMln8pdj6cduaMEurK0hBhkgkefPmd2nC1c/T+VHVmK/V5RquzTJgmZbU6CattnlOAh5UDF9X+nC4n/d/J1Rxo6nIod4/XamEKVSYUgm/ffJp2qckS8NX+ck3tI9uw7rusiJNS1ByFSz1/HxFRvV89bd/vXrMf0V5cWRlP/KXj2cZ6rINx/z2lby/osmm6ka3Uxo9lLqp2ql//6IIpd802anJLkxdWmFkZT0jlx2loldTbCs01PlY/jJA1U7V8wsUGdXz1d/+9eqxz7y/xZGVbVq300KDPOox1U4/9H4XJpCnn/d/J1SpqDD1U7ofqO2EXEadqh/49y+KUNpdkx+Y9GSKJ37bFRl4LTbU6VM/RYb7FBnuU2yo04ejYbDmA7GmArGmA7EWWYo1G4g1D4g1E4g1Fog1B4iFtHsb2yuoH2wplixIW10MxJoFxELaKlLGRiCWrb69FIg1DojlP0LUx5k+fiTSNFbS+/t+3v+dUOXf3E29ny+Heky9f5HGK5afprGSqV1NY1q/fdrStE+cn7YGftoa2sfXZTtDnY/lz7WoOYN6fltFRvV89bd/vXrMn6go1jBl0XOGdgZ51GNqzuB/jkgfl/p4sqRDD+r9fL7VY+r9iyKUfuME2oXJ/wsjK+sZ2D5OKnpV+fV12d5Q52N18P6v2ql6fjtFRvV89bd/vXpse81OVZvW7bS9QR71mGqnW2l2qupGt1MSPbj1Kdupf/+iCKXfNNmpyS7aGtqxMLKynoHt46SiV5VfX5cdDHU+lj/1r9qpen57RUb1fPW3f716bG/NTlWb1rdOdTDIox5T7XQ3D7cwgTz9vP87oUpZqUmXOPwKt71BTt3P1LbG2XU0ZT/z718UWdkuKPyso8ZPIjvw267YwGuxoU63kWLDfYoN9yk21Ol5TRis6UCssUCsqUCsOUCsRiDWbCDWXCAW0iamAbGmALEWgbBM8TkMXwtBfMmyGIiF9O2lQCxkLET64zwgFlKPZwGxkDaBbHuUb0fAMiJtYj4Qy9Y4geTrvzBmQtl9pk/7//rjDCAWUsYzLOULOZ5Ayqg/H1Bzyyzvb2FkZd8D5tl1Wdr9fDnUY+r9izResfw05dmmdu1oaFe/7ToZeC021Ol5difDfToZ7lNsqNP7jDBY04FYY4FYSBlnA7HmAbEWA7GQbb8UiJXRY8uwzgJiIW1iGhBrPhALGb8WAbGQbY+0VWTb2xq/kLaKtK+5QCykHpH2hfQhpH0tBGI1ArGQMto6lkPKiBxPNAKx/gtjuTOAWLaOc5BjzMx4YtXwoUYgFpIvlH3J3/q8ahi+TgfxJUsjEAs5BvD7Wn29m48vC+0cWknKa2z1OTSSNVhJ5tBMa+sKIyvbIbB93FT0rPLr67Kzoc7H8j93qK4JU8/vpMionq/+9q9Xj+3oNUqxhimLviass0Ee9ZjfvnJN2DbefwoTyNPP+78TrsT0+VD/Huq91XYC2l1Kn1hQ718UobS7Jj8w6ckUX/y262LgtTiysu3o9tDFcJ8uhvtksOzC2hmEFRTD/HpZCg3XoeOtej9fDvWYev+iCGlccIPa1RQv/fZZjaZ94muUVzPws5qhfXxddjXU+Vj+t67V/kg9fzVFRvV89bd/vXpskNYfdVXO1X2gq0Ee9ZjaH1W1aS6bqhvdTmn0kPqeD//+RRFKv2myU5NdmPy/MLKynoHt46SiV5VfX5fdDHU+Vnfv/6qdqud3VWRUz1d/+9erx07U7FS1ad1OuxnkUY+pdjrU+0/HSGL/TMWfVVxT3NbbUL1O9wcSfbt1Tqr+4N+/KELpn03+0DXFdvXbpxtJ+9TWp2I/Kr++Lrsb6nys1b3/q/6gnt9NkVE9X/3tX68em6r5g+o7uj90N8ijHlP9oUGL26pudDsl0YPj1Kdqp/79iyKUcbLJTk12Yer/CiMr6xnIT10qelX59XW5uqHOx1rD+79qp+r53RUZ1fPV3/716rFFmp2qNq3v1VvdII96TLXTOVq+q8vTz/u/E6rUuSZd4vCrnEJDW+PwSyoLDfrC4VfHfPw1afDLffy1SPBjcf2uTYJfFm+fHjT4tT5+Txr7ifO/Dgl+NOrj9yLBr4vz35sEvzSOvy4JfnXcf9cjwa+M2//6NO0T1+8GJPj1ZT7+hjTtE+e/Dw3/8fjfV8FHzkX4+JuQ4DtRvz02jjSVbINM/v39schGyvlZCf76WHqdf68iDYtq3GeSTeVfz/s2VvhR2yAR1sYtxCo01FHotG+A3Or92wfwqsshi/4OnNa2iSzTgFiTgVgLQVimsW0YvsYD+eoO4ss0/g2DtQYQKxuEJYv+ScAwfK0J4kv+XstSrLWBWD2AWD2BWOsAsXoBsXqDsGTRP9UUhq91gXwtAPK1Hogv+Xt9IBaq75C/NwBibQjE6gPCkkWfO7UFa2cPi3a+q7SSdr4rWkU731VaSzvfVRalne8qraCd7yqt8cfqfn/o30O1LbV/w+UVpSnvBfXvX6TxiuWnKb/rqfGjt4++fmcdA6/FhjrdR9cx3Gcdw32KDXX6Wt4wWEuAWI1ArDlArNlArGlArLFArLlArOlArEWWYjUCsWYCsVBtb+q3bbFVpD8uBmLZ6o+nA7GQPmRr288CYjUCsZB9LTJGI9u+EYhlq30hxyZIPTYCsf4LcWIpCEv+1nPYMHw1APlaA8QXEkuWCQ04vtYE8oVqe1mmALGQNqHPpYfBygZhyYKyCVkmA7EmArGQ9oXkC2WrNsfCdkC+kLaK1CMyrtraXkhb1edWbfFtZPw6C4iFHH/NAGIh5xSQY3JkroCce/TH9/489tpKXZb3l/YZgNPqZwBr0/AT+AxgbUO7mtbDAvmpTUXPKr++LnsZ6nys3t7/1bX96vnrKDKq56u//evVY5d4iivWMGXR1/b3MsijHvPbV67tPy+7uWyqbnQ7pdFD6t+A9e9fFCH1GzfILnoa2tFkF/61xYY6fUzfy3CfXob7mHSvr30LgzUfiDW1AYc1HYi1yFKs2UCseUCsmUCssUCsBUAspA8h9bgEiNXYgMNaDMRC+jbSvpA+hIyr/4W2nwvEQsZoPxaa9lEBxx+OaZ8TED++56B3QFuo99fX4vj1pr8+ll7n36tIwwLL5gbJFpS79Vb46aX8ToTVu4VYpr1xFDrtFUkst3p/2r2AZSW0ewHLymn3ApbW+za/ntKeWVrbbUCiy1jK71Lx71+k8UrlUxto/Ojto+dDGxp4LTbU6Wv3NjTcZ0PDfYoNdXq/HQZrCRCrEYg1B4g1G4g1DYg1Foi1AIi1EIiFbHtbbXUxEGs6EAtpX8iYMx+I9V9o+7lALKSMiyzFagRizQRiodpe/tbX5dpiq41ALOQYAImV6bcz/TaXviPTb2f67Uy/vWq2va22ejoQC9leyJiDbPtZQKxGIBay37Y1RjcCsWy1L+TYF6nHRiDWfyFOLAVhZUVWXp8TBqsXEAs1Ty5/9wZhyaKvPQ7DVzsgXw0gvmSZAsSaDMKSv9eN4LBW9baXv/W9E2Gw1gBirQnCkgXZXuuD+ELaqixIH7LV7m2VcVWPhUi+ZMn0Hfz7DlkmgbDkb+SaB1R7yd9rAfmaCOQL1dfKguwfke1lY98hy1lALGTONwOIhXymg5wHQM5PINfn+HMK/lovdW1YlvfX9L54eZ9+3v+dcKU2S7ufL4d6TL1/kcYrmB83qF03MLSr6X33QH5qsjR8lZ8+hvbxddnXUOdj+e/JVPe3qef3UWRUz1d/+9erx9rk/vu3WMOURd/fZnpXunrMb988QX/kNJdN1Y1upzR6KEl5f5t//6IIqd+4QXZh8n+TXfjXmvSl9/up6suENRuItQiINRWINR+ItQSINR2ItdBSvqYBscYCsZYCscYBsc4CYiHbax4QC+mPi4FYSLtHxkKkHmcAsZAxB2kTc4FYyLZvBGIh+VoAxELaBHJsguy3G4FYtsYvpH0h/dHWGI3EagRizQRi+W3v5ytqfpPl/S3UrsuKQHO90iztfr4c6jH1/kUar1h+mnI9U7v2MbRrS74v5vPq/1br1Puk+ztesswHYk0FYk0HYi2yFGs2EGseEGsmEGssEAv1bSRZGoFYSH9cDMRC2lcjEGsOEAtpX0gfQsZVpE0g46qtvo30R6QPLQFiNQKx/gv2NReIhRwD+H1tR69OHW+r7yNR69T7BI351ev989obrsvy/hZq/GVFkGPsypTf1+Hfv8jQJhRj/o1TbFe/7TYx8FpsqNPXrmxiuM8mhvsUG+r0vikM1hIgViMQaw4QazYQaxoQaywQawEQayEQC9n2ttrqYiDWdCAW0r6QMWc+EOu/0PZzgVhIGRdZitUIxJoJxEK1vfytv6/DFlttBGIhxwBILFv77UYgFnIMgIzRyPFEIxDLVvvK9Nurhm9nxuQZ+9LrMuPC/5992TgulAXZXrba6ulALGR7IWMOsu1nAbEagVjIvsPWGN0IxLLVvpBjX6QeG4FY/4U4sRSElRVZeY1TGL4mAPnqBeJL/m4HxEI+H0K211pAvqaA+JJlMghL/l43gsNC2YQs+t5mG9oe6dtof0T5kPzdG4QlC9If/wv2pb9vKAzWGkCsNUFYsiDba30QX8hYKAsyRttq97bKuKr3tUi+ZMmMTfj3HbJMAmEhxxOyoNpL/kaOyScC+UL1tbIg+0dke9nYd8hyFhALOacwA4iFfG6FnGdCzn9NA2L5c1b+WtV2Sl2W99df56vGOnmfft7/nXAl5fe4+PcviqzcVwH5ia/z7RZZuV3bGdrVb5/uNPxUZ2n4Kj/dDe3j63J1Q52P5cdh9X1D6vndFRn1uL2GwkeuduydvH//FmuYsujvG1rdII96zG9fCfl6XnPZVN3odkqjBzfl92L59y+KkPqNG2QX3QztaLIL/9piQ50+h5Oqvky619cmhMGaD8SaCsSaDsRaZCnWbCDWPCDWTCDWWCDWAiAW0oeQelwCxGoEYi0GYiF9G2lfSL6QekTyhYwTSJtA6nEuEAsZ7/246o+t9DFBP+//TqhSVuaPTdSxjD+mKoyYxyaYe7uxLO1+kYh5XOffv0jjFctP07jOpDe1ffRx3RoGXosNdboO1zDcZw3DfYoNdbpvhsE6DYiF5Gs+CEv+zo9gsNAyjgVizQViLQJizQRiIdtrMRDrTCDWAiDWdCAWsu1nA7GmAbGQMi4FYo0DYvnz0frYQpZ+3l/RHUZj5dGSWHlJSW2dU1VbXlFfGa1wotVl0cqaateJlpXEaiuqoo5TF62rKXVqyyvLauuqKsui9dVVlRW0Y4eyysKIuX/F4Luuj78mDX6Jj78WDX7Ux+9Fg1/q4/emwS/z8delwS+nfYeGG/PxN6HBj9v/pjT4VT7+ZjT4tT7+5jT4dT7+FjT49T6+Q4Jf4vj4Lg1+PL6V0ODH41uUBj8e30pp8OPxrYwGPx7fymnw4/GtggY/3r/HaPDj8bOSBj8eP7ekwY/Hz61o8OPxc2sa/Hj83IYGPx4/tyXBj8bj53Y0+PH42Y8GPx4/t6fBj8fPHWjw4/FnRxr8ePzZiQY/Hh92psGPx4ddaPCrffz+NPg1Pv6uNPjx+LYbDX48vu1Ogx+Pb3uQ4JfG48+eNPjx+DOABj8ef/aiwY+P3/amwY+P3/ahwY/Hz31p8OPxcz8a/Pj4bX8a/Hh8HkiDH4/PB9Dgx+PzgTT48fh8EA1+PD4fTIMfj8+H0ODH4/OhJPhl8fHnYTT48fh/OA1+PP4fQYMfj/9H0uDH4/9RNPjx+H80DX48/lfR4MfjfzUNfjz+10SaShN2tK5aPEooqyqPVbv1VeX1TnVpRSxaVV9RUVtVW1laV1Hm1Lo15W5NiVsfi1WVlVXVlFW6bn1dZVl9LM57rRE7TGma96+jaBe3Ph4X6hX8LBj/sTj+IBL+a+Nx8xhD25eU1pZXVzkV9RVVVbF60cmV1Io/5UKr9WUlVZXRmiqh5drquqrqaE1lSU1tSW20LiZiQV20sryurqlPOZakbZrm5I+Dt03sn3/lUukzvYUG/nvCj1fulavJNdj7v78WXJYhDU3nHK/Uq+c/V/TvX3m/c7z7tVfkiSj3kcWXOwcu9z/tWpml3S8SMa/j8e9fpPGK5adpHU+Oxo/ePvo6nlwDr8VanSz6c91cw31yDfcxYZ0FxBoLxFoAxJoOxJoHxJoGxJoNxELKOBOIZat9NQKxFgKxFgOxkPbVCMSaA8RC2hfSh+YDsZA2gYyr/nq/wsjKfSGuby4v9ftadezuF7+uLtJcLrWuXjl/94am8/SSrf1flalAUPcuTbj6eTo/6ripTsFPNGaQxW/HPKUeOcbx8Qtp8KN+2xdEmrepLlNhgrby601/fSy9zr9XUWTldqcYH5pkU/nX/aVA4Udtg0RYBS3EKjTUUeg0L0Bu9f7tA3g1yaHnN6Z4ZBp/++cXBvClnt/RcG//Wr8Ni5Q6YBuWBLWh6ov+/dspfNbWVZ84aM+hgyJaydbawW+31bXz9mxoagfdBgsSYEW0/6+uHctW8NRCmzP+f/sBX6aW9gNq29Zpda2Ne7LosUFvc1mkrn/X5hayDTLpNpRobiFbqW/mqwVN9/vbu19b5Z7tA+7ZQeNbPV+WPRuan99RkS3bcE57jUf//NyCJlb7ePoztZ3PT6F2/apky75MLbVlVY86b/F2jjTpUdVtIr10UvSycZcmnvX7dYgklsP/f43hfj7vnbRzZfF13Fk5DpzjSvmbeP79izRewf1QfAzTWeNHbx8/tsh+qK33e/DQqtodq4aNPHFwXRutKYuV3yp8sQbnn6Oeq5ZihaVIgvN0tcvSv2Hl6/TiN2WuxvOGSuhay/vdMbKy6+uv2lJ5yDYc08NzOwP/punXwQ3N69Th0H5aXV5AXUFAXaFBLr+uSLluiHZdWwOm5GFwQROe2raRiNm8/HBtaudEtpQIaw8NS72+s4bVJQnW/hqWen0XDWu1JFgDNSz1+tU0rK5JsIZrWOr1XTWsbkmwRmhY6vX6a2e6J8EaqWGp1+ufs1o9CdYoDUu9Xn996BpJsE7UsNTr9VearZkE6yQNS71ef33oWkmwTtaw1Ov1V5qtnQTrFA1LvX5tDatHEqzRGpZ6fQ8Nq2cSrOM0LPV6/9r2Biy9S1Y/bwvsAlN+fZV//yKNV6oueZ3Iyu2qto/+2KmXgddiQ50et3oZ7tPLcB8T1mpArK5ArG5ArO5ArNWBWGsAsdYEYq0FxFobiKXHrWT99QEN//4N6q/961TbVc/LVs4x9dEqRqLxQHYk9XFBf41n0z1NY8yhDc3r1Ck4fWyqThcVa3XqVFpnrU4dY+pxX51m66LVtVXqfHnUMWauJs9Q7zhtuu446lgwUVvpeYvpbySS2nSOaUquvXZfxH3U9tL7mGLgffRxvXqfTsD7qFj+tIh/ny6G+/h2o/tgP+//TrhSn4oc6v2LIua40g/Dj/v/eyVjacrTIel+JaMpn1BtRX/kYMoZTK9wVKdPBtWNEpP4O4weWDUoXzlVDZ06Ox2081bT/t81AVv9tPP0tzT5wxKdDxVLLTofQdMzpvubwqL/O9dwXBZTuqUPZVv6Ngv1+jUC7tMt5H26Ge5D+2aIpie7a9Pgx58CmlJcVSb//vpbrvx6018fS6/z71UUWVlHFGHAJFuQntWhbypTAWu1EIv2bR9NOl0zQG71/u0DeDXJoT5NUuNcZ29sKId1Zxc0xzbFCtrVJdHyVO3Rv3+6VqKm+iTcNFT3ry3W6mTRv6hgeiqdZ7iPCWs+EOt0INY8INY0INZYIBZSRqQekTJOBWIhZZwLxFoAxJoDxJoOxFoMxJoNxELaBNIfkT6EtAlke80EYi0CYiHbfgYQC9n2C4FYyPZCxsJGIBayvWyNhY1ALGTM+S+MmZA2gey3UW0vf+tvU7bF7pFtPwuIhbR7pIyNQCzkGADZXkuBWKns1jTl9f75phXupnmp/8oK9zLtPMQK9zLtWHbEvMJdYv+u7Z5eS7tWFtr52GhJlnY/XcaIdv8ijVew/uNzVqZlS6Z5T7/tehh4LTbU6V9ENi1p6mG4T7GhTu+3w2DNBWItAGLNAWJNB2ItBmLNBmIhbWIeEGssEAtpE8j2mgnEQrbXDCAWsr1OB2IhbXUaEOu/oMeFQCxkeyH7oUYgFrK9bO2HGoFYyHiPtC9kzEH6I9ImkGMmVNvL3/ocjC12j2z7WUAspN0jZWwEYtk6/loKxPLnYExbXPSl9aYcdu2A+6jXr50Clikf9s83bQMJmutRt6X419J+xadprsekD3Xbjn//1sz1+O3maufpcz1qbOuZACui/d/VjiWa69HXLZ3qTWTRfkXKvNRcX68YtDXRtGVSPabbr3p95wRYid4IsFrE3FazvLaSet+sS3PMZMtt9e2hKk/6esI1Etxf1b3+1ft5Cm9Ol8T3omhX033ahbxPO8N92huuy0rw17+Pfky/j4ln/z7qGkLfPuRc6VmFTdfo+so2XOtvkdR1drfy9spzPUzTNspE9pul3E9dR+1vH/bP92NzXqSpTdRzdHv3z79Isak+mr2vpsmsymni2cdU30qh8uxvEdd5uFyLT0RrgY3xyb+XaStSYcTcHpGIWSe63RUa2sF0nw1C3mcDw33aG64L60cmnoOeJbT2PiqW75O0ttHyt5ro7Vyv1OnrjtW3E+tvEDtGqVOfceklW/u/2hbSd6MpvA2F9lla+tpwTa1ObUPdx9ViakO/LVJtw46RldtQ9+3OBjlMfq/v12ip33cL4EG9T0etTt9qqNap/lmk8Zdt4C87gL8iw31o9wa03Aa7aXWqDXbX6lQbXF2rU21Qt+tjlTp966X6du48rU59m7b+lrrBSl2RVneCUtdSf/D1Iu83CPS2MHWcU6/VFRhwabc2RqOp9Evq/Ys0XrH8ND2DNvm/6a2Kftt1N/BarNXJMrGh6Ty9LttwrE0A1mwg1iIg1lQg1nwg1hIg1nQg1kJL+ZoGxBoLxFoKxBoHxDoLiIVsr3lALKQ/LgZiIe0eGQuRepwBxELqERm/kO21AIjVCMRCthfSh5DjiUYg1hwgViau/v/iKqrt5W/9GbQtdo9s+1lALKTdI2VsBGLNBGLZOl4dD8Tyx6v6/Jb8rT5P8ecA1FfRIZ8F/z/fO6LKpL93RG2rrAR/fSy9Tn/vSHca2QLfOxJkB+qcn/6KwTDvHfGx0vXekdUD5Fbv3z6AV5McqwHbJJWvU5jmllqqW9Orav1riX0svp7DNG9meq1smL07Jdp5/rPVNpGVdbd6AqyI9v8S7Vii9RymdxKpz6qri8w8q8+qTa//1b+GsFR5Vl3n/TY9FyiONK9Tbc1/jR3t111aPs+frdWp8/yJ3uUViZjnyH2ZWvoVAnV/l/4VAh8z0VcI8pR69fwRRU289OphxsxSMNV9bvoXKvxnk+oaAvUcnQf//JMUHvQ1BP45OQnkKkiAOVuxxdFFZsyIAdMkV5Eml85DocaDf/54Ra71lEVj6jn+/9X4OqyhOW9tDfeKJDimYqvX6nVB9012rfytfqFCr9NtRW8v9fpEbarbin/+1ABbyTPwoMqr61XnQT+nKAEPMw08qK88rBk6bLT3xYiIVvQP32Rr/9dVqasgz4CTqPj48prZRWYc//9B5qcuQykw3KMgAY/qtbJ5/OarrRtcN6ouQQO1MQhgulmbiLmYPhHhx1LiL4alvDdV/3JbHg0/gV9uM+3hNr2m2L/W9ExeX9+U6n3aRZrW0Y0cNXREIlvQda//PzfB/bMM10e0a7MMxyKR5vucTeMTXeaWfkWy0MC/6T5FIe9TlOJ9uoS8T5cU79Mt5H26Ge6jY5nGq7Ic09BUr55/hRLHN+xhxmyTAHP/hubnm3II09oW/3zTHMhqBhlN7zboHkl+b7Ut9X5v9RbymmwOQl87ZMplU+V1jzTzmttCXosM91b7ftG5HXtS3Yi9ho6qU0OMzkZE+633+/qbzvXurCABq+208/Rl0Pr0UK72/67a/9sa+DMVnw+16LxkR5IX30X9trpDcdG+CVw0EjG7qG/2evqrXmtKf03L9NWpxURLpxOFH//LMPqy5fsDwo9p+0zQm7lNW1JMW31MX83podWp7aQuq/8Hu2FlzHiKptQBhzE1sn027dHEh94+uQ2pt4UsetuZvuyjbq/RX/Wrbj1aS6tTl8vpW6KS2ZVur+qyN/9adWuBr68TlfP0rvEk5f/Z2vnqPf3zT1buY0qJ/GtztfNfNqRExQaefH4KteuxNlMR89vwlMjKxa8bHWkuu1o3Rjl/t4am8/Rimt7xZZJtkd+C6R1VjzpvPqYaY1TdJtLLe4pe9I9Mqvc7KZJYDv//2Yb76W3p18vi63iMhtHP+78TqpRVZWn3i0TM6ZZ//6LIym1LkW6N0fjR28c0bAj4yOQpym8V/hANzj9HPVcthygsRRKcZ1L76obr9OI3Za7G8+/KLNzn2oyw6vr6t3FVHrINx/TsIMfAv+k+eSHvk2e4j77aWhb9Y5aDDbLqq61l0T88OUSp0z9mOTSyslx+3bAAzOEBmCMC6kYG1I0y1EmeBrdr4lEPxybX0HdAqrpL5AeJsPQPZKrXj9GwxibB2l/DUq8fq2GNS4I1UMNSrx+nYY1PgqV/IFO9fryGNSEJlv6BTPX6CRrWxCRYIzUs9fqJGlZDEqxRGpZ6fYOGNSkJlv6BTPX6SRrW5CRY+gcy1esna1hTkmDpH8hUr5+iYTUmwdI/kKle36hhnZoEa7SGpV5/qoY1NQmW/oFM9fqpGta0JFj6R+vU66dpWNOTYPXXsNTrp2tYMwKw5G89zVKvn6FhzUyCtaaGpV7vX9vegJXl/fWHX7OU47jhjpvyLhj//kUar1h+moZfsyIrt6vaPvps92wDr8WGOrUvUuvU+8w23MeEdQoQawwQaywQaxwQazwQawIQayIQqwGINQmINRmINQWI1QjEOhWINRWINQ2INR2IpfdlQeN6+VvfxWwa1/vXqfFMnx7K1q5Rz1cxEuUN2QrPY5Lw3EvjubX5g/zdW8Nqbf4gf6+rYYXJHw5saI7V2vxB/t5Y46u1+YP8vYmG1dr8Qf7eVMMKkz+MaWiOpV6vx9xk+cORGpZ6fUvyB/l7s0hzrNbmD/L35hpWa/MH+XsLDau1+YP87WhYrc0f5G9Xw2pt/iB/l2hYYfKHqIYVlD/MSoJVqmGp18/SsGYnwSrTsNTrZ2tYpyXBKtew1OtP07DmJMGq0LDU6+doWHOTYMU0LPX6uRrWvCRYlRqWev08DWt+EqwtNSz1+vka1oIALFn2amiOpV6/QMNamARrVw1LvX6hhrUoEizjVpHmWOr1izSsxUmwttaw1OsXa1inJ8HaRsNSrz9dw1qSBGtbDUu9fomGdUYSrO00LPX6MzSsM5Ng9dOw1OvP1LCWJsHaXsNSr1+qYZ0VgCXLwQ3NsdTrz9Kwzk6CNUDDUq8/W8M6JxIs4w6R5ljq9edoWOcmwdpRw1KvP1fDOi8AS5ZjG5pjqdefp2Gdn4SvnTS+1OvP17AuSIK1s4alXn+BhnVhEqxdNCz1+gs1rIuSYPXXsNTrL9KwLk6CtauGpV5/sYZ1SRKs3TQs9fpLNKxLk2DtrmGp11+qYV0WgCWLv4quo+H6yzSsy5PwtYfGl3r95RrWFUmw9tSw1Ouv0LCuTII1QMNSr79Sw7oqCdZeGpZ6/VUa1tVJsPbWsNTrr9awrkmCtY+GpV5/jYZ1bRKsfTUs9fprNazrkmDtp2Gp11+nYV2fBGt/DUu9/noN64YkWAM1LPX6GzSsG5NgHaBhqdffqGHdlATrQA1Lvf4mDevmJFgHaVjq9TdrWLckwTpYw1Kvv0XDujUJ1iEalnr9rRrWbUmwDtWw1Otv07BuT4J1mIalXn+7hnVHEqzDNSz1+js0rDuTYB2hYanX36lh3ZUE60gNS73ev7a9ASvL++s/f7pbOY573lPqZmn38+VQj6n3L9J4xfLT9Pzp7sjK7aq2j/786R4Dr8WGOn3O8R7Dfe4x3MeENRaINQ6INR6INQGINRGI1QDEmgTEmgzEmgLEagRinQrEmgrEmgbEmg7EmgHEmgXEmg3EOg2INQeINReINQ+INR+ItQCItRCItQiItRiIdToQawkQ6wwg1plArKVArLOAWGcDsc4BYp0LxDoPiHU+EOsCINaFQKyLgFgXA7EuAWJdCsS6DIh1ORDrCiDWlUCsq4BYVwOxrgFiXQvEug6IdT0Q6wYg1o1ArJuAWDcDsW4BYt0KxLoNiHU7EOsOIJY+55hsndxR3u+gdXL+deq8k77FMFu7Rj1fxUi0Di9b4TnZeryjNZ5bux5P/q7SsMKsx6vWsNTrW7oeb3UNy7Qez7QPbmhD87rBynX6Hgb1qyP63rohSt0pWt1QpU6flx6m1I3R6oYrdWO1uhFK3TitbqRSN16rG6XU+W2k7oPz90f6bTTUO16oyebbYD/v/07IYvpymd6Oqt6yEvyNRFaeY5dFjwHql2eytPucAryPiuVv0/ZtVLVf/XUZo7X76Mf0+6jXj06AlehLkSco9er5Yz3dm74UaVqbPFg5tmeArP61vk3pca2f938nXHF9/PE0+NGg+KvKpPug2nYtsS/1XkWRiLFf6QdquyDZVP51O1T7g1TWjY9rIVahoY5Cp2MD5DbFXBOvJjkS+aZ6n6C31o4P4Es9P6h/9ttQ7SOBbVgS1IamPr41b631220t7Tz9K8SmsY6OFdH+r3/pMTtifmutKbYVJuDTv2+yOK5e758X9AqLVOKG6T4mnv37qO8XUN/Ce6a2V963O/WVH+q+ljWUevX8Nzs3YZ7tYZr23STylSzlfuq7CfRXxfj3S/SqmBMS8HeB0u/pb/A8wSDzGgE8+5jq+x9UnvUvxvrnX6qNu4j6SOO4y79XR41fXT+6LCad6HZ3sqEdErWtLOo4RR3HqOdf3cJximrf+jhF5cm/1pTr6e1guk9QP3lyivcpCnmfIsN9wo5DTPcx8aznVLKo8eQOLZ74dqf6lnpt/4amevX8J5R4cndAPNHXp+hjJz3G6vHEv1+ieKLbp3/+AwHxxDQ279+QmGcfU40nKs96PPHPf1SLJ0TjJ2M88e9l6i/bRsztEYmk1l+2NbQDdX/ZVrvPWOB9VCzfV0xjOT3+tHRsrV6vj2UT+evL7cz3NPmraru52vnzFX99TfNX1d79NjfZjd5HjTXcV/eZSGTl/EyWoFg2NgFWqn2Uf/67AX1UUK4hS1AuHTTnqJ6nnhM0/5cdcA/VbtXj/thY7TtP0M4dp507NuDcRHmj/O1/DYE2t6+o831BncP0i1830cCzX9egnH9QQ9N5esnW/q/KJG1lhx5NuPp5Oj9qO01MgGmKF/pb9X2Z2xhwx2u4agzQ28t/z5bu/397viD9/8d2ZjzdTmQ5zMOjzV8r6nX9qkXXr94+ejHp1+db6nd4C/Sr6rBBq1Njtv5uNzXW+xiy7Qu9m9rqS63xl+Eh/cXUnvozAlPfqbZnroaxafumc9q2b86Tf47eX8ji+4/vs3775Riul0Uf+/nnd/TuKdvnnh7m+wf5WyRijgtqO+jvZJwYMfNiktk/t69mjw3KNTh7LHV9PU7SeFbvPZno3lna/SIR8zyvf//2Bn58vosMdTkheC1zKypKyktry+qry2NlZXVZGr7Pq35Mn6OcYji/o+F8v60bSdo6Wmt6JfQUpV1lyVHqJmt1uUqdz6P0oft7NOd/ChH/qbS/ev9iw/n6q8BT1WWx4T56zhEGa2wrsTpHmvuAqS9UxzZ6X6iOX9T3gO6aIC6nEuv82KbHfVVOPQ7urMU6tf8D2lCpaTyqx7pJRPdONdb5928fSazbIkNdmFhXW1bqltZXllXX1kfraivqsyIr9wnZhmN6rDPZbQfD+cSxwjHFOj2e5Sh1k7Q6Ndb5PJpiHU2/GHVSaX/1/sWG8/VYl6ouiw330WNdGKyxrcTyY12Dcr0+TlVjnT5OHW+QR411el62hxaTaF59b54j1GOqyq8sag49XmknvX11HPWYOm5Wr9HnbPzz91fG7fu0N/Pny7CfgT/TmiJVrgPaJz5vvOE8mSr746hBdaP2P6ZqRF3t/nU1I+pGZUfM7Oki6uLr6VREO08W/YtwI7T/n6D9f7CG43fBqX4Rzv+rYplUp2LrXe8hSsrzlBbCTtDu1c/764QsptRR72ppHuOVpJxW+PcviqxschTLR0xTm2r76N0jzWOJEkd+tFWf+pbl+IaV20bnw7cXfRmgX2/668urH9O7CdUWdbsJCoGJQtZJSsga1L7pfD0GpLJkK5VH8eox9fx6rU59dJYVgK9Pg5yg+PF62tSOOtTx5aD90k+Ja/rSj2pP6jAqkf2bPt/gnx+0lEwW/1FD0NIik22ptuTbiEnP/jWmx+HtNV5b+ui/veE+1D7VXpNHtWN9iNfSR48m+032CG1yAp9M9AjNUerV8ycrj9BO1fSpXq+28z9yNTTVpclnSlrqMyY9BPlMsiX7fhuaHrEe2tC8zuQzpnbVbWewgQdTP2eyncEJ7iPLoIbW30e/3j8vlXGK2g44W3BTHqf490/XOOWEFNvVb5/RNO3jpBKLTPHT9DhV71PUGGNKf0yP+9T+SE8XL/SCStDShSAfNT2C/2dJoJYWUY+3gvyhtfdRsUY1/PvX/8qcn7NcrYzVrmyf+Hr/kzB5yjWmZQ+6PKoNqX3QdVofpD6OCXr8r+dYuyl90I2tHFNQLidM1o/on9pRr0803m1r4Ev+Ptb77evYn4q5R9HxXQnSfVlU/dyv6UeNhSb9+Pc2TSP416q4Oo8PKzw+GOB7Ko+PJjhP/j4usvJ5eiyKRMzjHV2H6jSI6Xx9+YF//pMp5g2+PdCOgVxj3qDqXx8Dpdof6e2knq9i+DGoWDtfb0NZfLt4X7GLlzT/NsXR1vpwovFqothPPD1ZmeoYxb9/UYRyzNQ0RjF9CjDIJsYZ+PfHg6bzk9mQf76cS9HjfLGC5d9X3ZI2Xjum91FBYxpZ1NizvL0ZQ5XPNC7yX4OvYqQS+1tqzyaZbPCbVOzadJ+gMdPJwPuo/qxv9yLawlfqt/0EhU/TGFlfPjdRkSFbwzCdr89r6vj66/v863Mi5uW8vj/o/V4f79mjtPEVWt8bJKMsAxvMMvo86+foS0e9qmZ99TgDfq52/h9KX60vjzflLuoyMn1LQHyJoYKpf7m8Qbk+lTg6yXB+g3JOfJlVZOV2maRdN0mp03VuwlbPz06A06Dh6HK2UY4VG7BNj6Yl9fP+74QsPp7/6DZHuccUAz+52vntOzTn69RI8zYNajNJjYb7qq9ZLNbu26jdV9rQs5oN+byp+YCq9waNB32cqtvVLg3N6/3zuyj+3Mn7rT/elUXtH9foYL63mj9MDuB1koHXBuVeYzVe/fO7K+31Qg8zryo/Kq+msXl65ifNY/Nm8x4NzdunQakzxbnWxg/T0oHxWp3aF+vx1zQ3GNTHqHowna8v0/TP30DRs59bBc1rSny/XzLNW+hzACcrMgT1U6Z8V33OsUkHM26i7WX+51/1Z2pbKvMcm3cw31sW1QedFt57jwT3/r5TE2ZUa0PT3Ady/GfSlbp0Q9dL0LxeseF6fcsExTYq9Z6m/lkf67d0G5V6faJXAvj1shCPZ1POXf37FxnahCJ3NeWWQc90kn0KXD/f9Hogk97U3FWNrRHtvmruOlE7FhSLk8WF3VsYF9S5Y/X8R5W4MECLCypf+jY5NWZ0iZh5iUSCdVRsuF5/HRJVXthFk2d0gDwtfZ6rXp+uraRdtPskspvDNbtp7VbpyxS7OSrAbvRnn6Zn3SYdpDIHH6SDE1K8z5iQ90l1m+mqbFNDQTa1WLGpEQHjvFW9nccB72Oa6zG9Jk9fWmzqZ8cH3CfoNVWJ7GZSB/M9U7Ub//zxit00pmA3Jh0ketWSet90rf1JVzwMwjKNvf3zTWPboDFYqs8DfHtRx2y+bdNub0l9PYl//yKNVyw/TePdhsjKbTfB0HbtIk1zH1V1I92S2E51NSNGDxulK8MHLI40b+SJGqB/fkT7v36dZCpHO2e04R6y+I6kG1Kxdr0+oNbxU+Ep2bnJ6k1OOCGBnJFIak6oXt/Sdyvq+2D9889WJlFSeR+EajwteR/E2AS8ZxtkKEpwnd72pndg7Bkgs3/+RQEyj0si8x6azIne66b+Xz8v2yBDQcS8qCLonTWrRZrz3lJ7Uq9P12BlNe0+iTr36xJMHidaoDpIqVfPP07p3G/UOnfT4Jta/kTvflLlGqSck+gdJDkGTFn0jSj++Xd5shNP/Bj3VAXtQ1IX5N/TIXnbBOncP/9wRef3p6DzIP8xvdMsKFawHsi4dU4qNq7en/1A5t2s5o2c6kBGvy5oIKOfm8ipww5kTDwlOrelAxk1A9AHMi1dMaJe759Hu5qqZKUVzepTHdWZEr1QUV1hEZTB6auvdHy9A1A3hZraTl9h4Z//sjKIedl7+mXSVdcE/EUiqelKvT5dq3u6avehmMWVRZ/RSPdgPZENOt7vZIOkD1vYYeq72/zz2ykd5sdah5nqKrJUZmp1m49EUpvhD/K3VP1Hb6McA6YsiV6E28bb8Uy7g7bM+f89tStLufPXB3SmVRVFhrpQLwWqqHed8vKKaH1JVayurFzvI31e9WOpPNHrYTifdsao1PhSoAlKu8qSo9SN1+pylTr1yaD+ogyagVlpbSrtr96/2HC+/mLbls4aI7D8l1uYkvX/VyxL9QMZ/vkFXmxK9cXTppcLB72oWE+GdBn1mChLP+9vMkuqT1L8+/n6yTfwou8Mik+aKO3yWo/msiRa+ZOTQF5VtogBI1Hb6fcwvSzkmEhz3salwJtp4knFODkBnxIjXStQTPdZO+R91jbch/LJl3rPZOOx3h2brlHjTaInUqMbmurV838rbsJc38M07f7VV96ZJlbVsZAeI/WVd/o5erzxz++r+FWyDxOocgbZWaofJvDP31wbj/0/JrR0mXMiTat71fi4d0NzGfzzeyh6dju2DHOfBJhHdmzCLG0h5r4JMPdWMCsC7LF7pPn9WrobXb1eXXWr8gLWb/zjTENp8OMf8hliaAtVJv/+phjTklim3itdu9ZNsgXpWf1Inf5k2oQ1pIVYhYY6Cp0G7Y5U798+gFeTHPq4wnSf7oY28c8fFsCXer7vw6rt+9f6bah+/A/YhiVB+h6m3NO/v5zYbenHmfx2666dp3+cSW37oQmwItr/u2vHsiPmjzPJmLnUi/OmeZNuCXj2edCP6favXq/bP03MrKg2rZT2iz4W03nUS7b2f5Vvqe8fOjfh6uepGLodJ/rQqSnmJsIwzeUm83tZ1IcR/gPPkaOGjqjbZ8SxJ1WNqtv5pLohowz2W6DJp9ud/sa7odq56vysep7+MHOI9v+R2v9HGfjRi94mamlvOC9RMfmH6o99lN+t6R/U6/3zTPdZJ+R91jHcJwirjwHLP3+44fx1DOf7cpjipR8D1I+wUsRvkw+pfYZ//9bEb7/d1tPO83OuNpHE/Vey+L2edixR/DbZyuAEfPr3TWYrpjGCjqXmT+oLZfU5fP/8KVo+RDOerYz68V0dY/htRjtmqIxmaffz21s9pt6/vYEfn+8iQ12Y+emSWNR1Y+IRep1T6lTVOkG+rB7TfX+k4fy+hvP9th5F09bGFzmPVNpVlhylbrhWl6vUqf2JPj9NE58qU2p/9f7FhvP1+ZJUdWnC2qOVWP78tBrjfd9OV2yijSktH0/qb39Q52P0hVzq8x51Ll0vpnGoL6+022Ut+KCLqg99LnSoQY6gvlQ9FqQr/zxfV6q9cNSV6nt6MenKl7elulL1oetqmEGOLK3O50c/FqSrYQH3aRfyPu0M9wnqs1PpU033MfFsWheizo9fqs1H+vFOnR9Xrz25oalePb9ImTe9ImA+UuVRxc6KmJ+F6THav16dHw8ai/nnXxswPz5Mk1mVU+dRlTnHIJcs+vy4f/5N2niQKA8wzo/796IdD7Y8FmVpderz4N0bms7Tiyne+DJJHXfv0oSrn6fzo9qkvmDcNE5VsfQ8vcbAjy/nqEhz/lXfkEV/7qteP0rDSvbGL31RvHp9KjucVKz9NaygZ+/J3uo+UMMybVDwscYlwRquYQV9vHJ8EqwRGpbpw4Y+1oQkWCM1LNPaCx9rYhKsURqWer3+1o6GJFj6Wy3V6xs0rElJsE7SsNTrJ2lYk5NgnaxhqddPTnCd3i8FrX+k/UCN2+IPt6XrrYCmdg9a3D7FwGuxoU6f45xiuM8Uw31MWEOAWGOAWMOBWKOAWCcDsUYDscYCscYBscYDsSYAsSYCsRqAWJOAWIOBWCM0LNM6BlNsaxdpyoX+ed6zY9WwkScOrotoJVv57d9D/f/IBPcvNlwfCcBSrwmSRR1r6nNevpx5EfPzWf3tXP75fys50Hra2rsTDNfLErT2gfiZfkmq/aqtaytM8xn+tcWGOj3PbMkzzbA2Louab+n86NdHkmD5/1efJfrnmeZZVVn1nN/3PXVOQsXQ1+z553fw7mt602eyXEx/BmDKt9R+3eenY2TleKHvwzDllKa5ffW5oSw5Sh3QrmtMbzlU2ye3IfW2kEVvu6AvHam6N715RH8WoMY5fVyVzK78OKrnCuq16pyYSZc9tXuang2px/Q+radBNtN91gl5n3UM9wnC6mnACtJf0LPvoLc1E71NriTIr03zAq159u2321raefqzb9Nci44V0f6/lnYsOxL87FvV6dAEfPr3TWYr6vVBNjk45H0GG+6TKMbLoo579Hld//ydvRhP++w1Fg3a90i7/yyW8jP2RG/NVPkuMtSFecZeHytxaqL1dU5ZtLq6xqkNihktfQPReobzadeWx4zP2NU9DbLkKHVjtTq1r/xfe+8CJNdxXQm+6urqRnej0Q2ABEAQBAqkqD+l+nV1t+ywYQskLVIfiqRI05Ild3dVU5BAQCRBUaQoqShRH0uyPtbPksffkcae1XxiPfZ6FBMb643Znd2ZXc94drzeUIR2tYwd74zXnnCEZ2N2I+YTgwe8W3Xq1HlZ73VnVheIyoiOev3yvntv3rx582bmzUy82YDX2MPYwbVKFvkj/WUBz+ONvCe5+sBla+zYl1jbHpVtCmtTxneNHWND8qzbYn3wuu0lUQ5Xn638SVVXlxx0bt8lndsFHeUfF1J+jQ6/YzqK52Hrtu+iMZU6LRa//VCnl4/w/xrWbd/jiIlmX5vbBOpgnLjd4+nbWfp3g2/BGI7XbdXezA910nk2Gln3mRv8OfIxwvTzet3Wte+V5wvy7ntVZwWELePqFts1TMqu8R4cnIPlWAqcU+V4ww7k8fzM85BXoDxcM3qS8j4Bec9S3guQ9xjlfRLyUEc5KduMh5M9mmONG/WGzwpQZ2yo2KiXwzPmGa/8jvUNv7+Y8h3bkcB7XqqB23R3X5La841lYt99p3FBSGuecPmWnatsrngoXKfjdTaF69mcuOZEXog6fdxRbmUTFK+qHDyeV+3s5UImBv9hB18Irw5gG/V8jZKhr/kak9trCI73mqEOPpuCK6L/X0Pv0uZrhu1P//qy5jnreUEG/8/Aj/smPPM+HsT1/qg/7/2Q96HkOewaz+qqmldh2X0IaKfdZMv8c1J9qZUp1qvZHH0p+k3IG+LE+vsgwOBefIT/LfBzy7donIXIPa/NOpT1DAGD/67D1zaY6ZRyXUjB+d+CLv6dFF2PBE5VLo79ZB4uEg8G/ztQrtvgYCG2i6hDcfpAp5+3xwWtKOUd9wWPp+S56A77Nn5+Cp5VX8/6+kGCt3X1NJmyrhj8P3Doiorpda1nMw8M84EUHv4bwUPcTywk+VsXP/BMylLoNDyzeVZVyVXwmMCTlkwMcfGsOTAe+9+lfmoZOUp5x9Vg3+JZnK32+faltLXiKUJ2PoXYVKRTlni8cYsbCB2P5zpvAmXJYwD8Vq2Dsr+Ylc5O4wZYF96fQr8gvo/o24J4F6crfszs1Wc1FuW5j7xjUdU4GFfaGUHv7fTyEf5/dcQbXAQ+FE6LsTZ45Re7DjIeNr7k/WlqnOKijbLMMqfv4lWt9aDPz7EUyN9zOXm9d8S8XszJa1q7tD7sspE+98H2E2+9eKmNTYXZiOh5jt4xDG9b+EAKq/sJjqe9+Ug17je5T3pC8KeSMg3MSzEanviegT+FJvqqlCYaRbqJcviI2uqnhnRqWtblvqvLlhAHhzsZ/F84zM+wrRSs9mq7hDoCT229+Ajl4Xe4jHIFd6eXZ3CBw51aKtwJy1vq9MtCbfdwHWeqtnSo47WXCR7lqJaGeNpWTd+rpaFhW1/enFLeUkp5+TJUg/9PDv1TMlFHNRt8R8CjnFjHUL4dysPveCkf9c/gAutfW+lfQupKYv17XsgC4Vl2HxfwzwMMhi4jPMrR8tTF1cr+WX3gkYtqebuQ8mu88jtXaMH9nX46oS5Zs2VBbk/KlYufK1E//PNAl9uTgu8k/+NUi6q/EsEfPXj1Fy8l56nnOPVdCH5Q08a2/6zglWmvwHHlJ5Jnl/vGR3mfAt7/71vSv+flUOx3HqO8tCNbUf5YTqxztnEGfzvw+WcUGoG2BKfR4zQNeR5tyXbevqwDeVn6sucFfAdgOIwI9TTtXh3EhTJP84NmIu2D4NH6CF+BOuJLyLHP5AvUn87Je1bf8Fkox/9FR/l3AI63F3UETXzHNkv1gVnqXZX3eeBZwRu+EsH/qJA94yxFWpc+loLzxwEnH6U9DOejKTh/EnCyr6L6T3WvjcF/QsBjn9pJntX21k9QXgfyuN/8ONDnOn2k008f8Twf9SfmOY1fFY7v4pdtu+U9ghdSJ89zhM+zXay76vKVojxZ6/JZR/kZl303HQ3qq2pDHxfyevCgxlnKifNh0b8qX+dip0f7kRTfIE7sG8SJbeCzgi/0OVQ/nXYdyntEe92zMWS1XVH9LsqC+101BnPdY+Yac2L/sizgH+v052W56w7p7KRf+69T7gZUeOPnm4gPlz8WP7chH+EvOOy4kqFL5sPG7RzSivXxMcpTOj1u+oryYX11ySJOecfrrK8dyGM/zHXl07B5LJe+4tH6f5f8MBVKreYWeEp3mM5wqHMHeFDw7AMZ/Ccy+FXIg2urRdb5AdXHfTzStLHdokzu7vSXx+B/PqM9t3oJO46qVlX7QLly+3DJME55fUSTmWt7v2ofz1Me6ie3nazzgMPmd/iS92FH/qRdcYE6gz4m23qD/6bD1vvuX3meQcnVZTvGTZfHxdbzfIGy9Ur/cC7gYgZf4zEH/8PWNtj+ZV3beBr4v4K7Ew2Uey/qfpRrG1z3rrUNFZKe1abcTeUYZlN43tLgfz+nTXHplU+bou5m37t5xvHWK5dNyatXrj4QbdC7MlzJ6dIj19pX1rGfS4+Kgi+0k2obbZzOJL+VXSbXmkzYaxArKwWiZ/LAd0h/XsgxRPiXqld1rVrYay4rjdjkcVuJ0/s7g7JhPrg9PQO8m4wfBDwcrq2u+o3b05/QXJOaD8BvjQbPB/wA5s6+TziHHZnpavu4vn7PAc0r4nVdKflRwKXgsewI/386xoDKfirdMviOgFdXbuddX/9wCh0VS6D6ZYP/VxnHh6NZs69V93rNnudIXGv2WAcdoqN0FdsFtwHlo6n2ildpqraFNgF5ND7i9D6A4XkT5d8h35c6vXyE//9y+ncH4V3efpnbTN6xuKoHl81QdTMQk+OwGcPifFim3TIc6uHMEufjkmlHwOeN88kqUw4FNTpZZdq90hnKn2aHs8rU4BccMu1Eg+VyyfR5Ad8R5VL2+3nCNUymHLZsdLLK1OAPOWSqjjZwydTgb9xDmWKZn6fv0Gawz8n2bj7lu2UHzo+m4HT5n4wjrS6VTeO6POWoS1Wuj2Ys18c8letjOctl8LcHKtfTKeV6Ome5PjqkXE9TuQz+NaJcqg9LG9eqOZc48dy/wb9etMvrec6M58WUH+6KX3Lpy07GNxWa23AdOaJi1dU8Hcdo/VhGHcBjSeI0DXmhdQB1mXXAtS0kTjudc14W8DZOVjqQdt090tmJDrzmQD9cqNhaPJoKy43jCJyj4HHEx4CuaosMb+0OY2uxvXH8icG/HfSVY2vTtvY/cEjTTmsrPKdh8NuHejgfSp7Vdn6OT8hru1HOabb7nRPb3We7TWbKdnObdtludQS4Ok5LHXtg316Ja1gczr+aSzb4DuBy+WDs873P4Rt14BvV5qopOC+C3j92qL/8Kt4phnv6kB/aTzjGDs8DbTUmyju3w7FDHcizb7ncXFdPk11Q6yMsE/RVEZ59VczLM7boiDKyDGdS4NkHN/iPCj3LEvsw7MoeV7+IfjXbdN/bSXltR63fuPY+7N0aYa2mbDGWl22xyyeKk6+YSGWn0RZz+xh2HZZLV+zbWFc+nlSGmrtKWxNAmioGQ62dc1ux8nwd2grHzav5VJff3o3BcdhFVQZXW8i65qv8mY85vlPrnEjrTPJbqWzvKhm9ToJvVvCS1l/+Bsjxf7tF81oY4Hd3SfWdBZJTB957tA2VAtGLosGxAvdNqr8544Wf3ppsh/hJa3cmn+eD8FPdxjVZ1F9ck+0AbeU/KP8XxyPfpb5L2QC0p6+HfIT/L8Ev+zspOKMov+3E+Nw/3t+P13eMmiuOq0N5anzo2q/DPk7a3qQ25CP898A2/Nler31Wt/c8NraTPKvYWO67lf514B2vq6m54I7Az3PB/53DD3XF5344J+8fEbxzO+e2890MPupu4nNvgnyE/0OHbzBsHWlU8bl4JOcV3J1e3iQ+dzCWDvcLZY3P/R7ZbrXHyLXWreaUkY/jkI/wP3Ton+/zT3gfYNYY4T3fC1Sp1vZ6zozXNFwxwiouSsWm4F60byb6F1KOq2uVrk9rdYjH0GOahnyE/6tEX+ehHPa7qytZVjeq2/WN7Y2VjVarsbXBx8rHyeosPmYq1od/c6gnM5OTb5nFyfCXwuDv7vudhrIWRZmMvunSFMAXUn6jSI9ZjNY84fJctqqrbMg/zxVMEz/2nIZrOieuuZS8M37K3a3ToqPcTD8NXrUBez/jwI/wZtdRh2dIFrNhZFFz1dsM0DT6Ozk22/4/QXB8zRnKu5SCK6L/T9C7YqSPzWa7tBgNltu+CWxTMh8navTno6DtoWsHSsRPWtvF4wTPX9xoJad8ssnjqkNxIjouNlddt1ukd6wOU/SduYGqC2U+CwKHEoHhXIr6ecBvlSkpptCNop66svkYhsueiw5e0nAUCMeiA8ek6UyajkiTppOt6fj2xmtra8312malsdra2m416sO8cd/0tzabm4325laz2mjWG5XWqOm3Nxvrq5vrWyuVVmW9uj7y8q9urF2mvt7YaDQrW5XVZp7RkOk+elbc1pXXOCNwL4vvDU7RYR2eddBhk1mIel7fTOT2EEsE/6PJSqGK5JiBb6wceOHabAoP06LMcbKTFZmHM8DDX9BMBZpuXN34ycNuXtkuT0f9tA3+TYd7OO9Mnq1+lHe7HGk7g3lYlyajhShbvZtMokjXY4ngbdYjrd73UbkN/q2i3pcIRslgTvCH71z6P5eCS9VZnJ7uaN4fBN555m9e8FcU/Bn8goBHm2T8KNksUN484VZ0sKxY13xho8G/U5RVzSYa7b04TRllWOr0l3s/5BUFPNfHooDfDzAms2WCx7pRbXSB8pDuDPGgbDzqJa/MqJkBtFHKPUcZGJ9zorz+6m6rWiB6Vj58h/TniVfPulTNqyMmn8Uw8qm4dHBRyMf4ORCEn0r3EvJlQdt4tV1MaFcQfhFkiPD4bN/ju+fggqz4/RJ8Z/iXKS9OdkpzQeQVxbupPcK1LHCh3KxO43b8OMmCbyZQv4aX3zGPWJ+m8y4bsVM6iMv8KNWe4r8zyf+VXaV6zcpxQJTDaKNe+Ws7K6tZbZ3Rn4+CtuWqS4dRPlZvqu3bt8vRoA5/tNODG6bfSEfh+tqY4vqMR1xf9IjrFz3i8imvz3vE9SWPuD7rEdeHPeLyWcYve8Tlk69PecTlsz36rMdPe8Tlsw191SMun/XoU1e/4RGXT/36ikdc3/SIy6fej6vN8VnGb3nE9ZxHXL/sEZdPefn0TXzq17j6hT71flx9uRc84vqCR1zXgy83rnrv0zeZ9Gn5cI2rLzeuttCnL/eCR1w+69GnvMbV//qIR1zj6n/9vEdcPtu2zzbkU14++yGfbWhcZf+CR1w+5+XGdW7Ip3759H3H1cccx74jfuY1Kx99x1IKbnx2rQ0rOgXBs1pTngIcc9FgeX2uKxv+Q4HwW7kPCllhmYw+rzFbvvo1XJxntOYJl+eyVV1lc61F47o7yiAN18GcuOZEXog6XXaUG+kvOnhV5Vj0KJOSR1wcG6Tav1q/NfhDAl7pyZKgbd9a3R6GPI91W3PVLdoIo7+TXUYmt4cIzk4UnooG28bBFFwR/f8QvSsCPkyjsu/8v8XWYEwv32Y++hiJZr1A9KzMEZXrpRIj0en04HbrM/ySR1w+5+h9+t3jOp/hs4w+14rHdd3mBY+4fOrEL3jEdT3oxGRNY+9k71NePucEfZbR53zGuK7J+pzj8qn3n/OIa1zn+33qxMT/emnYaJ997Sc84roebOG4rpl90iOur3vENa7z6j77tMk6RD5cL3jENa723mcbesEjLp82etJ3vDT6jkm8xd7pxGROYe/K6HNPwriOh3zK3mc89bjOF/r0cyZ2Yu/8iYmd2DvZj6udMP/LFTsTOI4o83F/Rn9UsTlKrirmIm+Miuv8LiwT5iEPrnPClgQd/l/FEXygc/WX6zpOZ5Lfyq5SfYXlZHwh3UCxZJl1zOjPR4P1FkLHVFyPiiky2R0WvC6LvGX6DutzNDKvb+5U5oHsjFPmyl7mkXmcnu/04DivKN5NOXC94BHX5z3i+oJHXJ/xiOvTHnF92COur3nE9WWPuHyW8VMecfks4xc94vpFj7i+7hGXT/3y2R596tcLHnH55OtLHnH51PvrQSc+5xHXCx5xfdUjLp9l9Cn7n/eIy6fef8UjromdeGnYCZ9l/KZHXD79iXGV/bc84pq0oXy4PuER16QN7Z3sfY7dfY6Rea8rziHxHKaabznkoIPfG5yic3CXdFx75PC7M8lvZXepxvvvPOLu7sW9Yfe4V/iF4b7RP98Nm2PD8/bxfobfu7FXR/Ef3r9QpG8LUMclgr/5SA/n309w8p0uETzPEb5C5HMuMvvN5kZ/nnj1y09vbnSK+GH58NxoUfC6THlx+linB8d5RfHOhevzHnF91SOuT3nE9WWPuL7hEddnPOL6ypjy9WmPuD7sEdcLHnH55OtrHnH51HuffL3gEdcXPOLyWY8+Zf/zHnH5LOO3POJ6ziOuX/aIy6e8vuQR17i2bZ99h/kTNl5B/9Hu6FD3gvEdUHj3GeLAPOTPdfsyfj+d8h2Xw/xfvsPuTPJ/ZXepavj3hcHfPWdm2P13Rl/dE1dI+TVcnGe05gmXb9m5yob8sx7gPXt8Ho3CNZsTV+BbrLt16rpXC+kvOnhV5eC7EFU7KwiZ2Pt9Dr4QfknQtm9Nhnx33pnk/8ruUs0lQ2yLRn8nZ/SY3E4RnN13NhUN6uBsCq6I/j9F74qAD5Pr/tmCwO+q3+WU7+Pkuhd2UXxn5cN7HI9A/j6icUTweMTBI35vcIpOYZd0CoIO41JzNHF6b6eXj/AvSx7UfYxHBX+utnhMwB8FGONHyeZYhu/itChoGU/Wjm+C975tIdIzfvEd0p8nXkP1STcRPywfbhvHBa/LIo/twnFB57igo3AdJR5Qt0ZUf7Wd1t/RMPw46++okGve+uP59eNBylHdNL5ujgaT5Z0A2qwLt0AethVORfofyxTbr7+kO1Yjgctooo4Zb3OCV49yanF5I8HXSXj31zqD/EcOWZwAWRRP9vAyHNNE/T5JeVgfpygP9alMeTdD3mnKOyH4ydI248Q2xqVXRz3SQRkdIzrHPNJBeR8nOsc90sG6s7paigbrDtsJt/GieMd0bhJ0rDzo6+P60zuPaJro2+C3dg5lienc0sP57gSntfGTwJfHNr5tZWM/HMtdBtonKO805LE+3wp5rIO3QR7WLSdlN0wWsd04ncNuoN0uU56rfw/kD2Xu343+qPp3l18cJ1f/bt+qdmtrw0tCrlimNB6Uj7hTexfWx8het0Z/VL738YxyVX7QcZI55lm8wpKQK9dtXr/8qOBB0Tm2SzqqLzMbbfblXUkHEdvo54/0w9hcxachjuATybPqE893+vPQz+Aze0+KvCuxDwnTJo8ylIHnCcqAoyjeueYJyim4pgHXHODiPs7gv0392mnA60/fm6vcBxkNpH1bINpZ277RV32i8T0v8qZ3wev21lqlXmk2W+1mY3OlsV0g/MYrv+O5k5cJeHVussn69iiIrGvdew46PfwvA7nGaRrybqO8EuQZj7He/8Et/fy/LBD/WeSP9JcF/ANQhjx1GRIX2gMfuGZ3iOtQ1N+e0OaEtUG1mrJBllSb53UmbGM23igIXMpHtjLFON+Qw0cuQx7yxuVQ/YfN3S9Fg3K9lXDdNgTXvYTrVgdfLxuC6wHCpdrVoviO+4swNqDSyNpfGP35aLCuQviKw+TKvuLtgtdlkYd6gXlI53ZBR+G61SMu0wulvxyvfFrQOe2gg9+z/Qnjh9Qayo5YUnVWpryXp5Sfk7I/VqbY/lzIYX9Q5rdT3m3i28Bts7nTthmmTt1tU/V/edpmnOyMj922p+sNl2prhZRfo8PvmA7qNI8VcL4O5yJ/QHOR9h3OReK3D3Z6+Qh/D4xzf5jgVHbReLR2+ArI82jL1qzcr4wGk+W9CmjfAM+clL0yvvOuRWA7fxXlYf29mvKwPb6G8tDuvpbyXiH42al+YV2ljUV90HH5W6HaC/cdt3ukg3VndbUUDdbdaXjGPKPD75jOaUFnWPv/90c0zbT2/3inl4/wb4D2/59ozgbLuJdt/BWU92rIY31+DeSxDr4W8rBuOSm7YbLIuxaBdWtlCjtXUmuyfYkEX2hfeH7ylcAXrqVwUnLCuZVP7dC+cn1jezfelqJBGZbhmW1Blv6+LMqh6Cztks6SoBO4za2qerek6r1Mea9KKT+nYW0nzxgBZf5KyiuLb8PKMPsYweiPavyu+psyvOMxwisEr+wrxIn951cIOq8QdK53XMr+FlJ+jQ6/Yzqo0+Won06aj1A/2vsGv8s6RjD4V4KP0ExwqnUo49HaIdoMj7Zsg/0ATMoPyDtGML7zjhF26+vHz3dQHtrk11HeqwQ/O9UvrKtR+9Sh2wv7E6HGVuybqP60QHlGh9+5fBPuC9Pa//1HNc2sYwSDPwbt/x0JzjlRxr1s4zwmV76+5d0BeayDr4M8rFtOym6YLPKOEcqQh2VC3qfhHY7Z39i5+lsi+FZST3GdbR7tp3cKaJSjHtwPCE61x7DzP9lj2Y3+fDTY3kP4WMovUGN6Zbft22WRV4LnndgFZWPGbY6O4wVx/I71xmnY/F2euOoy5PE4HPnxKKdNtlOR4Ou18C5vXPWrQRZ5/JSQvkj8/HrKe7XgJ0s7jxPru9Kdl5r/oNrXbulg3VldLUWDdVeGZ8wzOvzO5adwn4x+JPopXzqqaaKfgt9yzFkXHvyUr5CfEmgskquNo/7u1BexvNdDHtYtp2Hjm9M7HN9gmZD3rH6Kwf8G1VMgv6JyiMqlZDrxd8L7OziXyzYur7/Dc6fj4u9wXPpe+DvYVif+Ti9v4u9oOterv4PtBPOMzjB/R7UztUaB/s4fZvB38Ns0f+evjvVw/hH1o4HWFq9JfwfXJHc6L8N2Y9gcSoFop/lFZztXf3n+5kWYv/nh0XS+TgHtR471w038mWtr/sbqcjJ/M8gPtreJP9PLm/gzms716s9gO8E8ozPMn1HtbNj8zeIxTTPv/M0PwZ9ZTp4n8zf9CWUxyvmbs52rvzx/c5LqaS/nb1z7BgL5F5n9HY4Jui0MP86YINe+gSwxQfEzz9/sNF4G9XGc4iHjZ56/wfaJ9cZp2Ngjj7+DcjbeAq+5r7MvEAm+0BfI6+/g+vhOY+99x9ejDQ/db48q9v6lGr+zFPm3R6qd8ZgjTujv3HNM00yLq2F/x+D/Z/B33kL9aJh9bvnaOOov+0lKn/PG3GS1GyaLvP4O+rJsN8qQp+ZQrB7QT/NXD/WK8VGJBpPlVYH2rfDMScnM+I5l9vZTPbwMxzTRjlQpD3WyRnloF+qUh/XdoDxsyyuUh7azSXk4HlilPNTfNcpD/V2nPNTfN1Ae6u+PUB76+T+aPI+b/nBbrUEe75OpQ17efTKod79e7uFlOOYV9dv4js8btrmnR9uX7m0/89DG+XOtjUvnLl64v/34U+0nL00TWu5SedvZ7SnsIp7IwW6cpijvVsq3Y3umIp0WxXdGw9SmAu/3Yrhi9OejweoJMVypED8sHx6uVAWvyyKvDM+Yh3Sqgo7CZbqiQt/5+rGyoFN20DkoeB43E3KQ8tCE7KZ72mkYn/E2J/jxKKc6m8VI8NWAd3mHRTWQRZ5hEcqcu1XUGe5W0bZwt4r1zd1qTfCTxZ7EifVd6Y7LLu6UDsqIp7Vf75EOyrtCdCoe6WDdWV0tRf7tXlnQGTYs+jYNi6wvzjosMvjvwbDot8gdLwNfe9XGUX8tbwXyWJ+bkMc6uAp5WLeclN0oJ8+7GRax3cBjCy92+vPwGMjT9B0eW4vDqd+jJWm8VoOPEVZHX1seHv17EvD/QpLBOvQPQIf+Mell1uOODF5t732ZKK86doqnOMMM68dLfy1vDfLyTpvikP/Fcg8vw1lS9Xwb0WD7Y8eYqXZxG+A1u8bTN/8UdOwHKUtgSBv1jnXs1QJeLeupKTD7dty2XfLUEQ6veTh6B+Tx1BEOr3nKEfvdvNu1cBntxXIPL8NZUvWsphuz6tgrAO89pGPG24ugY39JtF8zhDbr2GsFPNYXH3mAemTfzonvPOrY1qLg1ZLSFZ7Wy6sryidmvUW/CmXCSemYySmPjv1lBluCfRLrmApJxGV61rH/F3Rs6qZ+2q8ZQjuvjpWT54mO9eeNWse4npWOleEd61hZ8Iuhraxjs7A158YMOlaGdxM71p93rejYjRl0bCd2jLeLKd+pDO9Yf5S+4ZIB+1q4DGHfjlPoIconhD/l0q2s+oOhji+We3gZDp+RjuHF+omTy7+yb9VRCOWMeF18uPpBpesq1Ff58xzeh9+9PIVO2tYBPtLB4CtJ28Tr9aw+8Ih1oz2X/E5Dnsd1gGbMx2uBD5ZhqdNfbtd4KU5523w5eV6OBvsFDv/GOuB2l7YtoJ5yFAfyc9rBf159UjyOU/iQsi9ZQwt4uTKvrctqszBc6cVyDy/D4TPSMbx5bJZ9q454zDqf4eLDpWOuLRJKx7B/5hAd/C4tRAdtFpaNbZbB35/RZuExVHGahrzQNgtlyDZLtXkVmpS1zZvMXEc45QlzQpxX5jroOGCc/91HvJ4QvJ4QZVNXzpxIwZX1yhmDfybRD7NzYa5S6105w9cPI+1yINoFomfyxndI3xXupI4nDHHlTJl45Xes96cFvOvKmTCxCfrKmdMg1zhNQ16Z8rD9G4/qypnTgfjPIn+kvyzg+ZoYF644TY0AF9oDH7hmd4jLrpxB+2k2Z1Q2M6yty39t5D7KOw3wea+2wesf81xtgzIvwzOXQ8mcr7ZR65ouPUFcfLXNKQdfp4fg4qtt8Hu0Sfwd90thbE32q22M/nw0WFch4sqGyZXjym4VvKpYEtQLzEM6Kn5N4TrlEVc5eVb6y8dWnxR0Tjro4PcGF9bfqVWVHbGk6ozjBm5LKT+nYfEVeY6tRpnzWnpZfBu4bWY+tprbZjkMP862WYZ3O2mbceIjnXfanq43XKqtFVJ+jQ6/Yzqo0+Wonw7GGmEc2e/SuoF9h/MF+G3asdX//kQP5+8nOJVdNB4Db71Z4XUNTJaH8yZ5j63GmJniDo854fUArD+eN8D2yGtNaHd5jjTUVTDllHL5oFMGmNNE57RHOijvUcXFWl2p+DX2c9Qc5G0OOicFnWHt/1/cpGmmtX+eLzT4P4f2/yc0N4Rl3Ms2znPZuA5Upjyc+2MdxLm/vLH4Jou8caRYtzjnyjx4lG+d7Usk+EL7cr7Tn4dz1nmvtsE5nE/t0L5yfWN757gF5dfutL8/Icqh6Cztks6SoBO4zeW+/pLHCC9PKT+nYW3nwg73bvCalWv8HkaG2ccIRn9U43fV37jG7+oqRfYV4sT+s4oJV/G61zsuZX8LKb9Gh98xHdRpbptpPsLC8d43+F3WMYLBfx98hAPJB2ru1ngMe5xM/mu68o4R8Cqune4124mvHz/v5OgO5Gen+oV1NWqfOnR7GfU1m2rtn32TvNfhnRB0hrX/Vx/XNLOOEQz+H0P7vyP5IPBxRLnbOI/Jla+v4mtYB9XVmFntxk6PUMW6xTIh73jkWBlw8JHxBv+jST3FdfaG4/30jgMNo31lTongVHsMO/+Tfe/9S+GK8fi5BM87sQvKxozbHB0fjaquWs7axnD+Ls+eeGxjPA4fhyNk45R3TzweEzu5pntyTbeLjjqSTMUhsp+i4iNf7qCj2pnyI9FPee9xTRP9FPyWY9sM/r8CP+X95KcEGotcV9d0o++OZULes/opBv8M1VMgv0Iejcoynfg74f2d0/DMNi6vv8Nzp+Pi7/DRqHvh72Bbnfg7vbyJv6PpXK/+DrYTzDM6w/wd1c7UGgX6O9/J4O+ouEb2d/46+Du/Tf1ooLXFa9LfwTXJnc7LsN0YNodSINppftHZztVfnr/5Hszf/P7xdL6OA+3qzf1wE3/m2pq/sbqczN8M8oPtbeLP9PIm/oymc736M9hOMM/oDPNnVDsbNn/zp57mb74E/sy/nszfXEnjMn9ztnP1l+dv/t0Yzd+Uo8HyB44JyuzvcExQOQw/zpigMrzbSUxQ/HwantmW5omXQX0cp3jI+Jnnb7B9luGZ07CxRx5/B+VsvI3TFUBxyuvv4Pr4TmPvfcfXow0P3W+XU8rlg04ZYF6q8TtLkX97pNoZjznihP7OrTdrmmlxNezvGPxHwN+5PcEZdp9b/mu+2KfF+JQy5eWNuclqN0wWef0d9GXZbgybQ7F6QD/NYz20jI87osFkeXguD+5/5aRkZnznvdqmDHl8/SnqJJ9xjHahQnlY39fLdTnjpj9lysMz7E5THp5hl3efDOrdr5d7eBmOeUX9Nr53cLVNmf4/Tf/fmsLubq624WMfsl5t4zoa5w54vxfDFaM/Hw1WT4jhyh3ED8uHhyuvE7wuizwOZ3mdoPM6QUfhMl1Roe98tU3eY0sOCp7HzYTw1TZoQnbTPe00jM94G6crgOKUd1iE1/zkGRahzLlbRZ3hbhVtC3erWN9p1+UgP1nsSZxY35XuuOziTumgjHha+7Ue6aC87yA6d3ikg3VndbUU+bd7qp0NGxY9R8OicgKTdVhk8O+DYdHHyB0Ps5Uu/zVf7P7iVU2sz3hTIOsgXjeCdctJ2Q2TxW6GRWw30A/iq23w6pmT9B1ePYPDKb56xvD/5mjqtdvHnRQyMdqnAtHO0sZd9g/5Vn7Ybo4hrLU3t5obG9v1re3K1sZ2uxAN2l6XH8ZtHOGXBXzYaY36huk9HkNYjnpyjdM05J2ivBLkGY/qGMJyIP6zyB/pLwt4Pto2a12qvpKP+8uKy477w2MPeLsqj9niFNYOZB/3GP154tUzP91xjxonTAu5Ljrkqo4R4bCUvMeYIS6z+2rcc5To5B33HBXlGbfjGjn85TTkoX5wUn02Hte403FPOXkep2Pl4pR33FOOerLIM+5BmfM0M+rTbZSH+sRT/Wj7eMq7LPjJYk/i5FqmmU4plw86KCPW36Me6aC82Sc86ZGOOmJUHRnK4568feAJQWfYuOef36xpZh33GPzDMO75Y/KPw/io+Y+OLFMeTu2zPuPUPusgTu1j3XJSdsNksZtwXrYbLp8EdXwvfBKjPyqf5Cjxw/Jx+ST2rWq3eJQU24e8PonV5VI0WEfHiI4qz1EHnWOiPGH902pb2UxLqo/iEJUy5OX1SXAeIY9PgjI33gLbq4rqk5mv0/Aur0+CtmWnPslpykN9Yrujjs/J468gP1nsSZxc475R+SSsv8c80kF589jzhEc6WHd8pL2yiTu1ey4fK80nWTyhaWb1SQz+LPgky8nzHH2/l20c9Vf5K6zP6K+wDqK/gnXLSdkNk0VenwTr9jTBGu8lAXuE8gz2Fqivn0iel6LB9rc/6s87AnkL8Ix0UXeORL303o7m89aEfiyTP7tF45xKwWn6qOb1rBxhry7aqqqri9BOlTr9ZcL2VBTwPHeq5kqwTbEvhTrJvtS0wIU+Dl6ndQWm0/veeNwLeSKPWeSp/Las8jQZKXneRLiOCVwoY5c80WeM0zTkhZYn8sjyvGlImVieSv4oJ5OR2jpyM+FSPji2d567NtwzAp5tEsL/GNic227p528/fM+6sCBwow11tbN5UY5FysNvY7y/d2M//9bf3gX2+0GiXRa0Xe3htIAvA4zVV5bj3vG7vZx/4L4+6/yDK6TfddRt3rmJcvKc5wrgB1N8NaPBbZF17LjgF31Anmd6BHTsUaKtdEbN3xv8rQL+NMCwjuFYg7d/4Hcedaym5qotKT0qUx7qEesY6hHPcSk9sjwMUc0bO2VyyqNjXM9qXjSrjp0CvP+c1vfLSd550LFnR6xjZcgbjY6NV/yI5a1AXhmeOfnSsWcz9FdZdawMeJ8jHbP2+DHQsV8g2mrbK+od69iwa11Zx9Am2Lfjduwxr2NheHuZ8jC8neeo8l45nFXHcBvri+UeXoazpOpZbffJqmMvA7y3ko4Zb78IOvbrRPuVQ2izjg27qtbkPrmeuj9vlNdTq3pWtgT7JNaxWwW/uE2edew7oGN/L4OOIe28OsbrJhMd2xsd+3sZdExduanWDVDHvpOiY38fdOwfZdAxlz82sWO9vHHWsX8UyI7xca3Kd3Lpj+uKd+Vr4RjLvh2no39QPiH8KZduZdUfPGroxXIPL8PhM9IxvFg/cXL5V/atuorgREa8Lj5c/aDSdXXUlvLn+Xgd/O62FDppR/fxlQoG/yLMU76c1txxLtloh51LrjTVXDLKsNTpL7drvBSnvG2eY1mxX+Dj17AOuN2lHcu3kHIVBvJz0sF/Xn1SPI7T8R3KvmTd2n+a8vLauqw2C48LebHcw8tw+Ix0DG8em2XfxjrzL1KuWB2G18WHS8dcRxQqHcP+mY/IwO9Op9BBm1UG2myzDL6Y2IdhNsto74XNQhmyzVJtXh0NkrXNl5Nn1xVKeY4ZQZxXjhJN9M/qwdbUlm7pwdxC6+q2Low83+Qoo1prwLVlm+9eIh7w2znx3V7GxvF6ThnyXLH8vEaE7es45WH7QplwUnbN5JTHl+d6vploYF3FiW3ctOA3xvvOZFF1nujaN2eS/ys5U63Valcb1dX1tXaj0Vpf4ePb4mS6uBCAfmNlY3VrY7VaXW9U243qyOlvrTQ3ty4zUWlXr4hj1PRXWptrldXaxnprq9mqr2wNo29Xes50evlo0+M0m/wf81UU8IavRPAVsFc16jdKgt6VdXcHXCHl9woO8W660/9urjMIX+wMwhvt+c4gj5a3AHnY38Rpf/I/ygtxGR8lgv+xpOxWJ/vgG/t+WdDfR/T7+BbvsC9gXEXxzuDj+llNeDS9xbL7jkm/QpPw4zvmzXQn1uvYxv6bRPlVjExeXUqLaY2TXf9p/eFMFEQmNcM/S/x5wt+NyShFg3Iy2vuClG17O0s9IP154jWE/iE944flw/uc58LIpx2fwWK6h+13RsiG+ZglHucD8ajGBMaT5U1DnvERw9x8up/HqUA8hm2j291zB9D/w/jsh8mfs7rBMRnqPfatCP8u6Ft/BvoNw2vfm51agPxZkW//W31NCVjeGz5LMlRyRXjTyZmUss5QWQ1+E8afrziscaL8kK+pFJxtMaY1nBjX52rzBr8g4LGNGT9L0WDbXKDvkPe5qD/hO1U/BYJl3xKvvJ4l2NkUOiwPxcM+gUft/ZgjXpEm60OceCxTFHSwTWGfPyfoe+wfVlRfacnyZqi8mIdlf1enB8dJjSOtTHF5fzLHvi3V1nz6Rva+BO+ZbpFgZwiWzy9AHkseeFwWdGYI76yD/wLhmRbfLUa6ParfrPwWBL+qr9ktHcT1s51+OljP2Kd9juwn2vGi+PbZTi8f4b8EfdoXMvZpbEuwDO/u9N6xzWY/ltskz+ly38Uw2I8j/NdE38X2AXHF776RwUdQfh/7CL8P8vwWyVP5AEvRoGxYh+eIFvrH1r+wDH4T+Pi1W9JpmVwXHWWM3337Fg2HPCAc41B9p+FQ7dq+WxJ8cdtj2zHjoKH6M0WjRHm7rR/Vb6OvoXwYlY/9OdLhd1MCfpj/MZ+CW+GdEXiUnd9HeQWRxzYMy4s2jH0TNSZD26jaXVrduXxvxXsWv2rGwbuSH9oh33OUlbVKtbK1urK9XW01NzYbw+Yo7b3NK1q5rvzCuxKUK044f8bzdzgXON3pp29zZTh/h7iMjxLB/xOav8N5Kvt+WdDHOS6mpejz/J2a15wT8HGd/kOYI/M+97+yvraxvlmp1rZrtfpac9Rz381Gs7q2trG21dzaXm9sbY587n+9ub1er29W6+ut9np15OVvN+qb29Xt9dXN+nalvlYd+drDRqV2ec1lc3Ol2t5YX98eRh/HawWgH6es8yEG/3+An3UHzRFMOXDG6ZlOP06Df9ExR6D2A6py2vuSgOexaZyWosH+xL7lcQXCBdGnarW63WxsrjW3apentrZGvpa3vbrR3F6trNRajXattTFq+put5lZlvV5tbWysVlaba7vR5zgpPbG+2Oq9SLwPwzXlwFVw4CoNwXUv4cLvWR95/B+nuWjQ//I4/9IoED0rR0Tl7vbR0WC7CrFeMEyuUyQ75ecvizyeg1D+6Yygo3AVPOLifZFptkmtx7n0hueMziT/V3aXMutNd900Go3eFImfYXqj+g61Nml3UrhsiDoLYFS4XHNYoedws+qC0Z+Pgupm1SXXopArz4vitzz+jRPXn7JVap3jWsGF9kfNa5/v9OcpW6XG8zwvpdb22MYtRel1w3ZX9a3IL8+TviIJiFPxAB71UV69yWvJgfr3pprbs7Qoys31jvM5XLe8Ro956tyOguChSP+jLGLarzvdw8twlpSOFChvRpRDzSVxH6B8IFf8gGtOUtlvuyOgQDijyD3npHzTnfjQSO8B4sXKOyPgEV+J4H88aVd4hgzjtDFknD7UGcTJPGdt2wb3RuBhG3SI5cB95Lj52aHPKnWNp+O0Ez87TtwX7dQ3DoUr9Foo+/NpcSwPnOx9w21K+Sx8zqDB//TJHs6HkmdlI4zHhchtF9RcEcs/Lf6E7YLBv8thF9RaJ/L1oY7G+R7A+fKU9T4sl6o/e69i1Fzre2pdbdg4/wruziDOwHs9GmqvB8qn1Mkuizix7NS6llqTXCZ41XdiO2LfZJhP74p1wfPDHgC9CTnXVBqCK8v8kMvuIS6zDcof4nmLrOtyyoZw3IRr/iFQDG/mMafRH9X8wzC5cn/qWjtXfqnLtqn2qXBNe8RV8ojL6i3PHBjzwWsPcbI+v0R470o2PcVy/+zJfhjD90XoVz9/UvMXpzd2+vPUeCN+98aEporPjf/OJP9XdpVWN5Q/6w9/7+5LjjfAsoWJcW9sZW37HOMeaHxfzdtnqvEzx1Rgf/rxTg8ura+dE3QUri97xPU1j7g+4xHXhz3i+pxHXC94xPVVj7h8yusFj7h88aXs7Ljo6lc84vLZtn3qxJc84prYr4n9CllGn7L/lEdcPvX+6x5x+Wzb49oefdroce1rfdbjpz3iuh76oeuhjD758mlXx7Hfjp953D4u+uVTXr/kEdfnPeLy6ZuMa582aY97V8YXPOLyWY/XwzjNp0580iOucdX7X/SIa1znOr7hEVdIG22wKhYvThZLxGsgZ2jNIUyMS6PFMWNGA2nPBaJdIHpRpNcEjL5rDn5e5O1q/0N1u96ubG42aputlWazmVc3DF6dp6HWF0zWC2FkvaniGOZBrnGahrw5yitBnvEYy/4PbunnP8z5Oo3NLPJH+qptXoAy5KnLQ1G/rmF7VOuKj3X681QsE64rqriHAuHH9V+M5XnrqR6v+B3yiOVTsWAFoK/e43OB3iNdpHe20/8dx2wxL1zeouBTyWJKyEKtRRcJh4qJTNurUSTe4zQnePG4PtnOahvHNT4/vnfQzi59tH3pvqc2z5/burf9zJM/caF138YTl85tnP+JVuuJ9pNPsoZhFB6XFqWhYBiO4ZU2uiKSdhrhg7g4WsgV4TPsVCCOFlK711UkF8IhDK6uq5VwhZ/rY24Izw92+nlOO6ktrbdEXI8TLmX5DdfCEFxPEC78nk+m2p9CB2Gw594vaCv8LMvFITw/2ennGflaJFwHhuC6RLjw+wOEa2kIrqcIF36/RN8tp9BBmCV4vyxoK/wsy4NDeP5gp59n5Osg4To0BNfThAu/P0S4Dg/B9SHChd8fpu9uSKGDMIfh/Q2CtsLPsrxxCM/PEM/Il32bpTe9Ed577L0yjzSM/qh602Fy5eijI4LXZZHH0YJHBJ0jgo7CVfKIa9Yjrn0ecc15xLXgEdd+j7gWPeJa8ohr2SOugx5xmS0024S+2Znkt7KrVG9Yu0ZfhW0iynovRhhGfz4a1O8QNlH5GigfnjE5HIaflqu/PizkY3V5o8hjfcQdMwh/GMrI+oh6W6J3/0Uy8l0WONnmqj4H3+GI+ts0olaRw1n0CPGqKHKr32GnLf7dU/1lse/STlvkHUgG/4VyD+fvJDjVzhDe8evBBrT4heHGuvanx9XuDbpHo8FkecdEmQsCvkj/I99xf1yEaHuGY5poR/gWEmw3N1Eetj2+oQT1/mbKG5XuLnikgzJiO7PkkQ7K+zDROeyRDtad1dVSNFh3PBOa1Wapndw8/kizLf/slKaZZlv45CyD/2i5h/N/oVWcMOObapPHB5i4/aP+qvbP+nwT5LEO4i1OPHbEpOyGySK2G6dz2A2sW77ZyLWzJZDfUs/SFpD+qHa2qPkv186WJcGrsg/cNpW/tiToKFw2TzBHuCN/8tjeQx+7llU3xtXHVn2ufatsenEkcq3WVd8UEc84B8U2Lc0/5qTsVveGost/f7nDE+hZ75FXj3Ja4fJGgi/sM/5aZ5D/yCGLG0AWeXw/lPkRykPdZ/uO+sQ+I+oh+4w3CH6ytM04sf3CuppNKZcPOteDj7kUpduQQjTYxovincv3Y182zfdbLmuaab4fn+hh8O8v93AeTp7DzlPka+OovyH8wqx2w2SxG9/vCOBXfaY9p92OsyDo8dytay5A+SrVer16eYi/Wt1ubddXVtdrm9VmvdncbmyvNtcare2VxkZrtV1tbNRr6+3VynZ1rd1eXalvrTa340sLt42WyXPKUbYcPlNta7taX7lMqdLcaKy0mvVaq7ZaaTVWtqvVtWptvbFWr29vNdZaa7X6dm21tpXFZwo075b51CWjPyqfSdkhl890g+CV+5A44c1EnFcU71z9EdvOneKKE58Y6Fq3C6QL9Z3qQuh1u2FruDvRBbZPu9UF7stdY+NA45/MbZnHP6HHxmOyxlB31XPRwU+gdfKa8aPWzdTcQbzeNhOl+3esk8g39t/2jutB0Xad5MT999IQXBybpXxhV5tHXBybpeRRorxHyld/Yxm+qdwPY/FC7wCYe5Nn19xs2DFl9jZt9OejoG2o6mpDapwQ6+xs5NYdrLu0eLV5UdYsuow8ZdFlNWY2uCs3AJZ3BocRsHjzzTsdcPsEHNPiE5sQR4lg353giPGeO91PF2XBp5dhXOI85WG9LFMe8sSnPapbr9SJuouUh/LhSGWMnXHtYjhAeaiLBykP63c/5WG8iMV1LUSD49THyld/Yzl+uNz7Bm10nFx9kauvQDtv8Gqsb9+O2/oIj5HV+qgaB3ObxfUR9sduhrzdrJ28WO7hZThLqp5Vf4ZzHK5bvg4DXp47Ufrg0p+jAh7nK1h/UEfs23FdQw+hI5Z3AvJQJpyGrdm/WO7hZTh8TrMNWXXGvlVrrQsZ8bp016Vjim9sc6xjS4JvZb/SYmtwzgnLlrZm/PXy1V88EVft2MKYtDhNQ57P2DB18izKsNTpL7erD4hT3jbP649om3n9Cesgba0fcWIcEe72MT7U7SJxMhsT5oTEyjr7BZjYt4lT3rUa4zvvWg36YexroX/Ddg19NPZTsM7Yn1I7Ufk3igbHHHHi+RDXDatFj3R4vhnphL65meXtg47a98MxcHup/1i3ymfmuka/mOsH46JZprwPJoqytzeTU9Y+dk7QuZ7ki7aak5KvwU3k28tzyTfvjS47le8UleNM8n9ld2ms5JtVhiaLvOucqKNWprRbltSNdIbDbJDaPR4nvonF4P9V+epvYJ9H3rKU5cZxVb6iKN8DKeWbOn31N4b98/Jweq4brNW+Vh5P8KkUiMPqV91wr8pg8H9Vvvo7bMyA/Xecpjv95TuTvK/sLsnbKtBfLXX6y63GfAjPYwa1pxbbNJ/Er9p0gf5HXOrGJtazGQGP+FjP/mP56i/enrIcpbdxy1Nzri5f0/JQt+aA5+OJvs9FWsfPJP9XdpdW1VqjJTWXWqA8bCe8hsoni2Ae6kHefs5kkffmMnV6hbITbAv2CV5VuzX8e9FusY/ldqv26LtOwBnWzi0OS8WjsX5jm5mjPLWewW0mTm8memreH9vMAtCa6fRgfa+7xslkXQSepzs93o2+6cs+yDM443UuDK8V43U+wY+3ws0BP1aWKYLn5xK9u+N0j28sI9YjlpvHDQuQZ/BFeGc82jzSDOQtdPLh2ke4ZneBy/haFvCzO+RL4ZohXHMCF77D/YCnoE2ok3KwX8X4yirUKdo29HnwW/Z5DP6nwG9rJM/qXBW2ua5Tj/LeTJd3DibwvEnmW5WM/nwU1Aeoss+EclU32QYeYzSMH3VOjarneL31QDRYZyoOAE9D4nNuXDebqjV6l3+g+j/fN5si7YUo3/hLtWNu5wj/5tNXf+P8LWrH6hamAvEXRe46dNW5OsVN1csc5Sm/1eUT7XPw5fKJFF/oF3NM7jz97yqDS+/UGHUP/dIV5Zdi2UtAN/5zjQ/jxHWwKODVmHGZ4FHmql3yeE2tQeVtlziW20rpS7EcaGd5TVa1T+yj+Xwr4+VM8n8lZ9pYba83mvXaVn17fWOtssZzPhHIaCEA/dXa1spGfWW9stVeWd1org6j/4lE8HOU57ufnBPl9IV/rdJu8TypZ/7r1m8vBsFf2zT8B8LwX7H2hjcVY1mMrrVR80nxuUAwDwLMgwCDbf0dAPOOFJiHAOahFJiHAebhFJhHAOYRgEGefwZgfiYFzzsB5p0pMO8CmHelwPwswPxsCsx7AOY9AIM8/xzA/FwKng2A2UiB2QSYzRSYLYDZSoFpA0wbYHAcvw0w2wATAcyjAPNoCq33Asx7U2DOAcy5FJj3Acz7UmDeDzDvBxjkGU+zPp+C5zGAeSwF5gLAXEiBuQgwF1NgPgAwuLcGeX4cYB5PwfMEwDyRAvMkwDyZAnMJYC6lwDwFME8BDOrPBwHmgykwTwPM0ykwzwHMc8QPrz/FyexjyPW9tcpKPay9r9Z4PS+Ccober14gelGkx+i8DyZM3+reB4PywTn4KzCdHj+cN90ZLIfloa9u9Rv7yQ8DHOsWxwXhHK7Z2JCnMK9Vms3APsj2Hupk5aWokzxune4MliOvTqJusU7iOMvstpoL/CDl4dzY05SH8wYfojz06Z+hPJwHeJbycBz8YcrDcbP1BzEPm1Hv+Ynk2eoIY3OL0WCfwXN7qFf+2udqK2T7vzxyrOS1e0XKQx2bBnk+TPIJ06f25BNC/rF8Dqfwb89xwjURtVZhMlJrWkXKw3WJ6U4/HVs/slgQxmV88HrTRvK/Wg/idRSkz+sofXyLd7xOlWfd5WeSZ1yLfCPQj//OJO8ru0t1w382DP6a4b8zDP7uvMpdgN9nv2n47w6CvyefnwqDvyufNyX4I3+4u7K5JwzvXd28Nwz+huHH+J8Q8nkL4C8EwP/WMPLp4n9bGPl0dfO+MPyvGP63h8HftHXxcmLQ1X0IvA6h7mnAd7z+jN8bnKIzvUs604LOoviukPJrdPgd00Fc1i6Mjjp/ynwaPDfc93pxFA0fFxn9+SjkOK03LlL3YKhzFk12BwWvy5QXJ7ZF6t6Mg4LOqHAtRoPl363Ooe5kOfNsLhqU6V7onNEflc6p+nPp3CHB6zLlxYn1RN2vckjQGRUubkOGX/0aHX6Xptt5dQ5luhc6Z/RHpXOq/lw6d1jwymeTxon1JO+5gqFxcRsy/OrX6PC7NN3Oq3PjdrZbaJ1T9efSuaxnu9kYqyDyiuLd1IhxcRsy/OrX6PC7NN3Oq3Pjdl5RaJ1T9efSuRsFr3zfR5zYNuU9Oz80Lm5Dhl/9Gh1+l6bbKEN1lgOPvfKeXT4l6Kg1HBt/x3N3/wPRtPl9jJnkNRXLR/h/ONXD+U+INq6NcbsKGVeL9KJItyu+oTnMXHSvXakYUZQPt6s5wau6PZjbQtbbg0eFS60f7bZd5T0/YS4alOle6JzRH5XOqfpz6dy84HWZ8uLEeqLijNWeyVHhUuuSu9U51h2k49K5MDePZ9c5oz8qnRt2Vy7r3ILglffcxYn1RMWqq7jqUeFS69271TnX3lKXzgU6czqzzvGdMqF1btidyqxzi4JXjqePE+uJis1XMSCjwqXiKHarc+o8CnUOKM/jF6PB8hQddNR5VhxvFSf0WWcLmqa6D6EQDe5/N/iPgM86X0gvI69jIM/LlIf7Fw5SHurbIcrDtRG+f0LdSbRE9NEfUnuCeK8N9mPzlKfuAldnEHPd57Wf0xnplHZJp5SRzuIu6SxmpHNgl3QOZKSztEs6SxnpLO+SznJGOvt2SWdfRjpzu6Sj9sO5cE0LXAav1jhKDng1P73ogFdziwcc8FnnhQxezcksO+DVWY2uvYrqrEbXeQ/HBLwaV1gfdBPkJV1E17/Cs1E9xvBUs/TZSH+eePXLT6W6SPSULG4OQ3s1qyxuJlmEqZurMSABy9v1ZU9Qebl+jf4ywWPZJ/XWk2vg8tYm9RaEn9D1Vp/UWxB+QtdbY1JvQfgJXW8rk3oLwk/oemtO6i0IP9VRlHdSb9dcva1N6i0IP6HrbX1Sb0H4CV1vG5N6C8JP6HrbnNRbEH5C19vWpN6C8BO63lqTegvCT+h6a0/qLQg/oette1JvQfgJXG9Xz6/xVW8FglW44mRrl/GZKbZm+mj70lsvXmo/OZWCi/ctHidcBs/PlmZS8BTFu4KAwbwFKBu+P5jy/lDK+8Mp79PuQb4x5X3aHeBHU94fo/eWx+du8133eMZNnO7q9P9v+8GXo8FUoD9+zzz6yo8C4vadHwl49a2CWUzBH6ew59c0M8cB2Lv5lPKc8cJPb226SPywfKZIPmHOP2p2bey04EfFFRo/pSD8VJp8fpbSM7W/BuGnQYYIj8/2Pb7775MK4PO9ED/fnxgn3reX976B6w3XWwLype4kQN0wvY1x/C7VN9s69RtFg/ZD8ahso8sO7pQO5ll877DY3z8s9PNm7SUt9vc45CP8QxD7+0ckS7QnbOvD2I7VzLa+ez5YFNK29my9uotMxSuafMLc27FaydLekF/jJ9C9Jqtqfx7HKau78xB+BmSI8Phs3+O7vyB9VXHeHPMaJ743Tu1FVLGWCtebJrhy4XpLQL5c+zOxDcT69n3SnVD3P5uNUHsm2KaGvu8vrS/5t9SXqPtipkSZ+L6Y/7/Qw/nvCv3lVrYb769Rd3ayjqTxM0v8GPx/AH4emOrnJ69virKzcSnTM6Ard30WNc6pFJx41hnbPfaBgFQXfthdNbwnxhWbP+yenJ8iXvfn5FXt9cI7XXgfjmtvyjBe7+4Mp+3iVZ3HtujgFctxICev93SG03bxqs5JOODgFcuxlJPXezvDabt4dZ2TpnjFcizn5PW+EfO6T/Cq7E6an6RsBPYP6rzj0dwfvFqNy/aqYo8PlmepE2WWnZUV4dU+H6xv3hON8G8j2mocibpidkzJ03jcC3m67mNeHlKmvPLkORE8/4z3fyn/CmXskqfxuBfyRB5Znr5tAY871J4+l91CGbvkuZftHXlkeS4MKVOWPst1BgLKej/h2k17Nx7Hrb37vn+d2zvKkH2rl2J7XxhSprzy5Pae1/+73tr7MHlye0d58rlP6D8ZTRzruewCjr1Q7oVIjy1xnMxzqD8N474fp3Gfa142TjyWNPh3OsaSai5SrX8bvOvuSeRHzVHMUJ6a23DxpfZoq3MPeL4yzJkt1U2rY4whsGR5J1LKyKlI/yPfcb39JLQjhmOaKNcTlIfzQrdQHo4nTlIejkNOUR76dmXKw3mD08lz2DXM/PVSpLxbIK9AeSchr0R5pyCP7wkvQ94s5Z2GvH2UdyvkzVHebZCHcuakdAvvptnKoFtsgwxvHvtn3+Kak5o/YFuQ9zwfdX8Tn1PzcYedLcI3qow2t8I4P+mws0XgVeHMMq/gOtNCnQnB55lGkZb3jdFw2qhDPGd3JCev6nyJIwDD53kif0dz8spzdkdz8qrOtjjq4BXLcSwnrzxndywnrzcJ+GMOXrEcN+Xk9d4R81oUvFr7M13+ZVh//gOao0d9Rxt7hX6nl2fvwvrGlUbeuS8lX9fc1zD5ss3E+r+R8rDv53pBuWL/dIVup5c3rnJ12c0oymYP0D6xXFHmRygP/SaXXK1vfynLVfUhLrminT1KeegLueRq/vVErlquRcpT56ChrS3Qd0gzq49YBLx2JqFaZ+Ryutbro8h9rrfB8Rrs/+jwEV1neseJfUSD/59yrusizizrulOizAa/l+u6Szl5HebPutZ1b8zJK/uIN+bkdVgbY16xHEdy8so+4pGcvA7zvZlXl++dd133aE5eh/nezKvL9867rhua132CV7MV1u7+FPzZW4r932Pb5LNUsU0vO3jic7cLgh/+Lk5s2wz+z4Vt27v5fN23Yj1x3+rymePEdX5cwKMfzX4J7j3is5Fxbc9oqvq0NdVxkyv2LSxX1TbUWZ9Z6kHJFWW+RHm4Bs3nk6Jcbd/TtSRX13pnnLLYKOyLWK4ocx4T4j1TLrnavrGXslyH+SosV+xTeR0K71JiuWKfYfvulFwNbi/k6nP9edh6PstV+VXqvqB5osP3p2DfGKc7O/159v2MgEd8HGN+cyKrOP/Xi/38HRDfY7+veFVjBB5bLabgtTuKQurI6lrlyh6DK7x2ejLB8WFE9EsEf3sCzOsb8e/0LvjcXt2obtc3tjdWNlqtxtbGIcIfJ9PHhQD0t1aam1uNlY1Kuxr/WxtGvzve7vTysc3HaTb5P+arKOANX4ng70iAY714PfltJUEvhvsxB1wh5fcKDvFuutP/bq4zCF/sDMIb7fnOII+WtwB5aI/itD/5H+WFuIyPEsH/CPjicdoH39j3y4L+PqLfx7d4h/aQcRXFO4OP66dB7QbL7rEP6O6xmiH8+I55M90J0a7am4311c31rZVKq7JeXa8Pa1d4d3eB+I+i/nGRJbOx1i+r+asClMWF627CVSQ5IK7SEFz3EC4VE2HfzaTQQRiMI1BxHwp/gXieGcLzvcSzomnfzA7BdR/hUvt1Xf0o4no74cLv0b/ivt9j29pQPpUl9mOxPixvP/Flz5y4P8YyxWX962TrI4HLaGL9L1Ae+q/7KY/jgzEPeefYCdTBKcpLi3dn3djnKAPHeKg4MbYjWearXfsY48SxXAb/XvAhO9P99NivxWeri6kUeqbvezdOa8p4QYzxwz6M/d6igM+7/4bnZNAnZ7uu+ggc37jiL43HvZCnz/HZokMGKCN1lw/3baqfRBnvfXywlifymEWeCJ83ntVkpOJZef/PsD3mLnkaj3shT+SR5Tk/pEx517tMRmp9k30P1d5Rxi55Go97IU/kkeXpiuWNU1qfhfC8zzhOah2e/a/dtHeM743TdKefhzPJ+8quUv72PjOkTCxP5c8qv3w5GpThPsKl5Kn2A7B9mBHwiK9E8L/imMNCn4N1QcWBhhj/XZ5SWd3aWK1W1xvVdqO6kmf8F1FZS8R7nOycgBKV+amkULE8f6sYSdn9LZhn+ZukV8jfGzv9eagTOI5+IqE5Fw3KOP47k/xf2VVqtNU5Lf7wN7fVuSL+8K82DP++MPyvqHGgP/y1iuGfD8P/mton4RF/91zI/WHqt274F8Pg3zD8B8Lgrxn+pTDy77bf5TD4u/I/GEY+3fZ1KAz/XftwOAj+Wsvw3xBGPt32e2MY+awb/iNh8Hf1/2gY+XTt57Ew+LtnFI7+XsvGVoHoRdHgXB/SD32vZYHoGT8sH56ru1nwuizy2MdR5/feLOgoXCWPuGY94trnEdecR1zzHnEteMS13yMun/LyWUaffC16xOVTVw94xOWzbfuU/dKYlnFiv14a9stnGX3KftkjLp96f9AjLp9te1zbo08bPa59rc96POQR1/XQD10PZfTJl0+7Oq799uEx5cunvG7wiOtGj7h8+ibj2qdN2uPelXFc++3rYZzmUyeOeMQ1rnp/1COucZ3rOOYRV0gbbbAY92B3McTJzu/lNfyLtGYe5u6RRkudH1mI+mnvC0S7QPSiSK8JcNwr8mN8z4u83cRnbFa36+3K5majttlaaTabBcJvvPI7nvdX5z2o9QW1du5R1puu818tbxry+OyhEuQZjzHMw8R/mBjzxmYW+SP9ZQH/VihDnro8FPXrGrZHFRdj931wXEycLC4H42JU/HiB8KvzKePfj0z3eMXvkEcsn7ovpwD01Xt8LtB7pIv0znb6v+O7RpgXLm9R8OmKpUdZqPj4IuEYWZzX9upGc3u1slJrNdq11tD9ez+WZMxRnt/2dPUO1EjIyAf+terVWAJMnvmvq1gyf/h7a/HFMPxXzJbg2SNclgh+DY6/QZj7AIbPCTGY+wHm/hQ8DwPMwyl4HgGYR1LwvBtg3p2C5+cA5udS8LQBpp2C51GAeTQFz3mAOZ+C5wLAXEjB8yTAPJmC5ymAeSoFz7MA82wKnucA5rkUPM8DzPMpeD4BMJ9IwfMZgPlMCp7PAsxnU/B8EWC+mILnywDz5RQ8XweYr6fg+SWA+aUUPL8CML+SgufXAObXUvB8G2C+nYLnbwDM30jB812A+W4Knr8NMH87Bc/vAMzvpOD5XYD53RQ83wOY7xGeuUj3pWeS/yu7SGuX/bqwdna1wv09lj/s+c7Z73U0+vNRyD6tF/M07GxkjHm6AtPp8VOgvOnOYDnUmMHKHfvXdwMc69YUwN0Pz++M+nkYtseYx1Uh7plbuzw+VDHh/uqsWXHtK1F1wPclYR3MgjzvJribn+/BTWWQdTEasayr1a2wsq6OTNavBVlPk+xCzPOgnga6o7V2WPCPtOI024m6qevfwjuTn8kJz6vg8zLw7I3pTj8dO5sCz8tAXMZHieDfnvyvzjCx75cF/Rmi38e3eIfti3EVxTsc496TPMdjRRtjvRHo+2wPhv9sEPyVmuG/Mwz+7hj3rk5Plp5wd2Vzdxje64b/p8Lgbxj+NwF+j/Lpyv6eMPw3bU/cDxN8yo8s+KNXUft+2Y8MM0ffnNwP7pbPuN0P3lRnhYzqfvCnk1+1VuKaGzcbWRB5rrnx6xGXsjM++XKdEY56G+vIdvKs9n0XUn6jaNB+KB4Rhs/smfZAJ6zdrFRcd26ptRm254HGGZntOa9tBrorvWvPXfv848T1FmZduFrJ0qaQX2VvOf5kmL3FM+3z2NvPJ7/qrgy2+a52bbTjFMv8U1Q2tT6/03aNskk7b8oHHVffG0Z3KquBzzpbUeuHeEbF1+E95qXd0WVjNz6D4VcB5zeT5yXAi2XDPLWuqc7sm6U8tb68IMoxJcrB9VmI9Jk2Slfs/bAzhUrEL7ZP+5bb5reT37g8PyB66owY9Gfv7Aznz1Ue15lfSF/dC7GYk9ezneG0XbwOO2+Mec173yvyendnOG0Xr+qs5QMOXrEcSzl5zXI3iIvXZQHvuhsEy7Gcg1e2d2m0XbxmvYNe3Q1yMAevceK7QULzWhK8ho23qnbnC7BslhajQbkVKQ/jRNj3VmevWx7G5/PZlRhvv0h5GBd7gPLUPYJ8TwXLmVOR/kfZx33HnwJehrOk6pP7MaxPji8yWWFfjLrKfbHB/1Pg89ZCP5+jP++reuW8r9uBD+T1Cv+d/nK7+tY47bTvUuclZlk7Qpmn9bMzAh7xlQj++8lvLJsfKfTzh/4un52pfFTlL6hyTIlyZPUPx/08+3+Z/L/X59njHK+P82q5jRv8/5P8Yhv3cV6t9XV7fR4o24tr9bxabGdXYDq970d5Xi3L81o9r9Ylz73UT+QxizxVPEKW/g9l5OO8Wpc8u2u7ye805Z1J3ld2lbQ8r9Xzal3yHOV5tSzPa/W8Wpc8R3lebZ72Ps7n1d5JvO70vNpTiTyU/1qA71kXxnUfQ8h7gF6VIIhl/BrQoyuwgl4M9wYHXCHl9woO8W660/9Oxe+M0z1AqwmCcb4HyAYs43gPkOnOOJwDbXsHr+n9QZXGKtrQAPzXA+/fqYWNHe/tDzrb6ccfEV21/9C+UbHv1l/F/YyNw+JnnNeLE8ckxCnknqvLOtEMXGfVwyn8x8nmGmxulfNnosG+GOPk0/ppjNOc7vgvl4+5HpvD3eu5npPJ88S2OVPgvY+V6qj2Pp7t9PCrNumybcPsF/vlmHeXoBuyzJd1YiVwf9GNv1d9hNk2a+dFAYttQcUqIHwk3hWidPvIe8giKHe1Xq9WKq3V6nZru76yul7brDbrzeb25fFGc63R2l5pbLRW29XGRr223l6tbFfX2u3VlfrWanN7vbXV3OayTjnK5tpvNGxf+Ljb8FuS//fahp9Onic23Jkm/mk08U8pZfJP8RwilHMpSrdtJYK1tf7Ypz2cgi+Lv1tM+Q7HqIwj8igv17kpyMe17p+Xk//32rY/mjxf27Z9ZWXin7uT2fa7Oz38Wf1z+ya2Vdb+4ueT8E2cOLYO894k6Foe7yfDPDwXhfeivxnyeE/vWyCP9/TimVGzlPc2yOPzsvD8FT5n6+2QN095eCbLAuU9AHn7Ke9ByOvukU3+5/X2M8n/lV2ky/3hmroPyqMetg4L/pegbHEKs/e1tzf1bBj81cB7X+u899Uz/ob5IxsJviznbASyV232L6JocN0G6Y/qnI0i8cPysee4LZt9fLR96b6nNs+f27q3/cyTP3Ghdd/GE5fObZz/iVbrifaTT2JplAXkfEwMw3AMn7UUZztXf127E+z9sJNH3ki4lIdpuLJG5KkdDiX6biaFDsKokw0wX+Hn+pgZwvNdxLOiGXY3bWXFeN3n4BXpG69qFT0wr91TOedy8qp2xarVeoRDmBnxPebvE7QLo5HJqslkPqdMsNzzo+F1zXhdyMkrjoQWRsPruvG6PyevGP20n77bL8rh0rVhkWwj1rUNk8liTplguRdHw2v3BNkDOXnFfvPAaHjdMl6XcvKqPOUi/c9wCDMjvsf8A4L2iHStZTJZzikTLLd9uyh4dZ0yPU95avchR1ajvNTqAo+iXbOnrh3sajcM7xpG+652S/MuIrUbcTEabA8m22thFm07+X+vZ9FOJc/X+ArJxmSFxJ1GsUJiOwjj50OAL05qhcTy1Myempnj8SXOzI3m5LreqkugfqXhOrnOZjlsJjO27bYb8vJI/fIY/aGN8+daG5fOXbxwf/vxp9pPXuKDUYr0P+fzwehGGuE4Feh/nnQp0P9TAg6Ta4FEdU/cBalFc9V1oVjHvbuwCZm97i4mAZ+ZUj2wOa+HNHNxUt1F2pRVnMy847PxtNMuRW3GMNy4CB8/dw/CjLTtOBPtXi6mN8p19oE/TocF/9j+MCh0PzxfuHjp3PYzb33q/Plz2+farbdevNSOKLHpTzPLWCz+jpPBTeJKs5vQ30qer/F16+rEhLqTmVA0hy4Tap4uPrtMqOFVJvRuysN2YrhjU2LeI8byKO+aPXZc92aP/V7iHfNw3ZvXxHHdm9fEcd2b18Rx3ZvXxHHdm1cBQpzJdbmLWA97lktl7bDgn/dGT9ahZapbF2rnkqrVMmwrc+KdL17U3t0C0Q01yiwQvSjqH1JFRH8+Cmoru2vUWfcqx66PzQo+eeniExuPtu9vb/Rd4YfoVNGw6AjDI+JhblLaCNs1YsakFqp5mz9XE78znpZTvo9TYM+1yZPYmNQEMI/acYH3bKcHx4ldPixTjOMjgJfhmB+UOR/dNCV4LUSDOuAKpVD1YXmBJxS91gd2J5xUfdi7vPWBMjfeAruBueWkTKdLFtMgi68DXoZjmsVrQBZTgv8QslDttBAN2l/VZZztXP11HUnK3yk76QqsScOh3Aru1tN4YnsdpzPJb6210q6sr22u1TY36qubjfrm+vpGtV5tVqtr261apdWoba9Um82t9fb6drW+vbnS3miubKw3W9V2ZaPZYlpTgq8pKteso1xqwVYdezGbIgOUTdqRF6yXiv99Dv73pfAfpfA/7LhnXnC257kM/HM7jtOZ5LdeqdfbG7VGs71SabbX1tfa66vbK6uVrY3t7dZqpbG1Gd8D3KzU43pdrVU2a+vtan29vbJVjdtw1WjNk2zUsR8qaIOHLSoQSQXILKTIAOt2P8lmXnzD/0+Jb7lu51NoI8yUKGMaDmXXFP/q6Lcs/LP896fwn2Z3VOCNql8XDrZvbIumUr7jADWl34xzZghOXvCfEzhVMECB8hAnB0kUiDfMc60mqT5B+StchqzBHFmCJK6F6dXnkv/H4YjGpwEG6zeKtL9+ttMPj9vHlP0wfLyV7ePJb8zDr0YaJ8r1zs4gTjUuiNOZ5Leyy2T8WP1hm5l2lNHgPw1l/A0qY5HKyHK28io/1mMZqyXi53PA87eJZ+U/Kt1iuSG8sqsqaJxtC9Kx58Dj9FqB6EWRnh8x+vORtp9n/PBT5X4H5arqQdl6Hm8rPc5jG5Du2c7VXzV+KNJ3RcET98GqH0IcrG8I6zoyYByOg/Ju+xu1dntlrbG5efmp2qqOmv7WSnNz67IQKu0rvnVtGP03JM/X9tLean0STOdOWYPpigSnvtlNwN3xqPfMy3e47FigvLshj5fv8gbcqSVBni8dh6uc8HrvEEt/l9VuzWSBR0vykuQ05PE23RLkGY8xzKtIPiGuAsPgxjDXIdW6W2jV5izrnxsgE8w3eJRDoHpcz+ojGf35oHLr+UiuzV1xwuUxu3qju4Xz7MaljYfPXbrQfvJJnkcr0v9Zo0Ltf56TNT5fmfyq+eS0ZPywTUR8PNdSoP+nUuCwnD7nBXgMr+ZzXRGorjmDBeBxthN1U9f3hHdmP8yejPrK6nry/zhfWf3a5PlamFNZT/7f6zkVO6LnGo/6HdlRK4Uw+Cuho0+VX6vGmrFt2g/PuCkr7fuQvF+u28Y4HIdlti2WjW22u9z/3r9xoXXxsbvOtc+3uKdSnoZK14K1sgu99tpafSf559q2Vs3K5GAodzJr9Uinh1+1TjXCtm9wqxqOtMyS/Qzg5lH0OwVdy3tXR/MRp5+FPB5FvxvyOAj2PZDHK8lhRoQrG2FHhJWma0SoglkLkV/9j9PZMPhrKpjVI/5q4EOVuvzfHQZ/l38MfPeEu2s73xSG967u3BMGf8PwYzB9CPlgQH4hAP63hJFPF/9bw8inq5tvC8N/dyRyXxj8TcP/9iD1W+vK//4g+Jtd+T8QBn+3fT0YBn+3ft8RBv+64X8oDP624X84DP5tw//TQfCvdg8E/FhiGNRGqELKbxQNzvbGiVfEQ400TRbDLk/jSIO0aNM0XOpSvWXxfdoMpuWr3yjKJsNAK3RdGQ67IJFlyBtc7DkNl9qcomSY5eJGVbcG7+PSORe8inZ1Xbo4lxP/fE54H5dquuAXM8KbzuMxXabPNjYKdOBs5kgdoz9PvPpuU4tET8liOQzt1ayyWCZZBKqbauDydu3XQSov16/RXyZ4LjvCKlxxwtVDsweXZy/jswSenErBhfWBNBmeny2lRdEXiV/1LY9dSpSvbCe+n015vy/l/VzK+/mU9wsp7/envF+MdLLxt6W30P93dtzwNsZYjgZTgf74faj/oxHS8sGr6aR6LjhgskR6BvIjM9tMezeqSM8i8cPycUV62rcc6RknPsQ/r897veF6cwC+fI6zlB9tcK52tVM6mPcWKs+UyIv7lUeJN47yx2/j5yXIR/hmoYfzfVE/bTXeCnx4yVpW29GNAIl0Wz3jh5/c4zkVUcMXwaNfgPOsnOeKWFS4fmqCKxeuNwfgy3W4xk7tg9rZ65p7WYoGdbBAeWm7ajHP+ON3afYY4YbZr08TzWH2awbyEf5fRj2cn6UyKnuR1RcwX9a1+4J5T8N1F+FSc1wuO4O43kS40q5bSNNnxHUP4VJHf7p0AnG9jXCpHdn2zb4huO4jXK4rFQKtDzuvDygIfrJcH1AgOZzxwquOnvaHv7mlDpbyiH+Vd9hG0aC/sT9IPVdXCkTP6jmi+jL688SrZ73r+huuKw7ixP7GouB1WeSxDqr5yEVBZ1nk8RrcbnC9wxMu1Q52w9eDnviK0wMecb3dI66f9ojrYY+4fJVR2a5x0QmfsvepEz7btk++HvKIy6eu+qxH0y/zdQ32f09+w0Z7V5tZdkDNB6JdIHomv4jK67qKxPieF3m7iQdeX2+3V2rbG9XKSr1ZbzdcPiK+y7JmqPp2k/ViGFk31K5BvlBzGvL4ks4S5HV3/lz++2Shn/9Avlsm+St/COExTixPXR6KtK9h8lHtE/PUGj3PHcTPIXZ44ekuWeYR1Cl06go5Hsu6TrKKIvc8QtppXGnzA7OQj/B/kfzG5a8X+nnPWuYQ8yOMa1qUK06mnyWC/7fJbyynLxX6cQ6LqeC5DTW+NlxzQ3Dx3Ia6UtDVthAXz22osbThWhiCi+c21FV5LnuMuHhuQ11l5+r3ERfPbagr4FxzO8pm48l9cZqGPJ9z83HdfqXQ44PLi/1B/KeumFM+kMG7rlqLk7WFZQFv8bhKPt2dp9Ho5TOdUz7Tu5DP3Sny4X6E5bOX+jPrkI9qS8rOZtW3u0g+GM+yzyEfPAV11PJx6U/e2DklT8TxJpIP+p1zDvmMq/4o+bj0Z9gpB/eQfFT/9FLWn2HyeZtDPnhKIcvnetEfjIdi+fAYRY0B0Ic1mmrtCf1H6xNc4wdcj2P/2Rbk43L8zRTaWX1Xg/8RwMm+q1r/Un2cy0dS61lZ1tlcMdWKjo1vw6wFVCtWZyp+zvIOppSRU5H+R77jevhb0C4YjmmiXA9SHo4zD1EejjMOUx6OG26gPGwnN1Ie+vV2WkSW8Z06zdWerS2iXuN4g/Xa4N8Oev2HJM89sHeryt5hOdjeZZ2XcvkT+4WclD/hGs/gVeajlo+rv8waA+SSJ+Jgfx3HgjMO+eyl/pQc8sl6iYrBqzE84mB/HdusazyD9nnU8pnOKR+X/gw7vY79dTWP81LWn2HyucchH9d45nrRn7c55GP9qmtfnopfTfM3MQ/jV8f9bJkXEgR7fbaMvZ/t9PKLxOsV/pPn7noMwlPeXGew/EZnpyexfTFBMM4nsX0m+WgcTu5VckJbFCeTNdbFjChbieC/UeiV+ZtgZ67ACnox3G874Aopv1dwiHfTnf53qo5Qdw3eaM93Bnm0vAXIQzsZp/3J/ygvxGV8lAj+O6S7qG/2/bKgv4/o9/Et3rHuLgj4BQEf18+vkj3CsvuOQ7tCk/DjO+bttwO2q/ZmY311c31rpdKqrFfX61luY7A9+AXiP4qil1zML/fvDIcwKs4X89NiipHn6yG2OMwpv5UNnrvAxON0rA/L43gKe+ak5nzwdOc/IlsfCVwqloFvnMG5m/2Ux2vAmIe8c5wD6iDHuqp9AWr+aZ+jDK6YC4yP8H6zwWXHr7m9WlmptRrtWmsjjx1j3jk+LE62D6VEZf5WAhTL548L/TCG7/vgL/xJoV8+yJ+di6Zkjv3BN5J/1Hl/8d+Z5P/KrlKjrfak+cPfXFNn3fnDv1oPG7+/uqHsmUf8tcD7A+pqnt0j/ysqTs0f/lpLxfF55L+rnwfCyL+mzhvxyH9FnWnhEX+T10qMRpyMNtphf319Y6tA9KIokvGsRn+eePXse3T3lxwiflg+3OceFrwuizy28YcFncOCzrLI4/js3eD6aY+4HvSI6+2ecKn+bzd83e+Rr1mPfPmSl88y+uRL+QHjoKvKfxiXtu1TJx7yiGtivyb2K2QZfcp+3iNfvvQ+fl7wyJfPtj2O7dG3jR7XvtZnPT7gEdf10A9dD2X0xZdvuzqu/TbPm4yLfvm0qzx3sxu+3uGRL59jq3H1MSftce/KOK799vUwTvOpEzw3/FLUe56fHhc/2pd+FaLBOfJxtdEGi3ESdtZhnGy/Jq9hfpXWDMOcM9loqf0/haif9r5AtAtEL4r0mgCvXyM/xre6AXg369Ob1e16u7K52ahttlaazWaB8Buv/I7n/dVeKLW+EPY8kcamiu/l2N9pyHPdjG08qjMuwsSKNDazyB/pLwt4PuMia13aGRfoY3LcBOqwnafJcQFxsrgEjAtQcSAFwq/OtIh/f3Oqxyt+hzxi+dR5rAWgr97jc4HeI12kd7bT/x2fA8q8cHmLgk9XTAzKIsu5I9hODV88x1ZLnq/xm3Y30e4E4L8bizATBv+qijXxiF/etKvi6UxvLI4Pn40nZQMMr4r/vzPJC3n+/BqchxlIhnVl30bjO1QaBaIXRW7fYT4Kqq9VV5+izk5W/XGR8qY7g+VQ/bHVbwxzAuBYtzhGUJ05o/Ynmb7H+F8BtF6ZPIc8h81sGdtsn7bgsOAfacVpttOTh8l0nPabvDz5f5z3m5xKnheiXkznawEftxVrP8VoEF8812p+9IWLl85tP/PGJ9obl9qt+LaciJJyPvD/qRQmigTHFwGUBP7IQYtxIlz8/lq4ZLya/L/XG8HWk+dr3FFbG5WjFuhiiEbgizCko5a28QPh+JthjlrITuZyPa8EllMttLPnMtCugxrZZqpfw8V5RmtUl5tk3Vi8HEVDB9M7vUQDce1lnaZdZnEFptPLY4d2GvL48AZ0Wq2MsRNQBjhug7zpB/uquzs9HK8BfOZUBHZM1yaOaQ8+zTF9dfL/ODumtyXP6JjWAV9aG8FBvT27NvoFbs8141VtylSTG7ETbQcJPXnp4hPtN12480Ptracunbt44Y0bW+8dcKTZIS5A4dM6ZiyowlGE71W6FpziteT/vXaKb06eJ06xM9UDO2ONwLOj0ilWBsd0+K5OT5Z3dfp5Mpi7AeZugInTTmc4Vad9F+WpE5ljA2yj+/jZ9P6l3KFbx2MGOTbO5eT56gzHnRcef6r9VLt131Ob589t3fXUha2rhvr8+YgSO90F+n+K/k+b6JiO0hN+V4AyjLutPp78v9e22uRkvzdG/uVVAVt9Qxj8Fb7FGcuCdLlPijzyYPhMD9SE3BTldZ1I4q/gn78q81IUtCxZNMkN8O7GFF7DRAtcnUyIU6DbvaTO4CkQfHO3iqKJgDf1/xT9umALDryLIs9wWl0hv1YO679MlqEmyAx/qJUtwx9qEkLpQt9pxMmvajPsB7BN9czrRnfQDTwUiSbziDBKf6fo/2l6X8wAq/QXT6dj/vg7jlLidzyREwn47kA9+S2l4MIbShCeTwcPVYeHBU/G+38Gc9EPfQJbFAA=","debug_symbols":"vP3dju08c6WJ3ouP60Bk/JCsW2lsFNzV7oYBw25UufZJwfe+p4LiGMxcnkymptY++fJ515c5hn4YIYkMkv/7H/6vf/o//9f/89/++V//73/7n//wX/+P//0P/+f/+Od/+Zd//n/+27/823//x3//53/719e//u9/OM7/Sdn+4b+m//L66dfPcv2s18/Wf8px/UzXz3z9lOunXj8vPbn05NKTS08uPb309NLTS08vPb309NLTS08vPb309NKzS88uPbv07NKzS88uPbv07NKzS88uPb/0/NLzS88vPb/0/NLzS88vPb/0/NIrl1659MqlVy69cumVS69ceuXSK5deufTqpVcvvXrp1UuvXnr10quXXn3p5fNnvX62/rMd1890/czXz5eenT9feuX8addPv36W62e9frb4mY/j+pmun/n6KddPvX6ex5dP8AFlQB3QLkjHgDQgD5ABOmAop6GchnIaymko56Gch3Ieynko56Gch3Ieynko56Gch7IMZRnKMpQjduwEHWADfEAZUAe0CyKEAtKAPGAo61DWoaxDWYeyDmUdyjaUbSjbULahbEPZhrINZRvKNpRtKPtQ9qHsQ9mHsg9lH8o+lH0o+1D2oVyGchnKZSiXoVyGchnKZSiXoVyGchnKdSjXoVyHch3KdSjXoVyHch3KdSjXodyGchvKbSifcZfqCTrABviAMqAOaB3kDL8OaUAeIAN0gA3wAWeWyCfUAe2CMwY7pAF5gAzQATbABwzlNJTTUM5D+YzBbCfkATJAB9gAH1AG1AHtgjMGOwxlGcoylGUonzGY2wk+oAyoA9oFZwx2SAPyABmgA4ayDmUdyjqUdSjbULahbEPZhrINZRvKNpRtKNtQtqHsQ9mHsg9lH8o+lH0o+1D2oexD2YdyGcplKJehXIZyGcplKJehXIZyGcplKNehXIdyHcp1KNehXIdyHcp1KNehXIdyG8ptKLeh3IZyG8ptKLeh3IZyG8rtUtbjGJAG5AEyQAfYAB9QBtQBQzkN5TSU01BOQzkN5TSU01BOQzkN5TSU81DOQzkP5TyU81DOQzkP5TyU81DOQ1mGsgxlGcoylGUojxjUEYM6YlDPGJR0QrvgjMEOaUAeIAN0gA3wAWXAUNahbEPZhrINZRvKNpRtKNtQtqFsQ9mGsg9lH8o+lH0o+1D2oexD2YeyD2UfymUol6Fc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MREzUYhoJSK4byJOLMRKRCsR5hJhLhHmEmEuEeYSYS4R5hJhLhHmElG2EmMrMbYSYysxthJjK2EuEeYSYS4RYysxthJnK2EuEeYSYS4R5hJhLhHmEnG2EuYSYS4R5hJhLhHmEmEuEeYSYS4R5hJhLhHmEmEuEeYSYS4R5hJhLhHmEmEuEeYSYS4R5hJhLhHmEmEuEeYSYS4R5hJhLhHmEmEuEeYSYS5R5hJlLlHmEmUuUeYSZS5R5hJlLlHmEmUuUeYSZS5R5hJlLlHmEmUuUeYSZS5R5hJlLlHmEmUuUeYSZS5R5hJlLlHmEmUuUeYSZS5R5hJlLlHmEmUuUeYSZS5R5hJlLlHmEmUuUeYSZS5R5hJlLlHmEmUuUeYSZS5R5hJlLlHmEmUuUeYSZS5R5hJlLlHmEmUuUeYSZS5R5hJlLlHmEmUuUeYSZS5R5hJlLlHmEmUuUeYSZS5R5hJlLlHmEmUuUeYSZS5R5hJlLlHmEmUuUeYSZS5R5hJlLlHmEmUuUeYSZS5R5hJlLlHmEmUuUeYSZS5R5hJlLlHmEmUuMeYSYy4x5hJjLjHmEmMuMeYSYy4x5hJjLjHmEmMuMeYSYy4x5hJjLjHmEmMuMeYSYy4x5hJjLjHmEmMuMeYSYy4x5hJjLjHmEmMuMeYSYy4x5hJjLjHmEmMuMeYSYy4x5hJjLjHmkv9fWeey29xyncF3yVgD9n2tvEoQBLkYgQEjMZx4EAR+93B/a7e+AjI5qKNfUu1ukqVuqkUut2S5JcstWW7JckuWW7LckuWWLLdkuSXLLVluyXJLlluy3JLlliy3ZLklyy1ZbslyS5ZbstyS5ZYst2S5JcstWW7JckuWW7LckuWWLLdkuSXLLVluyXJLlluy3JLlliy3ZLklyy1ZbslyS5ZbstyS5ZYst2S5JcstWW7JckuWW7LckuWWLLdkuSXLLdluyXZLtluy3ZLtlmy3ZLsl2y3Zbsl2S7Zbst2S7ZZst2S7Jdst2W7Jdku2W7Ldku2WbLdkuyXbLdluyXZLtluy3ZLtlmy3ZLsl2y3Zbsl2S7Zbst2S7ZZst2S7Jdst2W7Jdku2W7Ldku2WbLdkuyXbLdluyXZLtluy3ZLtlmy3ZLsl2y3Zbsl2S7Zbst2S7ZZst2S7Jdst2W7Jdku2W7Ldku2WbLdkuyXbLdluyXZLtluy3ZLtlmy3ZLsl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","names":["initiate_blocking"],"brillig_names":["discover_new_messages","get_notes_internal","get_collapse_hints","field_less_than","decompose_hint","lte_hint","get_public_keys_and_partial_address","get_key_validation_request","notify_nullified_note_oracle_wrapper","storage_read","get_public_data_witness","random","get_note_internal","notify_created_note_oracle_wrapper","store_in_execution_cache_oracle_wrapper","notify_enqueued_public_function_call_wrapper","directive_invert","directive_integer_quotient","directive_to_radix"]},{"name":"is_user_blocked","hash":"13605072054779945891","is_unconstrained":true,"custom_attributes":["utility"],"abi":{"parameters":[{"name":"user","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17595253152434889169":{"error_kind":"string","string":"offset too large"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"vb3RjiTBbWD7L3r2QwYjgmToVxYLQ+vVLgQI8kJrX+DC8L/fSmaSp2bGHVNd3bov1pE1zZOVlWRlRjAj/uMP//PP/+Pf//c//+Vv/+tf/+8f/vjf/uMP/+Pvf/nrX//yv//5r//6L3/6t7/8698e/9//+MNx/p8m8oc/9n96/Gf/wx/n+Z/jD3+08z/nH/64zv/UP/yxtRMswRPWDf1IaAmS0BNGwkzIyD0j94zcM/LIyCMjj4w8MvLIyCMjj4w8MvLIyCMjz4w8M/LMyDMjz4w8M/LMyDMjz4w8M7JmZM3ImpE1I2tG1oysGVkzsmZkzciWkS0jW0a2jGwZ2TKyZWTLyJaRLSN7RvaM7BnZM7JnZM/InpE9I/sZWU5YN6wjoSVIQk84I58X3zojn1ff0gRL8IR1gRxHQkuQhJ4wEmbCI7LICZbgCeuGdiS0BEnoCSNhJmTklpFbRm4ZWTKyZGTJyJKRJSNLRpaMLBlZMrJk5J6Re0buGbln5DMHZZ4wEzTBEjxh3XDm4AUtQRJ6QkYeGXlk5JGRR0YeGXlm5JmRZ0aeGXlm5JmRZ0aeGXlm5JmRNSNrRtaMrBlZM7JmZM3ImpE1I2tGtoxsGdkysmVky8iWkS0jW0a2jGwZ2TOyZ2TPyJ6RPSN7RvaM7BnZM7Jn5JWRV0ZeGXll5DMHxU+YCZpgCZ6wLuhnDl7QEiShJ4yEmaAJlvCI3OWEdcOZgxe0BEnoCSNhJmiCJWTklpElI0tGjt/AeUJPGAkzQRMswRPWDWcOXtASMnLPyD0j94x85mBfJ1iCJ6wbzhy8oCVIQk8YCTMhI4+MPDLyyMgzI8+MPDPyzMgzI8+MPDPyzMgzI8+MrBlZM7JmZM3ImpE1I2tG1oysGVkzsmVky8iWkS0jW0a2jGwZ2TKyZWTLyJ6RPSN7RvaM7BnZM7JnZM/InpE9I6+MvDLyysgrI6+MvDLyysgrI6+MvO7I4zgSWoIk9ISRMBM0wRI8ISO3jNwycsvILSO3jNwycsvILSO3jNwysmRkyciSkSUjS0aWjCwZWTKyZGTJyD0j94zcM3LPyD0j94ycOTgyB0fm4DhzcDzubcaZgxe0BEnoCSNhJmiCJXhCRp4ZeWbkmZFnRp4ZeWbkmZFnRp4ZeWZkzciakTUja0bWjKwZWTOyZmTNyJqRLSNbRraMbBnZMrJlZMvIlpEtI1tG9ozsGdkzsmdkz8iekT0je0b2jOwZeWXklZFXRl4ZeWXklZFXRl4ZeWXkdUeex5HQEiShJ4yEmaAJluAJGbll5JaRW0ZuGbll5JaRW0ZuGbll5JaRJSNLRpaMLBlZMrJkZMnIkpElI0tG7hm5Z+SekXtG7hm5Z+SekXtG7hk5c3BmDs7MwZk5ODMHZ+bgzBycmYMzc3BmDs7MwZk5ODMHZ+bgzBycmYMzc3BmDs7MwZk5ODMHZ+bgzBycmYMzc3BmDs7MwRk5OE+wBE9YN0QOBrQESegJI2EmZGTLyJaRLSOfOTjlhJYgCT1hJMwETbAET1g3rIy8MvLKyCsjr4y8MvLKyCsjr4y87sh6HAkt4Yw8TugJI2EmaIIleMK64czBC1pCRm4ZuWXklpHPHJzzBEvwhHXDmYMXtARJ6AkjYSZkZMnIkpElI585OP2EliAJj8h6nDASZoImWIInrBvOHLygJUhCRh4ZeWTkkZHPHNR+giesG84cvKAlSEJPGAkzQRMy8szIMyNrRj5zUM9v58zBC3rCSJgJmmAJnrBuOHPwgoxsGdkysmVky8iWkS0jW0a2jOwZ2TOyZ2TPyJ6RPSN7RvaM7BnZM/LKyCsjr4y8MvLKyCsjr4y8MvLKyOuObMeR0BIkoSeMhJmgCZbgCRm5ZeSWkVtGbhm5ZeSWkVtGbhm5ZeSWkSUjS0aWjCwZWTKyZGTJyJKRJSNLRu4ZuWfknpF7Ru4ZuWfknpF7Ru4ZuWfkkZFHRh4ZeWTkkZFHRh4ZeWTkkZFHRp4ZeWbkmZFnRp4ZOXJQT9AES/CEdUPkYEBLkISeMBIysmZkzciakTUjW0a2jGwZ2TKyZWTLyJaRLSNbRraM7BnZM7JnZM/InpE9I3tG9ozsGdkz8srIKyOvjLwy8srIKyOvjLwy8srI647sx5HQEiShJ4yEmaAJluAJGbll5JaRW0ZuGbll5JaRW0ZuGbll5JaRJSNLRpaMLBlZMrJkZMnIkpElI0tG7hm5Z+SekXtG7hm5Z+SekXtG7hm5Z+SRkUdGHhl5ZOSRkUdGHhl5ZOSRkUdGnhl5ZuSZkWdGnhk5c9AzBz1z0DMHPXPQMwc9c9AzBz1z0DMHPXPQMwc9c9AzBz1z0DMHPXPQMwc9c9AzBz1z0DMHPXPQMwc9c9AzBz1z0DMHPXPQMwc9c9AzBz1z0DMHPXPQMwc9c9AzBz1z0DMHPXPQMwc9c9AzBz1zcGUOrszBlTm4MgdX5uDKHFyZgytzcGUOrszBlTm4MgdX5uDKHFyZgytzcGUOrszBlTm4MgdX5OA6oSVIQk8YCTNBEyzBE9YNPSP3jNwzcs/IZw7accJM0ARL8IR1w5mDF7QESegJGXlk5JGRR0YeGXlk5JmRZ0aeGXlm5JmRZ0aeGXlm5JmRZ0bWjKwZWTOyZmTNyJqRNSNrRtaMrBnZMrJlZMvIlpEtI1tGtoxsGdkysmVkz8iekT0je0b2jOwZ2TOyZ2TPyJ6RV0ZeGXll5DMHbZwwEmaCJliCJ6wL2nEm4U2tSIp60Sg641uQFlmRF62kMx1vakVS1ItGUTlaOVo5WjlaOaQcUg4ph5RDyiHlkHJIOaQcUo5ejl6OXo5ejl6OXo5ejl6OXo5ejlGOUY5RjlGOUY5RjlGOUY5RjlGOWY5ZjlmOWY5ZjlmOWY5ZjlmOWQ4th5ZDy6Hl0HJoObQcWg4th5bDymHlsHJYOawcVg4rh5XDymHl8HJ4ObwcXg4vh5fDy+Hl8HJ4OVY5VjlWOVY5VjlWOVY5VjlWOVY62nEUtSIp6kWjaBZpkRV5UTkqz1vleas8b5XnrfK8VZ63yvNWed4qz1vleas8b5XnrfK8VZ63yvNWed4qz1vleas8b5XnrfK8VZ63yvNWed4qz1vleas8b5XnrfK8VZ63yvNWed4qz1vleas8b5XnrfK8VZ63yvNWed4qz1vleas8b5XnrfK8VZ63yvNWed4qz1vleas8b5XnrfK8VZ63yvNWed4qz1vleas8b5XnrfK8VZ63yvNWed4qz1vleas8b5XnrfK8VZ63yvNWed4qz1vleas8b5XnrfK8VZ63yvNWed4qz1vleas8b5XnrfK8VZ63yvNWed4qz1vluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5H15AfJ515flMrkqJeNIpmkRZZkReVw8vh5fBynHnuEjSKZpEWWZEXraQzz29qRVJUjlWOVY5VjlWOVY6VjmgquqkVSVEvGkWzSIusyIvK0crRytHK0crRytHK0crRytHK0coh5ZBySDmkHFIOKYeUQ8oh5ZBy9HL0cvRy9HL0cvRy9HL0cvRy9HKMcoxyjHKMcoxyjHKMcoxyjHKMcsxyzHLMcsxyzHLMcsxyzHLMcsxyaDm0HFoOLYeWQ8uh5dByaDm0HFYOK4eVw8oRed6DZpEWWZEXraTI84takRT1onJ4ObwcXg4vh5djlWOVY5VjlWOVY5VjlWOVY5VjpSMal25qRVLUi0bRLNIiK/KicrRytHK0crRytHK0crRytHK0crRySDmkHFIOKYeUQ8oh5ZBySDmkHL0cvRy9HL0cvRy9HL0cvRy9HL0coxyjHKMcoxyjHKMcoxyjHKMckefnL2K0Ot3Uih6OdQT1olE0i7TIirxoJZ15flMrKoeWQ8uh5dByaDm0HFoOK4eVw8ph5bByWDmsHFYOK4eVw8vh5fByeDm8HF4OL4eXw8vh5VjlWOVY5VjlWOVY5VjlWOVY5VjpiOaom1qRFPWiUTSLtMiKvKgcrRytHK0crRytHK0crRytHK0crRxSDimHlEPKIeWQckg5pBxSDilHL0cvRy9HL0cvRy9HL0cvRy9HL8coxyjHKMcoxyjHKMcoxyjHKMcoxyzHLEfl+aw8n5Xns/J8Vp7PyvNZeT4rz2fl+aw8n5Xns/J8Vp7PyvNZeT4rz2fl+aw8n5Xns/J8Vp7PyvNZeT4rz2fl+aw8n5Xns/J8Vp7PyvNZeT4rz2fl+aw8n5Xns/J8Vp7PyvNZeT4rz2fl+aw8n5Xns/J8Vp7PyvNZeT4rz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+t8twqz63y3CrPrfLcKs+t8twqz63y3CrPrfLcKs+t8twqz63y3CrPrfLcKs+t8twqz63y3CrPrfLcKs+t8twqz63y3CrPrfLcKs+t8twqz63y3CrPrfLcKs+t8twqz63y3CrPrfLcKs+t8twqz63yPDrCVg/SIivyopUUeX5RK5KiXjSKyjHLMcsxyxF5fs6+RoPYTa1IinrRKJpFWmRFXlQOK4eVw8ph5bByWDmsHFYOK4eVw8vh5fByeDm8HF4OL4eXw8vh5VjlWOVY5VjlWOVY5VjlWOVY5VjpiEaym1qRFPWiUTSLtMiKvKgcrRytHK0crRytHK0crRytHK0crRyR5zOoFUlRLxpFs0iLrMiLVlIvRy9HL0cvRy9HL0cvRy9HL0cvxyjHKMcoxyjHKMcoxyjHKMcoxyjHLMcsxyzHLMcsxyzHLMcsxyzHLIeWQ8uh5dByaDm0HFoOLYeWQ8th5bB0REvP9Qp5fDYNOh0eNIu0yIq8aCXF57ioFUlRLyqHlkPLoeXQcmg5rBxWDiuHlcPKYeWwclg5rBxWDi+Hl8PL4eXwcng5vBxeDi+Hl2OVY5VjlWOVY5VjlWOVY5VjlWPdDol+n5takRT1olE0i7TodKwgL1pJUa8uakVS1ItG0cPRjiNQT+yBBjq4Cs+ildhAATs4wAliE2yCTbDFCh7HCGyggB0c4ATDpoEGOrgKY1WPGxsoYAcHOEFsA0Us7nHYiddiHvHZruU8LhzgBBU00MFVeC3ucWEDsSk2xabYFJtiU2yKzbAZNsNm2AzbtfRHfC3X4h8XGujgKrwWAbmwgQJ2cIDYHJtjc2yObWFb2Ba2hW1hW9hikZBz3RCJBqFEB1di9AglNlDADg5wgmHzQAMdXIVnlWixrEK0Cz0mggMF7OAAJ6jgaest0MFVGKXixgYKeNrOlQ4keocSJ6iggQ6uwigVNzZQQGxRKnqchygVNyoYtviYUSpuXIVRKm5soIAdHOAEFcQWVaNb4CqMO4QbGyhgBwc4wbDFRRC15EYHV2HUkhsbKGDYVuAAJ6iggQ6uwqgl4whsoICnbcT3FrXkxlmHY3w247MZn834bFFLRg+Muh5nJwrIGIEDnKCCBp6KEd9bFJALo4Dc2EABOzjACYYtjiwKyI0Ohu08fddqQ/MIPG3nC6ZyrTh0YwcHOEEFz7jna5oSDUeJrTBS+nxZU6JHKFHADg5wggoa6OAq7Ng6to6tY+vYOraOrWPr2Dq2gW1gG9gGtoFtYBvYBraBbWCb2Ca2iW1im9gmtoltYpvYJjbFptgUm2JTbIpNsSk2xabYDJthM2yGzbAZNsNm2AybYXNsji2yUCMvIgtvFPA8Bo3LPrLwxgkqaKCDKzFagxIbKGAHBxi2EaiggQ6uwsjNGxsoYAcHiC1+xs8XjyV6hRIdXIWR8zc2MGwW2MEBTlBBAx1chZHzNzYQW8fWsXVskd3qgaswsvvGBgrYwQFOUEEDsQ1sE9vENrFNbBPbxDaxTWwT28Sm2BSbYlNsik2xKTbFptgUm2EzbIbNsBk2w2bYDJthM2yOzbE5Nsfm2BybY3Nsjs2xLWwL28K2sC1sC9vCtrAtbKts4zjABgrYwQFOUEEDHcTWsDVsDVvD1rA1bA1bw9awNWyCTbAJNsEm2ASbYBNsgk2wdWwdW8fWsXVsHVvH1rFRSwa1ZFBLBrVkUEsGtWRQSwa1ZFBLBrVkUEvGVUvOO7xx1ZILGyhgBwcYihlooIOr8CogFzZQwA4OcILYFJtiU2yGzbAZNsNm2AybYTNshs2wOTbH5tgcm2NzbI7NsTk2x7awLWwL28K2sC1sC9vCtrCtss3jABsoYAcHOEEFDXQQW8PWsDVsDVvD1rA1bA1bw9awCTbBJtgEm2ATbIJNsAk2wdaxdWwdW8fWsXVsHVvH1rF1bAPbwDawDWwD28A2sA1sA9vANrFNbBPbxDaxTWzUkkktmdSSaH56PLOfGLXkxgaeNuuBHRzgBBU08LRZ2KKWXBi15MawjUABOxg2C5yggmFbgQ6etvNdBYmOqMQGnjaPjxm15MYBnjaPY4hacqOBDq7CqCU3Rtz4mFEfXAMjQhx61IcbV2J0PiXG8a5AATs4wAmGrQUa6OBpW+fHjB6oxAaethX/NurDjQOcoIIGnrZzUl6iGerGqA83NlDADg5wggqGbQQ6uAqjPtzYQAE7OMAJKogt6sPZ/CDRIHVj1IcbGyhgBwc4wbDNQAMdXIVRH25soIAdHOAEsU1sE9vEptgUm2JTbIpNsSk2xabYFJthM2yGzbAZNsNm2AybYTNsjs2xOTbH5tgcm2NzbI7NsS1sC9vCtrAtbAvbwrawLWyrbNFdldhAATs4wAkqaKCD2Bq2hq1ha9gatoatYWvYGraGTbAJNsEm2ASbYBNsgk2wCbaOrWPr2Dq2jq1j69g6to6tYxvYBraBbWAb2AY2aolRS4xaYtQSo5YYtcSoJUYtMWqJUUuMWmLUEqOWGLXEqCVGLTFqiVFLjFpi1BKjlthVSzQwbCtwFV615MIGCtjBAU5QQQOxGTbH5tgcm2OL5ddjLj9athIVNNDBVRgLrx8SGBFaoIIRYQQ6uBKjKyuxgQJ2cIBhm4EKGhg2DVyFsRXCjQ0MmwVGXA9U0EAHz7jtPA/RkyXnlhESTVly7gMh0ZUlMbkbbVkSM6/Rl/WYygqcoIIGnrbY6CGas26MzRFubGDYVuCpkDic2BshtkuIxqzH1EXgqbjX4j8VsQx+9GbdGLsk3NhAATs4wLDFMcSOCTd6XiXRmnVjbJdwYwMF7OAAJ6iggdgmtthCIeaPo00rUcDT1q9/O8AJKmigg6swtlW4sYECYjNsscFCTCXHUmKJYYvLKLZZuDFs8W3GxgoxERxLiCUOcIIRNy6YyO4bHVyF15NE/FncKdwoYAcHOEEFDfTEWFBsXRQfwgM7OMAJKhgfYgU6uAoj5W9soIAdHOBpi5nkWG0s0cDTFpPKseaYxOxwrDomMc0b644lCtjBAU4w8jFoJdVuKKu2Q1m1H8qqDVFiSTCJud5YFCzRQAdXYWTijQ0UsIMDxDaxTWwT28Sm2BSbYlNsik2xKTbFptgUm2EzbIbNsBk2w2bYDJthM2yOzbE5Nsfm2BybY3Nsjs2xLWwL28K2sC1sC9vCtrAtbCttPfoRExsoYAcHOEEFDXQQW8PWsDVsDVvD1rA1bA1bw9awCTbBJtgEm2ATbIJNsAk2wdaxdWwdW8fWsXVsHVvH1rF1bAPbwDawDWwD28A2sA1sA9vANrFNbBPbxDaxTWwT28Q2sU1sik2xKTbFptgUm2JTbIpNsRk2w2bYDJthM2yGzbAZNsPm2BybY3Nsjs2xOTbH5tgc28K2sC1sC9vCtrAtbAvbwkYtadSSRi1p1JJGLWnUkkYtadSSRi1p1JJGLWnUkkYtadSSRi1p1JJGLWnUkkYtadSSRi1p1JJGLWnUkkYtadSSRi1p1JJGLWnUkkYtadSSRi1p1JJGLWnUkkYtadSSRi1p1JJGLWnUkkYtadSSRi1p1JJGLWnUkkYtadSSRi1p1JJGLWnUkkYtadSSRi1p1JJGLWnUkkYtadSSRi1p1JJGLWnUkkYtadSSRi1p1JJGLWnUkkYtadSSRi1p1JJGLWnUkkYtadSSRi1p1JJGLWnUkkYtadSSRi1p1JJGLWnUkkYtadSSRi1p1JJGLWnUkkYtadSSRi1p1JJGLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1JJOLenUkk4t6VdKr8AJKngqzsbqHn2RiaswUvrGBgp4fqAZNIpm0ak62657NEUmOhiqcWLk842hio8Q+XxjBwc4QQUNdHAVXhurXohtYBvYBrZri1UPVNBAB1fhtdnqhaftIinqRaNoFmlRRIxvLrJT4yuI7NQWOMAJKnge6dnc2qPxMXEVRnbe2MCwxXcT2XnjAMOmgQoaGLb4FJGdF0Z2anygyM4bBez3NqHXzo8XzSItsiJPigy0OEWRaxZnIHLNrn+goIEOnkd69lX0aGNMbKCAHRz37qLXjo8XadF5qNe/86KVFNs+XtSKpCgkESZy+8YJemHkq2mggOcJ7UGjaBbFGfFAAx08z8jZEdKjHTExrukWKGAH47KWwLiuwxb56vHBIl/PJo4e7YiJqzDy9cYGCtjBAYYtDj3y9Wz46NGOKCsOPTJzxUFGZq44yEjNGzs4wAkqaIXxQ7riY0aq3tjBAU5QQSuMnFtxoiLnbpyggvFncQVEzq342nODx147PPba4rHXHo+9Nnnstctjr20ee+3z2Gujx147Pfba6rHXXo+9Nnvstdtjr+0ee+332GvDx147Pvba8rHXno+9Nn3stetjr20fe+372KPl7/EDGmi1264Xrdp49yhqRVLUi0bRLNKicrRytHJIOaQcUg4ph5RDyiHlkHJIOaQcvRyRa+vCCSp4BjonJnt07vVzcrRH514/ZyN79Oj1c7KxR99dPycQe/Td9Rb/NjYwvjC2ML7x/HDnS7A9+u4SOzjACSpooINhi681tjW+sYFhi88WWxlLHE5sZnxj/Dpc/9bBVRibGt/Y6s9iY+MbOzhAbIYttji+0Qtjd+Mb27XTY4+uupt60SiaRVoUwSXQwVUYOxvfGIcX5zD2Mpb4zmM34xsdXInRUJfYQAE7GCdjBk5QwbBpoIOr8Npr3AMbKGAHBzhBBQ10cBUKNsEm2ASbYBNsgi0y8pw07tFQl7gKY/fjfgTGr20LtMLYWjzuVqIHrsevcPTAJXYwIsRZj03GbzwPp8fhRP6NsEWeRCWM/rNEATt4xh1xDJE9NypooIOrMLLnxogbxxt5cuMEI24ceuTJjQ6uwkiZGxsoYC+MLb4jRaJPLFHADg5wgnFkcU1Gitzo4EqMPrHEBobNAjs4wAmGzQMj7nnBREdYjwer6AhLFLCDA5ygguenmC3QwVUYyRDPYdERlihg2GbgACeooIEOrsL4hboxbHHOIkXiySi6vHo83USXV+IqjGy58TyyePyJfq7ECSpooIOrMH7DbjyPLB6Vop8rsYMDnGAo4pzFD9eFkXrxABUtWD0elaLZqmuch0iceD6KZqtEuTax7dFrddMomkVaZEVetJJiP+GLQhLXX2TRjR0c4AQVNNDBVRgZFw930WPV4zEueqyurz72EL7Ii9ZN0V91Uys6I8ZjXHRXJQ5wggpaYWRVPP3FolY9Hu5iVavE84f2Ii2yIi9aSbF/90XnOY3nvuigSuzgACeo4Hn24pktuqJ6PKjFslWRF9EfddMsOk+oBVmRF62kM2VuakUhiTCRRjcO0AojNc5XBHq0PSUKeB5mHPCZGTfNIi2yIi86P3g8QUbDU2IDBezgACeooIEOYjNskXfxZBoNT4kdDFt8UfEzdmPY4juLnzGPDxQ/Y/G0GQ1PN8bP2I1x/x/iSMAb4wkgrs9IwHiCvHZTvP53LbIiL1pJsaXiRRGxB8YDRBx0/KzF82A0NSWuxNg5scdTU7Q6JQrYwQFG3PMDrutxagWed7nxbBH9S4kdHOAEFTTQwVUYWXi2bvboX0oUMGwSOMAJKhi2HujgKoydFC9qRVL0UEXZj90Ub5pFWmRFXhSS8zuKTRUTGyjgBOMwZ+AqnBEhvs/ZQAH7telkX7mPaV+5kWlfuZNpX7mVaV+5l2lfuZlpX7mbaV+5nWlfuZ9pX1oOLYeWQ8uh5dByaDmsHFYOK4eVw8ph5bD4ZuP6NAMdjFMWl2qMidzYwBhNiOvoGha5MMYs4vxfAyMXKmiggzFwEV/QNTpyYQxdxPFe4yNxZNcASeTTNUJy4QTDFgd5DZJc6OC6dvYc0Qd1UyuSol40iuKH7zixxa9cCzyP9HysHNHWlNjBAcbP6QhU0EAHV2FszRTe3LZhRKPSuv7XdS0lOI5c7nEcudzjiHakx5BlYAcHOEEFDXRwFUY63thAbAPbwDawjbB5oIEOrsJI3Rsb2PMcxIKJF82iiB/f3DTQwVWoB9jA89P0+JbPtE0c4Plpeny1Z+Ymen5JsQNLUOzAclG7dpgY0XF0Uy+K4Nc/nKCCBjq4CiNle5yBSNkbBTzPWlxNuaTzOHJJ53Hkks7jyCWdx5FLOo8jl3QeRy7pPI5c0nkcuaTzOFY5VjlWOVY5VjlWOXJJ59FySefRcknn0XJJ59FySefRcknnEZ1F45xNGNFZlGhgnDMNXIWRzjc2UMAODnCCChqIrWGLH+ezNXtEZ1GigB0c4AQVNNDBsJ1JEp1FiQ08T2MP6kWjaBZpkSVF6p9DqiP6hMaIUx9Jfg6cjOgTSlTQwPNIxxVsFUaS39hAAcMW3+Mc4AQVNNDBVRgpf2PY4sRFyo84RZHyM443Uv7GCSpooIOr8Mz/xAYKiM2wGTbDZtgMm2FzbI7NsTk2x+bYHJtjc2yObWFb2Ba2hW1hW9gWtoVtYVtliz6hxAYK2MEBTlBBAx3E1rA1bA1bw9awNWwNW8PWsDVsgk2wCbaoDOcQ1Ig+ocSw9UAFDXQwbGcdij6hxAYK2MEBTlDBsFmgF0apOB/MRzQHJQrYwVCswAkqaKBn3ZGrgAReBeTCBgrYwQFOUMF133RJbo0+JPdGH9dOjCOoF42iM6Je/1BBAx1chVEkbjxN8ZXHvqsX9aLz4PXCCSpo12aPQ3Lr1SG59eqQ3Hp1SG69OiS3Xh2SW68Oya1Xh+TWq0Ny69UhXg4vh5djlWOVY5VjlWOVY5VjlWOVY5UjasH5eDiizyexgecXfj57jlh4LXGAE1TQQAdXYdSCG8M2AgXs4MN2jqOMa4fGi7TIirxoJUW+n+OgIxqGxvnYNqJjaJxDiSM6hhIdXIWR2fHQEh1DiQJ2cICnLa7v6BhKNNCvnQJH7cM4ah/GUfswjtqHcdQ+jKP2YRy1D+OofRhH7cM4ah/GUfswjtqHcdQ+jKP2YRy1D+OofRhH7cM4ah/GESupjUigWEltRK5G69CNcUtwYwMF7OAAJ6iggdgUm2EzbHFLYPHlxy3BjQOcoIJWGD/+kSr96tsLmkXxR/F9xy/7jQ6uwvhlv7GBAnbwPMTrAo5f9hsVPG0epz9+2W9cidFJlHja4luLnqERj07RNJSooIERdwZG3DNzonNoxONVtA6Ns9VlRO/QiKeGaB4aK8TxG37jBBU8bSuOLH7Db1yF8Rt+42mLh9HoLhorDid+uFccTqT3OT44osFoHnE4Z3rPIz7Qmd6Jq/BM78QGCtjBc/D5iGOIQfIbLa+R6CpKXIUxPH7E8cb4+I0ChuL6twOcoIIGOrgK5wE2UEBsE1sMp7c4ZzGefmPY4juOEfUbwxan+kzo2eLbPBM6cYATjLjxbZ4JnejgKrx+vuPsRELfKGAHBzhBBa0wpqlafJvn73WigB2MTxHfsU9QQQNjKCQ+ZuT8hesAGyhgBwc4wTg7kYUxgRUYbUmJDRSwg/EpNHCCChrohS3iWmBE8MCIsAIVNPCMEON60Zp045nHMz5QNCclCngeb4zrRX9S4gQVNNDBVRgpfXakjFiBLFHADg5wgjGsG6cvZrmu8xB5fCNnJ/I4fg5irbHEAU4wPkWc38jjGx2MTxGnOvL4xgaGLU515PGNAwxbHHrkcY8vIPI4xtmi52nG4Fr0PN14/lwnnnFj/CtWFUucoIIRNz6bHXWVWAMF7OAE/Z7WGbE82I0xm3Vjuyd7xrxmsy7s4AAnqKCBDq7CMyFnjGnF8mCJA5xgfPj4smKW+UYHV+LV4xS/WVeP040CdnCAE1TQQC+MBo5zFnVc3Uw3xqewwAFOUMH4FNefObgKI3lvbKCA/Z6oHVc3040TVNBAB1dhP8AGChif4kIFDXQw2hPODIgmqMQGCtjvWfFxNUHdOEEFDXRwFV4z2hdGe0ULHOAEFYwWCwl0cBVGmt7YQAE7OMCw9UAFDXQwbHFxRUrf2EABs9FhXI1YN05QQQMdXIWR8zc2MJpF4jqLH+EYZYzFvRINjE8RZ93jU8RFsA6wgQJ2cIATVDA6S84Lxq42khYYzS0rMJpQJNBAB1dhiwg9sIECdnCAE1TQ6hiiEevGVRiNWDc2UEA+ReTxjROMTzEC41OcZz1arhIbKGB8Cg0c4ATjU1iggQ6uwsjjGxsoYNg8cIATDFt8oPgRvtHBVRg/wjc2UMDoTInr4WpNuXCC0ZwSV8nVnXKhg6swsvvGBgoYtrh2IrtvnGDY4huK7I6b3liEa8ZoRvSFzUin6AtLbKCApy0GK67OsHjcv1rDIjev3rAbDXQwWoTicOLGOx6qo0FsRnGMBrHEDg4wPltc4JHzNxroYPa8jdg8MbGBAnZwgBNU0BKv1rF4qrt6x24UsIPxKTxwggoa6OAqjPpwYwMFjLgrUEEDz7gxZBBtZTfGL/qNDRQwWsBaYESQwFUYOX9jAwWMluILBzhBBQ10cBVWA/Pwq4H5wuhY64ETVNDA+BTnhXj1ksW4xtVMduMEI4IGGuiFkZsxBhK9YzPGQKJ3bMYYSPSO3echcvNGBQ3k/CrnN7IwBkmiSyxxgBOMXvH4mNdLARc6uAqv9wMubKCAHRyg3S98jWtZrBtXYfzGxoxmLIuVGJ/i+gcdHGB8ijip8Rt7o4Hn2YnngOgguzA6yBIbKODZcXI2Z43oIEucoIIGOrgK2wFGXAnU+223Eb1iGiNE0SuW2MCzFSYGi6JXLDGObAZOUME4slCIg6swesVubKCAHQybBU5QQQMdXIXxctz1iUfEjVM9BjhBBSPuCnRwFc4DbPcblONaauvGDg5wggoa6IXRPBYjWlf32I0dHOD5Kdr1Zwoa6OC6348d16JaNzZQwA4OcIJaGBND/UIDHVyFMTl0YwMF7OAAJ4htYYtJohgyiEavwBmdXokNFLCDEbcHGujgKmwH2MCIa4EdHOAEw+aBBnqhSMWVDg5wghy6cOjiZZNV2A+wgVLi3sEBxmUkgavwTLLEBgrYwQFOUEEDsUXqtfhAkXo3NlDADg5wggoa6CA2xabYrnQagfFv54nRlHljAwXsYByZBsYxxBdgDq5CP8AGCtjBiBtfVrRJ36iggQ6uwuiVvjFsK1DADg5wggoa6InR16XnKOuMxq5EATs4wAkqaKCDq7Bha9ha2FpgBwc4QQUNdLC+rGjuSmyggBFMAiNYD3RwFcaP5Y1x6CNQwA4OcIIKGujgKow8vhHbwDawDWwD28AWeXyO6c7o9roxEjIqbbRtJSpo4PlnPU5UJOSFkZA3NjC6zeNExS/kjQMMWxxZ/ELeaGDY4iAjpS+MlL6xgQJ2cIARVwMdjLhxEURK39gKoxvy+kDRDnnjSozepxUfKHqfVhx69D4ldnCA0c43AxU00AtjA+k43uhnWnFk0c+UqKDzb+Mgz6oRTUyJDRSwgwOcYPQ2H4EGOnjazuHHGU1MiQ0M2wrs4AAnyAe6ehwvdHAVxmb3NzZQwA5y+gan7/wls+tTnL9kiQ0UsIMDnKCCBjqITbEpNsWm2BSbYlNsik2xadxgxEm1A2yggB0c4AQVNNBBbI7NsTk2x+bYHJtjc2yOzbEtbAvbwrawLWwL28K2sC1sq2z9OMAGCtjBAU5QQQMdxNawNWwNW8PWsDVsDVvD1rA1bIJNsAk2wSbYBJtgE2yCTbB1bB1bx9axdWwdW8fWsXVsHdvANrANbAPbwDawDWwD28A2sE1sE9vENrFNbBPbxDaxTWwTm2JTbIpNsSk2xabYFJtio5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5YMasmglgxqyaCWDGrJoJYMasmglgxqyaCWDGrJoJYMasmglgxqyaCWDGrJoJYMasmglgxqyaCWDGrJoJYMasmglgxqyaCWDGrJoJYMasmglgxqyaCWDGrJoJYMasmglgxqyaCWDGrJoJYMasmglgxqyaCWDGrJoJYMasmglgxqyaCWDGrJoJYMasmglozrvqQFxp3CCHRwFV73JRc2UMAODnCCCmJTbIrNsBk2w2bYDFvUknPCdkaPVqKBDq7CqCU3hs0CBezgaTtnaWd0btmM0xe15EYDHVyFUUtubKCAHRwgtoVtYVvYVtminyuxgQJ2cIATVNBAB7E1bA1bw9awNWwNW8PWsDVsDZtgE2yCTbAJNsEm2ASbYBNsHVvH1rF1bB1bx9axdWwdW8c2sA1sA9vANrANbAPbwDawDWwT28Q2sU1sE9vENrFNbBPbxKbYFJtiU2yKTbEpNsWm2BSbYTNshs2wGTbDZtgMm2EzbI7NsTk2x+bYqCWTWjKpJZNaMqklk1oyqSWTWjKpJZNaMqklk1oyqSWTWjKpJUotUWqJUkuUWqLUEqWWKLVEqSVKLVFqiVJLlFqi1BKllii1RKklSi1RaolSS5RaotQSpZYotUSpJUotUWqJUkuUWqLUEqWWKLVEqSVKLVFqiVJLlFqi1BKllii1RKklSi1RaolSS5RaotQSpZYotUSpJUotUWqJUkuUWqLUEqWWKLVEqSVKLVFqiVJLlFqi1BKllii1RKklSi1RaolSS5RaotQSpZYotUSpJUotUWqJUkuUWqLUEqWWKLVEqSVKLVFqiVJLlFqi1BKlluhVS3qggQ6uwquWXNhAAcNmgQOcYNiOwNOmFzq4EqPFLbGBAnZwgHGHtwIVNNDBVRi15MYGCtjBAWJr2Bq2hq1hE2yCTbAJNsEm2ASbYBNsgq1j69g6to6tY+vYOraOrWPr2Aa2gW1gG9gGtoFtYBvYBraBbWKb2Ca2iW1im9gmtoltYpvYFJtiU2yKTbEpNsWm2BSbYjNshs2wGTbDZtgMm2EzbIbNsTk2x+bYHJtjc2yOzbE5toVtYVvYFraFbWFb2Ba2hW2VLVrnEhsoYAcHOEEFDXQQG7XEqSVOLXFqiVNLnFri1BKnlji1xKklTi1xaolTS5xa4tQSp5b4dV9igQY6WFU5mu8SGxgHGf/2Sn8NbKCAHRzgBBU00MFVOLFNbBPbxDaxTWwT28Q2sU1sik2xKTbFptgUm2JTbIpNsRk2w2bYDJthM2yGzbAZNsPm2BybY3Nsjs2xOTbH5tgc28K2sC1sC9vCtrAtbAvbwrbKto4DbKCAHRzgBBU00EFsDVvDFul/dlLP6OSzs1F6xgpxiRNU0EAHV2Gk/40NFBCbYBNsgi3S/+w2ntH1l7gKr/S/sIEChk0CBzjBlaViXaXiwgYK2MEBRrALFTQwDt0DV2GUihtP29lcPqPVL7GDA5ygggY6uAqjVNwYtvjwUSpu7OAAJ6iggWHrgaswSsWNDRSwgwOcYNji9F1rTlzo4Cq8lp24sIECdnCAE8Tm2BybY1vYFraFbWFb2Ba2hW1huxaiiOshSsWJevUY3tjBiLACDXRwFUb639hAATs4wAmetrMXW69uwhsdXIWR/jc2UMDTdvaO69VueOMEwxbiSP8bHVyFkf43NlBAbB1bxxZPEiuOLG4abvTCyOOzhVujbzBxFdbogR41eqBHjR7oUaMHetTogR41eqBHjR7oUaMHetTogR41eqCHYlNsik2xKTbFptgUm2JTbIbNsBk2w2bYDFvk8fl6pkY/YqKDqzDy+MYGCtjB07biK4w8vlFBAx1chZHH53IJGv2IiQJ2cIATVNBAB1ditCYm5liFtkPADobNAyeooIEOrsLI+RsbKOdKMC2wgwOcoIIGOrgKz5xPbCA2wSbYBJtgE2yCTbD1iCuBESHOWY8IcX67gQ6uwlhZ5sYGCtjBAU4Q28A2sA1sE9vENrFNbBPbxDaxTWwzbPHFzlWoB9jBiLACDXRwFcaKkjc2UMAODnCCp63Fl3XmfKKDq/DM+cQGCtjB09bimz9zPlHBfFrU5g6uwhW2uGBWAwXs4AAnqKCB8dk0cCVGV2ViAwXs4AAnqKCBDmJr2Bq2hq1ha9gatsjus5lYo8HSz2ZtjQZLP/uKNRosEwc4QQUNdHAVnr/diQ3E1rF1bB1bx9axdWwd28A2sA1sA9u1olQPnKCCq/BaLWoEdnCAE1TQQAdXYeTxjQ0MW3xZkccSX1bk8Y2rMPL4xgYK2MEBTjCONy6CyOMbHVyFkcc3NlDADp62Hqc68vhGBQ10cBVGHt/YQAE7iG1hW9gWtoVtlS06JRMbKGAHBzjBsPVAA70wMvbGiDACJ6iggQ6uwvg9vrGBAnYwbBo4QQUNDJsFrsLI4xsbKGAHBzhBBcPmgQ6uwsjjGxsoYAcHeNpGfBeRxzca6OAqjN/uGxsoYAcHiG1im9gmtolNsSk2xabYFJtiU2xRH0ZcUVEfblyFUQlujAhxPUTO32igg6swcv7GBgrYwQFG3LiiImNHfPORsTcOcIIKGujgSox+xMQ4Mg8UsIMDnKCCBjp42s6lKzT6ERMbKGAHBzhBBQ10EJtgE2yCTbAJNsEm2ASbYBNsHVtkdzyhRD9iYgcVjAjn1x09hokNFLCDA5ygggY6GLbziooew8QGChi2uDQiY2+coIIGOrgKI2NvbGDY4iqJjL1xgBNU0EAHV2H8omt8F/GLfqOAHRzgBBU00MFV6Ngcm2NzbI7NsTk2x+bYHNvCtrBFfdC4oqI+3DhAS4y+QT+HjTX6BhMF7OAAJ6iggQ6uwsjuc4hZo0MwcYATVNBAB1dhZPeNDcQm2ASbYBNsgk2wCbbI7nOQWqNDMFHADg5wggoa6OBpOweeNToE/Rzx1ugQTBSwgwOcoIIGOpgzg3p1CN7YwNN2vgiv0SGYOMAJKmigg6swKoHFSY1KcKOAHRzgBBU00MFVaNgMm2EzbIbNsBk2w2bYDJtjc2xRCc4lEDQ6BBMHaIWR3RbXQ2T3jQJ2cIATVNBAB1di9OF5DJRHH16igGFbgQOcoIIGOrgKI2NvbKCAKCL1zmVlNBrqEht4/tm52IxGQ13iACeooIEOrsJIvRsbiCJyKEboozPuxvg1vTH+rAcK2MEBTlBBAx1chZFDN6KIZDiXq9FocUtchZEM53I1Gi1uiQJ2cIATVNBAB1eho4jft5hGiF61RAfjz+KajAy4sYECdnCAE1TQQE+MBrXECOaBA5xgBFuBBjq4CiOdbmyggB0c4ASxReKcKwNpNJ35uWyPRtNZooAdHOAEFYzhsfhs8VN34yqMfLuxgQJ2cIBn3JgJivayxFUYmRUzQdFelihgBwc4QQUNdHAVTmyRejEZEo1kfq4ipNFIlqiggQ6uwki9G2PQNxSRhTd2cIATVNBAL4wJpOvQYwLpxg7WBJIxgWTVfqpW7adq1X6qVu2natV+qlbtp2rVfqpW7adqjs2xOTbH5tgc28K2sC1sC9vCtrAtbAvbwlat7OrVyq5erezq1cquV8tYXA9Xy9iNE1TQQAdrKu5qGbux5ZTZ1TJ2YwcHOEEFa3Lsahm7sSbHrpaxGxsoYAcHOEEFsUm2DevVMnZhP8CaHIv12hI7OMAJKmiggzVd5eMAGyhgBwc4QQUNdBDbxDaxTWwT28Q2sU1s17TSWeWcSuBa01WuA5ygggY6WJNjbgfYQAGxGTbDZtgMm2EzbI7NsTk2x+bY4pE2JtKipyzRCtcB1uRY9IklTlBBAx2sqbjoE0tsoIA1ObauCaQLJ6iggQ7WVNxqBxi/kBIoYAeznV6vPrEbFazJsXVNK124CuUAGyhgBwdY01XRJ5ZooIM1Obb6ATZQwA4OEFvH1rF1bB3bwDawDWyR3THTFs1h173GGjVdteYBNlDADg5wggoa6CA2xabYFJtiU2yKTbEpNsWm2AzbNTEVX+w1MXVhBxWsybHlB9hAATs4wAkqaKCDYYsva9XkWDRxJSpooIM5FWfRxJXYQAFzcsxiW9DECSpooIOrsB1gTldZNHwldnCAE1TQQAdXoRwgNsEm2ASbYBNsgk2wCbaOrWPr2K7Jph44wAl64cjJMTuGgB0c4AQVNNDBVTgPMGwaKGAHB5iTYxbNYYkGOrgK9QAbKGAHc3LMojksUUEDHVyFdoANzOkqu3YfvXGAE1TQQAdXoR9gA7E5Nsfm2BybY3Nsjm1hW9gWtoXtmq6KK+qarrpQwZx0s3bk5Ji1o4MDnKCCBjq4CtsBNjDiamBOjtnVrnVjAwXs4AAnqKCBOTlmV7vWhZGxNzZQwA4OcIKn7ZyCsqu160YHV+E4wAYK2MEBThDbwDawDWwT28Q2sU1sE9vENrFNbNdkU1ww12RT4DXZdGEHI0J83Wqgg6vQDrCBAnZwgBMMW1xRkbE3OrgKPSfH7GrtulHADg5wggoa6GBOjtnV2nVjAwXs4AAnqGBOV9nV2nVjTlfZ1dp1YwMF7OAAJ6iggQ5ia9gatoatYWvYGraGrWFr2K4pqPOKkmsK6sIGDjAnx+xq7bpxFfYDbKCAHRzgBBXM6Sq7mrhubKCAHRzgBBU00EFsE9vENrFNbBPbxDaxzZwcs6vh68ZVqAfYQAE7OMAJnrZzps2u5rBzRsyu5rAbV6EdYAMF7OAAJ6j3nJpdy+jd6GBOjtnVHHZjAwXs4AAnqGBOV9nVHHbjKlwH2EABOzjACSqIbWFbZbuaw25soIAdHOAEFTTQwbCdNbVfU1sXNnCAOTlmV3PYjatQDrCBAnZwgBPUwsjudaGAHRzgBBU00MFVeI2vX4htYBvYBraBbWAb2Aa2gW1im9gi58/tsexq+LpxgBNU0EAHV+E16n5hO7eab4ECdnCcKIETVNBAB1fhmfOJDQxbXDvWwQFOUEEDHVyFfoANxObYHJtjc2yOzbE5toVtYVvYFrYVtvhi1wQVXInRMrbOkT2LlrHEAU5QQQMdXIXtABt42s6V9y1axhIHOEEFDXRwFcbKuTeetnMMz6JlLLGDYeuBE1TQQAdXYayce2MDwxYnNVbOvXGAE1TQQAdXYayce2MDsQ1sA9vANrANbAPbwDaxTWwT28Q2wxZf7Jyggqswcv5cxNyiZSxxgBNU0EAHV2Hk/I0NPG0S10Nkt8Q3H9l94xlX4nuL7L5xFUZ2nyNlFs1hiQJ2cIATVNBAB1fhwrawLWwL28K2sC1sC9vCtsoWjWSJDRSwg2GbgRNU0EAHV+H1SrYHxp9poIEOxp+dF1f0iSU2UMAODnCCChrohR1F5GYMKUbDV6KB8WcrcBVGbt7YQAE7OMAJKmggiqtzK47h6ty6UMHs37G7c+vCVagH2EABOzjACSqI4uo6OQIHOMHzz87uG7tasG50cBX6ATZQwA4OcIIorq4TCezgALN/x66+qxsNdDD7d0yPA2yggB0cYCmudq2zq8eudq0bO5j9O3a1a92ooIEOrkI5wAYK2EEUV7uWBjZQwOzfsbtd68IJKmigg6twHGADBUQR97RnV4/dTVwXrsKZ/Tt2N3FdKGAHBzhBBQ10cBUqtkics9fHYiGz6NSxWMgsUUEDHVyFdoDZv2NXl9eNHRzgBBU00Asjs86uHoslyxI7mP07FkuWJSpooIOrcB1gAwXsILZIvRUZsLJ/x2Jxsguv3q8bGyhgBweY/Tt2dYTdaKCDqzCeQm9soIBnrT63TjK79nK4cBVeezm0wAYK2MEBTlBBAx1chR1F3BvFAEUsZ5XYwPMYYkwsepMSBzhBBQ10cBXGHdONDcTm2Bxb3AXFsFt0Fq0YE4t2ovz/xuHEtxk3OeculxbtRIkOrsRoJ0psoIBxOBY4wAmGzQPDtgJPWwxCRTvRijGbaCe6Dj3aiRIFPIPFTEV0CyU6uArj2rmxgQJ2cIATDFt8imsfkPgU1z4gF67Cax+QC8MWHzOeZm7s4AAnqKCBXhj3RjPOWdwFzThncesT8wHR9rNiuD/afhJXYTyW3NjBiBDndxoYEc4LJhaNWjFYH007KwbVo2kn0cGwxXmIxLmxgQLGMcRni8S5cfIPFDTQwVXnIRLnxgYKOOsTO5/Y+cTxUBG4rgtGAgXsYHyF17+doILxFc5AB1fhtcWRBo4TLXCCChro99Zfdu0HeOG1KdmFDRSwgwOcoIIGYpvYFJtiU2yx8dH12WLjo7j5vzYBvHHVB4otjm5soIDnocddfKwBlDjB89Dj92JdGx9d6CA2x+bYHFvsZXYjX4vztThfi/O1xF5mN2JbqfBr579z6MSvnf9uPFsIz4EPj4aOxAkqeA6fn+fXrxV8blyF0Yx5YwMF7OAAJ6ggtthH7Jy19+jXSOzgAM8TdS7C79GvkWigg+eJOnfu8ejXSGyggB0c4AQVNNBBbAPbwDawRRae+wf4tQngiC8rkmzEdxFJdqOAHRzgBBWMg4zzG0l24yqMJLux1TFEkt3YwQFOUEED+UCRhRdGf/V1TUZ/9Y3npSFxvDGPc6OBDq66UqO/+kYuROdCdC5E50J0LkTnQnQuROeydy77xWW/sC1sC1u0T58DKn4tpHPjACeo4NOfObgKI/VubKCA2Bq2hq1ha9gatoZNsAk2wSbYBJtgE2yCTbAJto6tY+vYOraOrWPr2Dq2jq1jG9gGtoFtYBvYBraBbWAb2Aa2iW1im9gmtoltYpvYJraJbWJTbIpNsSk2xabYFJtiU2yKzbAZNsNm2AybYTNshs2wGTbH5tgcm2NzbI7NsTk2x+bYFraFbWFb2Ba2hW1heyoKC9sqW3RxJDZQwA4OcIIKGuggNmqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuu7RTj1vLaTvFGATs4wAkqaKCDq9CwGTbDZtgMm2EzbIbNsBm2uK8+H8E9WjcSV2HsEXxjAwWMe6MIFnsE3xj3Rh6oYNhWoIOn7XzY9mjdSGzgaTufLD1aNxJP2/k07tG6kXjazkdPj9aNxNN2Pm96tG7cGNsF3xi2GShg2DRwgGGzQAXD5oEOrsLYLvh87vZo80g8bRofM27zbzxtGh8zbvNvPG0aHzNu82908LRpfOK4zb/xtGkcZNzm39jBAU5QQQMdXIVxm38jtoFtYBvYBraBbWAb2Aa2iW1im9gmtoltYpvYJraJbWKLpwOLryWeDm4UsIMDnKCCBjq4Cg2bYTNshs2wGTbDZtjiadziMornbosLJp67La7qeO6+UUEDHVyFUR9ubKCAHcS2sC1sC9vCtsoWqwglNlDADg5wggqGzQIdXIVRCW6MCB6ooIEOrsLI+RsbKGAHBxi2FaiggQ6uwsj5GxsoYAdP2zn56NHmkaiggQ6uwsj5Gxt42s45S482j8QBTlBBAx1chZHzHt9b5PyNAnZwgBNU0EAHV6FiU2yKTbEpNsWm2BSbYlNshs2wRc57XH2R8zcO0Aojuz2unRhru1HADg5wggoa6OAqjJxf8bVEzt942s7JMY/mDz0nxzyaPxJP24rPFjl/o4EOrsRo/khsoIAdHOAEFTTQQWwNW8PWsDVsDVvDFvXhfOnYo2ck0cFVGPXhxgYK2MEBTjBsK9BAB1dh1IcbG3jeLp6ThH7tKHijg6swbvNvbOB5c3qMwF4Yt+PHDOzgKIw73SPOWdzp3ihg/JkFDnCCChro4CqMp+YbGyggingoPuL8xkPxjaswHoqPOH3xUHyjgB0c4AQVNNDBlXjtmXdjDLAdgTGc1wInqKCBDq7CaxT7wvi9kEABOzjACSpooBfG0+35hq1fm99JHPr1dHvhBBU00MFVeD3dXthAAbF1bB1bx9axdWwd28A2sA1sA9vAdj3dxvm9nm4vNNDBVXg93V7YQAE7OEBsE9vENrFNbIpNsSk2xabYFJtiU2yKTbEZNsNm2AybYbuebuOKup5uLzTQwVV4jZRd2EABOxg2+c///Kc//PVf/+VP//aXf/3bP//b3//85z/88T/q//F///DH//Yff/g/f/r7n//2b3/449/+/a9//ac//D9/+uu/xz/6v//nT3+L//y3P/398b8+roA//+1/Pv7zEfB//eWvfz7pP/+Jvz4+/tPH0Pj5bB1//hgbP2aFWP5DjPZxjNhMISI8Jlbq73X+8Pfy8d/Pc+wj/n5OPsJjzPjVA4iXWq8DmOujAxgf//04Z67i7x93TW8dwNmfdh3A8o8OQD/+ez3yDDwq0zsHEJ27EWD1+dEB+OYAPK8hOz7+CnbXUY9uhes6Go/pkg+vo00QibcdIsZjcOXpRBzHyzEeAzRaMZY9xeivx2hHfp+PQZP1cYy+OSHT8qJ6TADIUwz7McbuuvRKjMG3+pjeeP0ovHLrMVTvHx/F5uI89wPNw3hUsYoxx+shrIrMufHhhyE2V+hj9LXfIR7DqO3DEGuTpTM/h9vTxdV/vEBld4G2qjSPkXkOYsiPITaZKs4l/mGA35zLxrn0j06EbK8Kq5q/Rv/wqpDNtfmYb6vr+3Ej/eFhjF26+6pz0Y+PD0N3h2GjDqM9fRT/6efHdtXX/6vq669/kkfRyeviMbz7cZrJ5up8TBBLfSuPqbCnz9J+TPh+fP189Pbl87H7LI9ZsrxIH5PZT3cFv3yWvss2k8o2fyrD/uNZ7btrzI6Kcd5y1U/jJz5Ld6/PMsbme9lcp6L1s/SYonkq5uvHzO+2+1kSr6tsPsf46Tg2ZfQxvl5X6mO89OMYu+OQMevn0T8+jrG5Th9jMXkcj1GX9WGM/TejB1eZPefdT9/MkF3urqrI8vzN/Bxjd6Vy//Q4jvVxjN2VKkdWw8dErb0XY/T6kRz+8ZU6dveiIxPm8YhVER7zBj9G2Fwfi3w5nk7GLyF296PNqUFPDwW/xNhdHueaGHkg5woQH0aZmwtVuSc91zV7KkI/htg9Hciox4PHXO5HIbbnQ+oH5twg5eNPsv3V17o6Th4fn9XdpW71YR74cbpsE/dRheph4TEzJx9Gmbuf/haLoNw/mG7HB8V92j/05+ExtzN58BkfJ+5c/9Cf3BFT3Pdx6Cb5dXd32i0PRB5PdE9H8uO1qvLVc7o9itGqnD7mfj48iu0tWdenHzr98JbsfHniwxjKDao9PVe3Y70c4zFTlmfjMfulH8ewr9/Uqf9Db3LHUU/W4znzP/HU8Eh2Ymy+FWu7ul6X6NNNsviPN1K2uUK9Hu8fM74fR+i7n7j8GGt9HGF7JuZR1+djGPvjMzF3N0A17vQoqU832cePeWK6O45W38hj4uKtGI/p4sU1Lh/H8K9f4/blKro9o70erps+P4L99Em8bW/kqF7947OxvTqc2/Ql471cewwFVgz/+Cnfx1dzzedXc831H5pra+VBjMfX+vGZ2I0/mfCr9kOe/DTIuhuAap0bwUPfirEOzVxbx1ofxljt67m25B/5ezJajUINafrWNT544Bm2GULaD6gdDKg9fSs/jyzuBoylVxF93EF9OGC8bHuzcdTNxvr44tjGcK3j8NW+HGMd8maMo1eM9nGytKN9tXK0Q75aOvYhtFLleDobP8fYno1YEuY+G88PCL+cjfn1UfhtjNeu9GN3FIsI7Wkgv/10FLtf+s4pHU8x2vx5pmj3uMNw2tO30uWn49glrVk9MNlzwon/NMvT2u72SfhlIcTPE0Vt97zU6pyeY0BvBpF6VJH+fJ1+KojVvaA8V9Nfgmy/3uFMDAz9+Ovd1WTlSj3XPnxKmZ+/4N1j06oJn7aepijaT8Mdr17vT/NnP1/vu2mnpS0PY+nzcOlPh9FkO64/a1BtPP/CLP0pyO7OtKn/VwPqP80TN5HdSa2skeNpPOyXGJunJ6sTYs/z7fPnj7KdGs2jmM+/L58KUYMMs9smxO6DHHyQtQmxHUxf9bPfn6rhY9DipyC7nDusRsKOpy+2z5+DbO9OV/3ejo9D7GaftE6pdt0cxfajaD2BHU9jer8G2V7olS2PkvphT0rbzT6NeOv9Ku2PoTUO5Kdh27adfnpptncX4WweqCfS+eZhtOjdzZFwfzOIzSrs5uPdIPUo1h7PQG8G8X5UkKefmF+CbMsyH2eZt4/L8tg9Sa3jaSa9PR2JvvoT0x5TeXVeH1PpnFj5zO1hdK/dP1RPs0efuz18rUtjzO0MlDJ0+26Mmud8xND3YsyagJapH98ubyddjhrIeUw0jrdizFVDY/sY28/yWuvLdg6qrlN/qmU/977sQ7zUPtPmdkb/pf6ZNr9cUrdHcSz6Cp4eg36JsblBjSXrruLRZHMydrenbnVz+ZjZePowsuzdq8M/vjo2tdC015PQx+fjN7Xjla6ktpv2efk5eRdkHFJj0c+3Qr8G6buxGBoA9XlY6efWu+2RtCqFj0mgsTmSLw+fNv3y+OlvPgqTWK3tTqp+eSRlfyDKt2vP7Ss/H4gdXz6nuzmoF8/pNsR3nA6vjBned6djfDX5d4fxqEA1NtXm5krfTkTJ8v/qQUg/EaLX2HjvT10SP4fw3ZVeR/EYlP4wxKtnQzYDqPsgVtOD8zE69XGQ7UyU1SzSA/2jD+PfMFXQvH91rmAforpO9Om+4XMhlMYm34TYnY1ZIxePO4yxORvbU8oc43zuKvglyO4xeT3N/S5Z712pLjUEsqZ/fJGtfSdf5f7zGflphGxtr9NXOka2RzF5/Bm+OYpdiGqxmr75INsTupbWAMhs76W+DquOs/lu/XiMv9SRTN2U5N3ExYs/lMu//EO5DfENP5TK2xiqm3sxObbZv2pa68FP1fATOff4ja2Rbdvcn8qxbcLTSWH/8On2NzF4CvKPn0y3MTo9q10+HnX4XYzjyzFGq4fC8TSq9KkYnfuP0TYx1ktP+49SYG/FeHHU4dXj2MfYntN6K66P+eGog+xeP3r1fLwY4wufxZ7azvzLMZ7L8ueuMakn3Nk258O3Y7k1+Gnj47GH/YEYoyjPz1E/H8huSurVL3cX49WL/cXjeP8CYfii74rh9o2oY9GO/Dxo8KkvJnYgvg9kc6Xu3oka9egwZHN97GalGsXwfJuTce2f3gjdH0eN0v8wY/nL6dj/5HaeP9b8sEN7+07UI4g8BdF3grz2YPjbD/PaceyeYmKTv+v+oR8ft9bIdlrq4F2T5xcjfhnf2j5PVUPKD7Pan3ok407XNw+G+vV5D//6lIV/fcbCvzxhIaN9vZqO9vUJi/XVuYbte7avjdDLblz8tRF62b0K9YkR+pffXP64pO+mkV4ao5NveBF8+76u1w+crB9GgX+KsZtFem2Ybx/ipWE+2U0BvVjNtyejbuVk7V5enl8e3Zf59e7o+fWB+e0r1C8Nz20jvDQ6t30V/MXBuf3r5K+NzYnK18fmds04sxp65nOTt78coDWt8awHP00b//Km3vYVqNfSdRvitXTdvQD1Wrrubt9eGwrfvhX/0iW+jfDSJb6/k33tEt+vEPDiJb57/+nVS3z7er8cNGnJ81t+9nqMOepdmx8WD/JPLLwgUp1vD36O8nOmmH05U7YhXsuU3StQL/6wvX469OPCsV/vgDtifZ6Z/Hm9g5dj2NdjPI+WfGbdhUNrhPLQzVoFu/egmtvTrWTfBNl1ndQ9hz81m30uRDWs+7Q3QwyW2/Ivh9D+3gl93N/xwPT80uHngvCzoG2++dUuEmZtvpfdehhd63HlfOv4rRiP51heNd5cYi+uy/EYKP342315jZFdjFfXS7GP81bWV5+atkdhvP/ox6aKHZtTunr9VK7H0NxHN3P92D7y8CZ6f17V7Kefyt2bTI9TRefc87zizzF2v/vtabWDx4Cnf/hpdPvoVKNP/vxz+5m67vXQ8kDdXB+7X7pZnRrth87KX1dc2i13wloWx/NIw0/P99t1W1rjxYzNEhJ9N+njNff8wyt3v1yqu55oRrCPwz+OsXsj6sUFU/ruRaQXV0zZfpZ2VHNDO8bmhOxW4Gur3phpa20KQJtfLwBNv14Adu9DvVoAtrNPLxeA7XfT69fuMdMg712sPwZZHwbZL7pUS1k95kM+vvPfx6jTKn23CNUuRq/mavlhWa6fY+y6Nep53/29VZceM771NvV4fk3kEzEeg528meUfrzHU94NBNXX0wPZekMf0yKiZkqe+s08GqTU4rS9/M8ioST0bvb8ZxGuCwJ5vmj/15Yya95nPPQ6fimGsSvo8JP65GPVENV02F0nfrtVxsGDi48Fsc153dxJNmPt9sG6utt1DYpuTefmpx/H20bBIlzy/VfhrmO1qUP70vqibv3uKWXLwwfPdK+b53QB7L8aiO289TTd+alG5o65cbe2949BWT67adlm4vnx3s13bTmdneeH5FORTK+Q9hohZ7uaRiW9GUcYC1Q57M4oJn8iGvhul5kMevCnY+yheE6kPbu3dY3k6u94+Prt9u2zf6/Vp99rUWZ94L/95UuHTYV4sc7/5UK+Wue0rVMNZAXTsT7F9R7X8zfc9n649ffvaq3fkHjzfzab1tJDV0vFuFFbQ1GXrvSgm9Sb1yfPdKKz2aOIfX3i76+571tFk/YIHz/ZmFK97sQe3480o6+lY1uZWeb+mp7F87WYYZB9jsS7o8/JFn4nhg+G2+fFT0H5QZ/E7Is99ib8MptiXX1nZh3htwtC+/MrKbxZJpV4/BmDbRxN1u3mpxUpdq304L7UPIfWKx3o8ML8zL9VnY9HYuXlY30fRWm+jdWsfR+n+5S6WfYiXJvu6f72L5fXTIW+fVO4tHlH0zShWMzoPnpvhWLevfzX29a/mHzsP++Pp2MzD/u6r8acom6WW11dL2TbCa+0920fazqofo29+Yvqa29+6VxpBdiEe1ZB5A9PxZhB7up+x532LPhWkJqge7PrOdTYGMcaUj/dq0O1Ljd+y/LSwFFr/YaTc34vxPB/zmRiTYeH5nHmfiPE4fqnR9ufz8XOM3czBa5152/Wnj+o+HW08v/n2iTWsG+v7npO4H8UYu3XhXqvL+xAv1eXRvtzGvz0ZwpKj8sNanz+djN0E1/DFNPvzSxq/BNm9GfVKj+D+MBhVG+u5s+VTn4VZw3nIeDuIVJDhbwepgcbjzbXWX16v3b/6c7mN8NLP5XbN+BdbBffrzr/WKjjkG1oFt0v18Vs5nlcN+7nZesiXm62HfLnZeh/ixWbr3dkQ4QUvfa+Xf/Ra12H88JbYz2d0u9xfTY7r03jM2cv5HGJ7A3MwjC3PV9j4Mdv862d0uzD3MfL68mPztvw2xlysj2XyXoxVI4iPH4j2VozHM37eJq9D5ocxdgsyvLzIuHy1CG4jvFQE1zes17G+YbmOMb7hlYDdkh+Pm6Z6AVns4wXCx9gv4qhPjy4V5JdmpW1TzGLx5cM/jrHd8fSlV9W2MV58Ve03n6XugOTo8nGM3bP+S+/bjt0uU48b7Mb3sp5+4n5+02x/JC+9cTv2rWi1pq08SvJbJ1Ua25C1p/Lxc4zdRNOrJ3U7e/3aS8z743jplG7L2Evvye4jvPKa7Ha/mtd+I7eLa416g7A/v+P6qc1mVs1tjR96xz612Qwx5M3NZl7esObLY2L25TGx7aY5L/6+7TfeefH3Tb9hOartuljfsfcO60D9+FLAZ2Kw8Mlj8OfjHZHG17eYGl/fY2p8Q9rvz2hNActcsjkb21czX1s5af8cyXjp0o+3RBq23cXnpYWTfhPjpYWTtjFeXDjpdzGOL8d4beGkfYzXFk4au32mXlxLZhvj1VvKF49jG2N/Tl9aOGm4f8P58H/0Z3lp4aSXY2wWTvrNNfbSwklj7QrIiwsn7Q/ktYWTxm7Q49Uvdxfj1Yv9xeN4/wJ5beGk2Cz+40Gg1xZO2h/IawsnzaN99Zlj7l6yevWZY38crz3G/eYX96WFk+ZuUe9XFyzaBnltxuW3H+a149j9bDt7tDX9+Pll7t45eXXhpO1t/0vPg/sIrzwPbucXXjqGfYSXjmF7Z1mdCQ9c//nWRK31p92oj/disMfTA/t7MZztt9Yx34rxmHiq37hDPj4fY5dtr846b4M8rol6tnVrH07V7kKsGkbSJfZeCJ6w1/xwqvblq2O8eYUJMfrHJ3TKl1dR2Yd4ae57iv1DQ7w4fb49n/pf9t987jvhjTtb71aOp+N4NwZbojzw3RhDXokxv/yLMr/8i/KbDk+2uRN5s0m0Ot4e+GFHlH15UcLfhHjlXOz7mOvVY/lhsbVP9ULXzehjlMHejGFcW/bucbAQgz9vRPBz++C+133Qpf7c2f3JjvnnKJt3nn4XhR3I3D5+G2HuXrZ98S33uXuX7MX3wH7T/y8sK7M2b7n+5pws3kVYx9vvIjwfS387Cg8uvsabb66YdBojHyO670bRp3dO3n7/pbNJnHWRd6OMpyjz3bdoen+Oou9GeRpK6f72ebGnKOt4M8p4ertoyLvf9Dieo7x91bEkgY2+qS273afa6NWz+eDNBfO7MLQpj757T2nX7/j6y3G/O5rJts998+rsZz7UF8LUoOTZTL47xev/j3Oz+FDjGN/xob4QZtSuUg/erFcwt0sEfte5YXnmB4/5LR9qvFs+j4PO/+N49yXlxUs39jwx98lVJar97oHrzSD6tBez2JtBZk3+2lzvfhyrUWDzt9f8eP447wdh3TC1d9f8eNrB3Np490iqTfwRZL57JJNl0Ob4hm+nbUqC+3eUhN+shFK9UtsrZb/gDo0CfXz8tsp+AdPqGhV5fl31p8VH566358WhoW2I18Z11viHhnhxjd7d+ey8ddPt2JzPzcXx0ksR26MYDC6NH9a3+vko1pcfD3W3buCri6Btl8cVlp5/7gX+1BK7zxsTfHw+ZDeD8/I6vbsgrw1L70O8NCz9mxCvDEtv14F+bYyqfXWIarvC1kvHsI/wyjFst+yrWfCnsQI5+ssBFkvxzHcCtENYulHfC9F4KbU9vbf0qRDVB9iav3cUvU5Fe16l7DMhJsslzqclKD8VQllh5mlQ4FMfhEUxurz3QTrje32+9UHE6gbjMefz1rX5mGFmBSF774OYMZjwdFf9mRCL0/n8muEnQlhNTzyvyfSJAKt+1J+3GP1MgBoIfx7f/EyAyq9l84sf4b0AzeulwubPCytOfSvE0+zwZ0LwdlFbTx0QnwshhLD3Qgz6OMd7H6QxXCLPwxx9vRXiuU/n9RBs6zN/mK0fbwT4oXXh5QCvLVKzC/BSD/v2DcBXWtiPr96HHP/A25DWWW+rO2fBf5rT3u01NWrKYjx/iuGvh5iVm1PfDVHD6fN5ou5TIWoRpx868N8M8ZRXnwrx/J0eb4Zgqcc13gth9dtpz6v6vhniOUE/FYK3So83PwgLjfm7H8TrhS5/7px9M8R880td7b+6E/hcCDoMxptXJ7+izz+i74awN7/UdkyWN9ePT+h2JyD2hBtPL5T+XPl0N3DUaiawt6c1eUR/WmZgu0PUUW9l9ON5lvXnpWN0926Z1Qze2ZS8CbI9knoi7M+Pc78G2W07waLx/rwjwGNy8Kcguw3ApHo3pjz9LP18m7QP0usFoAfOd4PUrNL8Ya73lyC7XoejcU6eJq9/OSe7KSWzWmPIntcY/DXI7oqtO9jRPn6ciPuSD58PGx2jcqw3g9Ds9BhIljeDvPikus/hzotE/Wnq+9cc3gVhUYofNn35JYjvHjaX1+5Ex1Mbyi9f8D7Ii+m3C/Ly9erfcb36169X/47r1b/jevV/+PU66o69j6fS+OultnY/XDWs8Kj0T3fcPxW1tR2h4Y1Ve75rt59ivLitYH8vgnO37G9GqC2lj4+PYf+VNN55e1pH/JevZPs+0lEXxzyed8HR12OMVbNQ83hup/05xq7JmUeYoc9P5m/H6B/GeP2kfnxvZcf2Ju+g7+G5F1V/irHdV3rwotg6Po6xezHqWKwR2o6u3xLlwy94f0b8ldvebR3r9T7zoyy2dysqL4304907gFePxL7jSPb3idX8Np/vAD55s8k6cONo74wOvnrnfPxjj+LFu+bdWoUs8zWetx7/cYTSdltP9cYvpXwYYrteYt19PLXi/noM9vW7INvtO/XaXZDttqV/9S5oH+TFTNkH+fr80ux1Nzb702/UZ65Qtlh8jBw+3b309uNH2W6DzrqN/Yct4z4T5DHpx2oIbXckm+f/SnrjzmG8fD4bGz0+3QL9sj6ObB9xX1nyw3Zr8b625Mc+xGtLfmx/H9fTRiEfvq9vfbv8Sa1j9zTF8/MbzPsQk+X0dBNid3EerNTRjg93ALXdFkheP2qryeYwds0vnfXSxlOi/fxO+KvfiX34nWwv8Oflpp9Xtfn5a90WrpqEfPzIfvRO+X5CmvnD5wHY4xMfpBbwbuuHBWl++iDjy8vz2Pjy8jz7EF/OVWk0q/1QOX85GbvX689Nm2hW+LB373dB+vPuN/3DIPt39BkIbn3zcXa3kKxHrMdTD8lPuw9vYyj5ps+Nc5+JMVeN0D+mJj+OMXetnV6fpa8fVu/+xIGY1I/b2ZX88YFs1418anx/Xim6//TNzO0D/n854f1LCP0Hn5Cnb8aed/f65YTsVtfR2ghuuvWPD2T32u2r4527G3SGf4Y1eaeiDm2EkM1Pg369ourXK6p+wzqHv6lkTwvRfbwzg+l3lMNdkNdaqvcVdR403j7fiv3y3e5eWFm8evi8LPEvT3DbINxJySGbINa+njC/CfLaBME2yKsTBLabi3r50Xg3ePPio/G2PfvVR+NtkBcnCPZBXnw03v7O+MGjQ//4d2Y3/yO9XiSS0TdXq3/H1br95VXhzdQfnoR+/jh994R9sPW374KM7zgn8zvOyUsPZe35JbxfP81uN/TG4h3P61X8+mn8Gz7N9sth8OGHhRx/+Tjr+IaPs77jgn3x7soPf+/eWa32HVZ7Wsbo3ftve9qJ/OcY2/0JHtNJT0+bT6tD/bwut20XNXjMqz/twrXaJsz2aaCasR9DCm1zz7kLsp4283neY+nnIGt9/SfUj28YqN8HebHF5TdBXhus356TV+8I4k75q3cEfnz5jiDG6L56R7AP8uIdwT7Iq3cE20fg2Z/eUP5wTMB3W0f1WoOwP/cL/PRksd1n+BNlQL+jDOjXy4C38Q1lYDdH9XIZ2AZ5tQzsg7xWBrbn5OUysJsherkMyPHlMiDtG8rANsirZWAb5DseDCYXyfObvT/dZ7lst39jKyp5uqv4Za5q/3TBzVpXe/fp4sXHWP+Gx1iX77ha+9ev1v4dV2v/jqu1/6OvVpbTWnN+fLX27YhrbfM123Nv1y9X6+6V+tYI8rwl3i9B/Duu1m/oIvb+HVfr+PrVOr7jah3fcbWO77had0+xsmoEWNb8eNjFty9SHTVFMI4fZo7bZ8YpXq2u8zuu1/kN1+v4jut1fv16nd9xvc7vuF7nP/p67a3aAB/jWh+PuviuRA+rqf3hP8xptdeHbl6ur+s77gbWd9wNzO+4XvXr16t+x/Wq33G96rfcDewmHKUm6R8z0rp56tsFGezV+7zKwy9Pfdu5rXaw5sXzqlTtM0cya9Bz6vP7078cybYrsObHnroFfmrk9d2s1H8doY2fH8e/YSxsG+TlzNttOvVy5u1esnox82x8Q+Ztg7yaedsgL2bePsiLLda/+TivNY7uC8mrR7IvaS8eyfyOI5nfcSTjO45kfMeR9O84kv4dRyLfcSTyHUeyH1J77aWA3wR5rR1/P4786jnZj2i/eE72sw0vnpPjG15ReL3frn/cb+drdzvgTwt2P70z/XOX7djubdyfXiM/NgfiX3/u+02Q1ya51/EN77H+Jshr9xXbIK/eV8T+jF+9r1jHl99jXcc3vMe6D/LifcU+yMuTUtsNHGt1xi7+ceve2u1I9erD4zbIq80Dq31D88Bvgrx40bdveIxd7RtmYlf78kxs7P395Yu+fcNM7D7I91z0NWLS++YNgG2QcdTHGcfcZI60f3CQ19Yk3Yd4aU3S34R4ZU3S/Zf74u3Rby6z126P9rX11SM5vuGN1n0z4otH8pu2yNeO5NiOlWSJf55x9PZqgMcEP2uMHs/9+/qJEKyYd3jTd0KwBtSDn1aB+kSIVasRP1jbWyHYvOSH9sHPhHjasfR4eqXrE0sYspPkg+Wjo1h9ff2jbIO81mR+bCv6CyuYbxtrXll8fO3epPqGEF8+D01mfaPy/IrMev01P6HbUJ7fbXs3hL4VovOSXn9+p/czIZRFFZ97sD8RYtZbKW2O985F563J5xcv3w7x3pf6vMza0xPlp0KwmvBQfTMEH+T5/c/PhGDx1+HvfaljsSvxcbx5XfAqrLz1pbIh+fOyKp8IwKU55ePzsPb7Pip7R/rz4qsvH0Td8/0wk/OJT1G9IT+scvOJAJMpnPFWgHpinKu/F6CWPF3jawF+WPD0MyeRpXHeKpVaK2xoX188gp+/xv/++K9/+pe//P2f//qv//Knf/vLv/7t/z7+7j/PUH//y5/+x1//fP/X//Xvf/uXp//13/7f/5P/y//4+1/++te//O9//j9//9d/+fP//Pe///mMdP5vfzju//Pf7HyZ7nEHbP/9n/7QHv/9MWGn/+R2jMd/7+f/7o+Uf8x/n/+9nX8wzs7TsTz+H+df2HqMQj7+j/33/zwP+f8D","names":["is_user_blocked"],"brillig_names":["is_user_blocked"]},{"name":"public_dispatch","hash":"6662757920344598939","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2236649814169388962":{"error_kind":"string","string":"PublicImmutable already initialized"},"2830029349304997821":{"error_kind":"fmtstring","length":27,"item_types":[{"kind":"field"}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"4846867431813379492":{"error_kind":"string","string":"Function set_public_block can only be called internally"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7049597037775588060":{"error_kind":"string","string":"Function check_block_user can only be called internally"},"11556553965573010925":{"error_kind":"string","string":"Function increment_approval_count can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14970808627057722807":{"error_kind":"string","string":"Function increment_guardian_count can only be called internally"},"15111608787814000058":{"error_kind":"string","string":"Function decrement_guardian_count can only be called internally"},"17595253152434889169":{"error_kind":"string","string":"offset too large"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["public_dispatch"],"brillig_names":["public_dispatch"]},{"name":"remove_guardian","hash":"9568004249405412249","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"address_note::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"guardian","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"address_note::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"855401245733623969":{"error_kind":"string","string":"Obtained invalid key validation request"},"1433889167918961673":{"error_kind":"fmtstring","length":17,"item_types":[]},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5641381842727637878":{"error_kind":"string","string":"Got more notes than limit."},"5672954975036048158":{"error_kind":"string","string":"Collapse hint vec length mismatch"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7506220854563469239":{"error_kind":"string","string":"Dirty collapsed vec storage"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"10583567252049806039":{"error_kind":"string","string":"Wrong collapsed vec order"},"11499495063250795588":{"error_kind":"string","string":"Wrong collapsed vec content"},"11553125913047385813":{"error_kind":"string","string":"Wrong collapsed vec length"},"11873158822563704285":{"error_kind":"string","string":"Mismatch return note field."},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"15431201120282223247":{"error_kind":"string","string":"Out of bounds index hint"},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"18313900523101689315":{"error_kind":"string","string":"Note contract address mismatch."}}},"bytecode":"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","debug_symbols":"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GqcuZ5z0q8WzcepeuZB+tdgbBzj9ajE1Ho25sTSejZuuNV1rutZ0ven6pZvP10fjputN15uuN11vut50velG0412v9HuN5puXLr5TGM21saXbj7H8MZRfE3aXkyNR2NuLI1n40vXkq2xNw4wHY2p8Wh81StPlsazsTa2xt44wONoTI1TN9/p11zuxdJ4NtbG1jh157V/S4DTrxZT49GYGzddbrrcdLnpsjcOsByNm640XWm6l1/dPBtr46YrTVea7my6l1/d3HRn051Ndzbdy6/yO+qa7b3YGwf48qubL92ZfOnms7786mZpPBtrY2vsjVNXz63k/t9/+Ld/+of/8s//+D//9p/+97mz3P/6l/+6tpF7/ee////+x/p//su//dM///M//ff//D/+7V//6z/+t//1b/94bjl3/n9/O+7/+b9eZe1/fxVs/N8vkdd/+6vB+Hd/ta5e/83n//96Sf/9dUN6/v/nH7waefPvr9bdcf4D5W9Me/3GjHNfO1px/fXF7Rx3lFezImxF8NcHu5Osvz+Huf9+jmmffz/W35+nlnP+Ul4Fvf5i/f1riOrvr6Gm9fev3vi/v3rez7/m3Ejv/B2Kvw85/0nqn17N25HXOPFP9nfOP9T6p7C/05H/Zvi1+ffr6vz3+HH+03mJr7eTjHWJr+o0NcvjQBT6+6sU/8+5/9//Hw==","names":["remove_guardian"],"brillig_names":["discover_new_messages","get_notes_internal","get_collapse_hints","field_less_than","decompose_hint","lte_hint","get_public_keys_and_partial_address","get_key_validation_request","notify_nullified_note_oracle_wrapper","store_in_execution_cache_oracle_wrapper","notify_enqueued_public_function_call_wrapper","directive_invert","directive_integer_quotient","directive_to_radix"]},{"name":"set_public_block","hash":"3713941616740913681","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"user","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"4846867431813379492":{"error_kind":"string","string":"Function set_public_block can only be called internally"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17595253152434889169":{"error_kind":"string","string":"offset too large"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["set_public_block"],"brillig_names":["set_public_block"]},{"name":"sync_private_state","hash":"6656019669551830516","is_unconstrained":true,"custom_attributes":["utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"vb3dru3MbWD7Lr7OhVg/ZNGv0mgE7rS7YcCwAyc5wEGQdz9TlMgx9/6yas811/rOTTxi78UhaYqUVEWV/vMP//vP/+s//u8//+Vv/+fv//aHP/6P//zD//rHX/7617/833/+69//5U///pe//+3x3/7nH47z/4isP/yx/9PjP/0Pf5yP/2yP/9rO/5Q//NHP/2x/+KPICT1hJMwETbCEleA39CNBEjJyz8g9I/eM3DNyz8g9I/eMPDLyyMgjI4+MPDLyyMgjI4+MPDLyyMgzI8+MPDPyzMgzI8+MPDPyzMgzI8+MrBlZM7JmZM3ImpE1I2tG1oysGVkzsmVky8iWkS0jW0a2jGwZ2TKyZWTLyCsjr4y8MvLKyOuM3E6YCZpgCSvBb/Az8nny+Rn5PPu8JfSEkTATNMESVoJf0I4jQRIekVs7oSeMhJmgCZawEvwGORIkISNLRpaMLBlZMrJkZMnIkpFbRm4ZuWXklpFbRm4ZuWXklpFbRm4Z+czBNk+QhJbQE0bCTNAES1gJfsPIyCMjj4w8MvLIyCMjj4w8MvLIyCMjz4w8M/LMyDMjz4w8M/LMyDMjz4w8M7JmZM3ImpE1I2tG1oysGVkzsmZkzciWkS0jW0a2jGwZ2TKyZWTLyJaRLSOvjLwy8srIKyOvjLwy8srIKyOvjLwy8pmDbZ0gCS2hJ4yEmaAJlrAS/IJ+HAmS0BJ6wiNybyfMBE2whJXgN5w5eIEktISekJElI0tGlowc18B5gt9w5uAFktASesJImAmaYAkZuWXknpF7Rj5zsPsJPWEkzARNsISV4DecOXiBJGTkkZFHRh4ZeWTkkZFHRh4ZeWbkmZFnRp4ZeWbkmZFnRp4ZeWbkmZE1I2tG1oysGVkzsmZkzciakTUja0a2jGwZ2TKyZWTLyJaRLSNbRraMbBl5ZeSVkVdGXhl5ZeSVkVdGXhl5ZeSVkT0je0b2jOwZ2TOyZ2TPyJ6RPSP7HXkcR4IktISeMBJmgiZYwkrIyJKRJSNLRpaMLBlZMrJkZMnIkpElI7eM3DJyy8gtI7eM3DJyy8gtI7eM3DJyz8g9I2cOjszBkTk4zhwccoImWMJK8BvOHLxAElpCTxgJGXlk5JGRR0YeGXlm5JmRZ0aeGXlm5JmRZ0aeGXlm5JmRNSNrRtaMrBlZM7JmZM3ImpE1I2tGtoxsGdkysmVky8iWkS0jW0a2jGwZeWXklZFXRl4ZeWXklZFXRl4ZeWXklZE9I3tG9ozsGdkzsmdkz8iekT0j+x15HkeCJLSEnjASZoImWMJKyMiSkSUjS0aWjCwZWTKyZGTJyJKRJSO3jNwycsvILSO3jNwycsvILSO3jNwycs/IPSP3jNwzcs/ImYMzc3BmDs7MwZk5ODMHZ+bgzBycmYMzc3BmDs7MwZk5ODMHZ+bgzBycmYMzc3BmDs7MwZk5ODMHZ+bgzBycmYMzc3BmDs7IwXlCTxgJM0ETLGEl+A2RgwGSkJEtI1tGtox85uBsJ1jCSvAbzhy8QBJaQk8YCTMhI6+MvDLyysiekT0je0b2jOwZ2TOyZ2TPyGcOznGCX6BnDl4gCS2hJ4yEmaAJlrASMrJkZMnIZw7OeUJPGAkzQRMsYSX4DWcOXiAJGbll5JaRW0Y+c3CuEyxhJTwi6/GAMwcvkISW0BNGwkzQBEtYCRl5ZOSRkUdGPnNQ+wkjYSZogiWsBL/hzMELJKElZOSZkWdGnhn5zEE9f50zBy/wG84cvEASWkJPGAkzQRMysmZkzciWkS0jW0a2jGwZ2TKyZWTLyJaRLSOvjLwy8srIKyOvjLwy8srIKyOvjLwysmdkz8iekT0je0b2jOwZ2TOyZ2S/I9txJEhCS+gJI2EmaIIlrISMLBlZMrJkZMnIkpElI0tGlowsGVkycsvILSO3jNwycsvILSO3jNwycsvILSP3jNwzcs/IPSP3jNwzcs/IPSP3jNwz8sjIIyOPjDwy8sjIIyOPjDwy8sjIIyPPjBw5qCe0hJ4wEmaCJljCSvAbIgcDMrJmZM3ImpE1I2tG1oysGVkzsmVky8iWkS0jW0a2jGwZ2TKyZWTLyCsjr4y8MvLKyCsjr4y8MvLKyCsjr4zsGdkzsmdkz8iekT0je0b2jOwZ2e/I6zgSJKEl9ISRMBM0wRJWQkaWjCwZWTKyZGTJyJKRJSNLRpaMLBm5ZeSWkVtGbhm5ZeSWkVtGbhm5ZeSWkXtG7hm5Z+SekXtG7hm5Z+SekXtG7hl5ZOSRkUdGHhl5ZOSRkUdGHhl5ZOSRkWdGzhxcmYMrc3BlDq7MwZU5uDIHV+bgyhxcmYMrc3BlDq7MwZU5uDIHV+bgyhxcmYMrc3BlDq7MwZU5uDIHV+bgyhxcmYMrc3BlDq7MwZU5uDIHV+bgyhxcmYMrc3BlDq7MwZU5uDIHV+bgyhxcmYMrc3BlDq7MwZU5uDIHV+bgyhz0zEHPHPTMQc8c9MxBzxz0zEHPHPTMQc8c9MxBzxz0zEHPHPTMQc8c9MhBP8ESVoLfEDkYIAktoSeMhJmQkVtGbhm5ZeQzB+04QRJaQk8YCTNBEyxhJfgNIyOPjDwy8sjIIyOPjDwy8sjIIyOPjDwz8szIMyPPjDwz8szIMyPPjDwz8szImpE1I2tG1oysGVkzsmZkzciakTUjW0a2jGwZ2TKyZWTLyJaRLSNbRraMvDLyysgrI6+MvDLyysgrI6+MvDLymYP2uM3wMwcvkISW0BNGwkzQBEtYCXdkOY6j6IxtQa2oF42iWaRFVrSKPOlMx5vKIeWQckg5pBxSDimHlEPK0crRytHK0crRytHK0crRytHK0crRy9HL0cvRy9HL0cvRy9HL0cvRyzHKMcoxyjHKMcoxyjHKMcoxyjHKMcsxyzHLMcsxyzHLMcsxyzHLMcuh5dByaDm0HFoOLYeWQ8uh5dByWDmsHFYOK4eVw8ph5bByWDmsHKscqxyrHKscqxyrHKscqxyrHKscXg4vh5fDy+Hl8HJ4ObwcXg5PhxxHkRS1ol40imaRFlnRKipH5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ63yvNWed4qz1vleas8b5XnrfK8VZ63yvNWed4qz1vleas8b5XnrfK8VZ63yvNWed4qz1vleas8b5XnrfK8VZ63yvNWed4qz1vleas8b5XnrfK8VZ63yvNWed4qz1vleas8b5XnrfK8VZ63yvNWed4qz1vleas8b5XnrfK8VZ63yvNWed4qz1vleas8b5XnrfK8VZ63yvNWed4qz1vleas8b5XnrfK8VZ63yvPoGFpHkBZZ0SrypDPPb5KiVtSLRlE5rBxWDivHmefr7LSLBqKbpKgV9aJRNIu0yIpWUTm8HF4OL4eXw8vh5fByeDm8HJ6OaCq6SYpaUS8aRbNIi6xoFZVDyiHlkHJIOaQcUg4ph5RDyiHlaOVo5WjlaOVo5WjlaOVo5WjlaOXo5ejl6OXo5ejl6OXo5ejl6OXo5RjlGOUY5RjlGOUY5RjlGOUY5RjlmOWY5ZjlmOWY5ZjlmOWY5ZjlmOXQcmg5tBxaDi2HlkPLoeXQcmg5Is97kBS1ol40imaRFlnRKvKkVY5VjlWOVY5VjlWOVY5VjlWOVQ4vh5fDy+Hl8HJ4ObwcXg4vh6cjGpdukqJW1ItG0SzSIitaReWQckg5pBxSDimHlEPKIeWQckg5WjlaOVo5WjlaOVo5WjlaOVo5Wjl6OXo5ejl6OXo5ejl6OXo5ejl6OUY5RjlGOUY5Rjkizy1Ii6zo4fAjyJPOPL9JilpRLxpFs0iLrKgcsxxaDi2HlkPLoeXQcmg5tBxaDi2HlcPKYeWwclg5rBxWDiuHlcPKscqxyrHKscqxyrHKscqxyrHKscrh5fByeDm8HF4OL4eXw8vh5fB0RHPUTVLUinrRKJpFWmRFq6gcUg4ph5RDyiHlkHJIOaQcUg4pRytHK0crRytHK0crRytHK0crRytHL0cvRy9HL0cvRy9HL0cvRy9HL8coxyjHKMcoxyjHKMcoxyhH5fmsPJ+V57PyfFaez8rzWXk+K89n5fmsPJ+V57PyfFaez8rzWXk+K89n5fmsPJ+V57PyfFaez8rzWXk+K89n5fmsPJ+V57PyfFaez8rzWXk+K89n5fmsPJ+V57PyfFaez8rzWXk+K89n5fmsPJ+V57PyfFaez8rzWXk+K89n5fmsPJ+V57PyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18twqz63y3CrPrfLcKs+t8twqz63y3CrPrfLcKs+t8twqz63y3CrPrfLcKs+t8twqz63y3CrPrfLcKs+t8twqz63y3CrPrfLcKs+t8twqz63y3CrPrfLcKs+t8twqz63y3CrPrfLcKs+jG8x7UCvqRaNoFmmRFa0iT4o8v6gcsxyzHLMckecjSIusaBV5UuT5RVLUinrRKCqHlkPLoeXQclg5rBxWDiuHlcPKYeWwclg5rByrHKscqxyrHKscqxyrHKscqxyrHF4OL4eXw8vh5fByeDm8HF4OT0c0kt0kRa2oF42iWaRFVrSKyiHlkHJIOaQcUg4pR+T5DLKiVeRJkecXSVEr6kWjaBaVo5WjlaOVo5ejl6OXo5ejl6OXo5ejl6OXo5djlGOUY5RjlGOUY5RjlGOUY5RjlGOWY5ZjlmOWY5ZjlmOWY5ZjlmOWQ8uh5dByaDm0HFoOLYemI7p47vfIT5ueFFu/glpRLxpFs0iLrGgVeVJs/UXl0HJoObQcWg4th5ZDy6HlsHJYOawcVg4rh5XDymHlsHJYOVY5VjlWOVY5VjlWOVY5VjlWOVY5vBxeDi+Hl8PL4eXwcng5vBx+O1p0+dwkRa2oF50OD5pFWmRFq8iTokpdJEUPhxxHYD+xBw5wggoauEAvPKtVooANxNawNWwNWyzacYzABXphLN1xo4ANDJsGDnCCChq4QC+M5TxuFLCB2AaKWM/jsBNj2Y4bI0L8trF0x40dHOAEz2ASv9u1iMeFC/TCaymPCwVsYAdP27lQRjuuRT0uVDBs8bNcS3vE8b0W94jdvJb3uFDABnZwgBE3zslrYY8LvfBalKMFemEszHGjgA3s4AAnqKCB2Lxs0aOTKGADOzjACSpo4AKxCTbBJtgEm2ATbIJNsAk2wdawNWwNW8PWsDVsDVvD1rA1bB1bx9axdWwdW8fWsXVsHVvHNrANbAPbwDawDWwD28A2sA1skYVtBHphZOGNsQ0a2MAODnCCChq4QC+MLLwRm2GLLIxlMK7Fdm6coIIGLtALY+GdGwVsILZrAR4LnKCCBi7QCyPnuwQK2MAODnCCChq4QE+8Fui5UcAGdjDitkADF+iFkd03CtjADg5wgtgEm2ATbA1bw9awNWwNW8PWsDVsDVvD1rF1bB1bx9axdWwdW8fWsXVsA9vANrANbAPbwDawDWwD28A2sU1sE9vENrFNbBPbxDaxTWyKTbEpNsWm2BSbYlNsik2xGTbDZtgMm2EzbIbNsBk2w7awLWwL28K2sC1sC9vCtrAtbI7NsTk2x+bYHJtjc2yOzcvWjwMUsIEdHOAEFTRwgdioJZ1a0qklnVrSqSWdWtKpJf2qJT1wgV541ZILBWxglHgPnKCCBi7QC6/bgwsFbGAHsXVsHVvH1rF1bAPbwDawDWwD28A2sA1sA9vANrFNbBPbxDaxTWwT28Q2sU1sik2xKTbFptgUm2JTbIpNsRk2w2bYDJthM2yGzbAZNsO2sC1sC9vCtrAtbAvbwrawLWyOzbE5Nsfm2BybY3Nsjs3LNo4DFLCBHRzgBBU0cIHYBJtgE2yCTbAJNsEm2ASbYGvYGraGrWGjlgxqyaCWjOtmRAMX6IXXzYgFCtjADg5wglEcw3bdjFy4wLCdt7fjuhm5UMDTdq6a0qIDKXGAp230QAVP2xiBC/TCqCUjdjNqyY0NDFtsQ9SSGyeooIGrMKrGiN2M+jCPwDPCjE2P+nCjgQs8t3fGDkV9uFHABnYwtncGTlDBsMVuRn240QujPsz4t1EfbmxgBwc4wdi3OAmiPty4QC+81gi9UMAGdnCAYYtDHfXhRgMX6InRjpQoYAM7OMAJhm0EGrhAL4z6cKOADexg2DxwggoauEAvjPpwo4AN7CC2hq1ha9gatoatY+vYOraOrWPr2Dq2jq1j69gGtoFtYBvYBraBbWAb2Aa2gW1im9gmtoltYpvYJraJbWKb2BSbYlNsik2xKTbFptgUm2IzbIbNsBk2w2bYDJthM2yGbWFb2Ba2hW1hW9gWtoVtYVvYHJtjc2yOzbE5Nsfm2Bybl02PAxSwgR0c4AQVNHCB2ASbYBNsgo1aotQSpZYotUSpJUotUWqJUkuUWqLUEqWWKLVEqSVKLVFqiVJLlFqi1BKllii1RKkl0RUl59pTLdqi5FwIqkVfVOICvTBqyY0CNrCDA5wgtoFtYBvYJraJLWrJudROiz6pxAFOUEErjKpxru/QogvqMeIZOMCIsAIVNHCBXhj14UYBGxi2+AGiPtw4wdNm8bNEfbhxgV4Y9cEk8IxrLXCAE1Qw4sZxiEpgscdRCSwOSVQCi+291h6PLYtKsEIcleDGAU7wtK3YsqgENy7QE6MpSs6u+Ba9UI8R2sBQaGAoLDAUHngqvAUauEAvjPS/UcAGnjaPbYj0v1HzLIl+qMQFemE7QAEb2MEBThBbwxY579dq2V4YOX9j7FD828j5Gzs4wAkqaOACvTBy/kZsA1vkfEzuRqtUYthWoIJhi18zVjGPieDojUpsYAfHiXHCxHrmNypoYNTJ68+88LpTuFDABnZwgBNU0K9+iRZ9UY+h+UABG9jBAcZOxGkWS5zfaOACvTCWOr9RwAaGbQQOcIJhi02Phc9jSjg6pVpM80ar1I2x/PmNAjawg3qvpx+9UTetIr8peqNukqT4NkDM9Ua7UuIEFTRwgV4YXwq4UcAGYmvYGraGrWFr2Bq2jq1j69g6to6tY+vYOraOrWMb2Aa2gW1gG9gGtoFtYBvYBraJbWKb2Ca2iW1im9gmtoltYlNsik2xKTbFptgUm2JTbIrNsBk2w2bYDJthM2yGzbAZtoVtYVvYFraFbWFb2Ba2hW1hc2yOzbE5Nsfm2BybY3NsXrZYsStRwAZ2cIATVNDABWITbIJNsFFLnFri1BKnlji1xKklTi1xaolTS5xa4tQSp5Y4tcSpJU4tcWqJU0ucWuLUEqeWOLXEqSVOLXFqiVNLnFri1BKnlji1xKklTi1xaolTS5xa4tQSp5Y4tcSpJU4tcWqJU0ucWuLUEqeWOLXEqSVOLXFqiVNLnFri1BKnlji1xKklTi1xaolTS5xa4tQSp5Y4tcSpJU4tcWqJU0ucWuLUEqeWOLXEqSVOLXFqiVNLnFri1BKnlji1xKklTi1xaolTS5xa4tQSp5Y4tcSpJV61pB9VS/pRtaQfVUv6UbWkH1VL+lG1pB9VS/pRtaQfVUv6cWATbIJNsAk2wSbYBJtgE2yCrWFr2Bq2hq1ha9gatoatYWvYOraOrWPr2Dq2jq1j69g6to5tYBvYBraBbWAb2Aa2gW1gG9gmtoltYpvYJraJbWKb2Ca2iU2xKTbFptgUm2JTbIpNsSk2w2bYDJthM2yGzbAZNsNm2Ba2hW1hW9gWtoVtYVvYFraFzbE5Nsfm2BybY3Nsjs2xUUuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJXCndAzs4wFCMQAUNXKAXXil94blD1/fCWlEvCpUGTlDBUK3ABca4wbkL7Ro4uFDABnZwgBNU0MAFYhNsgk2wXd8zbIEDnKCCBi7wtJ17eX3c8CIpakW9aBRFxPOXu75feDb59usLhu36HlsDOzjA2FILVNDABXphZOe1DZGdNzbwtPUjcIATPG3xhbnrC4c3nrYeOxTZeWFk541yf5cu+h5v6kWjaBZpUUSMQxS5dn+XLrZUAwc4QQVjS2MHI9du9MLItRsFbPXtu140is5Nja2KL6xdZEWryJPiK2sXhcQDG9hBBc/NHHHwI19vPA9oHNr4ntpFveg8IiOOXuTrjQqeR2TEtkS+3hiq65N+ByjgubFnn0i/vnM4LDBsK/C0nU0cPdoREw1coBdGvt4oYAOjFLXA03Y2fPRoR2xnD0GPxsM2r48QRtzYyEjNGwVsYAcHOMEIFrt5fWr0QgEb2MEBzsLrS6JxoK5viV7YwQHGn3ngeSTPyb7e80tOveennHrPbzn1nh9z6j2/5tR7fs6p9/yeU+/5Qafe84tOvecnnXqf5ZjlmOXQcmg5tBxaDi2HlkPLoeXQcmg5rBxxk6wXzvpepBZZ0Sry+pzkUSRFragXjaJy1LcN+bghXzfk84Z835APHPKFQz5xyDcO+cghXznkM4d85zA699o5Zdqjcy9xgOcZck5M9ujca+fkaI/OvaYRIbLqnGzs0XfXzgnEHn13zeLfxpXtxgWep/y54GOPvrtEARvYwQFOUMGwzcAFemEk2Ip9i1RasTmRSjeecdf1bxU0cIFefxZXvRsFbCC2gS0y8EYFF+jXp8X69SXDi6SoFfWiURTBNVBBK4ybzRtj8+IYxqVuxW8el7obFTRwgV4Yl7obBYyDEWdNPKLeOMDT5nEuxSPqjQaeNo8zLB5RL4xH1BsFbGAHBzhBBQ3EtrA5Nsfm2BybY4tLpMd5F5fIGy0xWufa+fJ9j365ds7d9uiMS4zN0cDYnPPHih64RAEjwgrs4FkfzsnFHn1t/QhbfOfzCEV86fPC+NbnjQKeVeeIbYgvft44wAkqaOAqjO/tHrG98cXdGzsYcWPT47u7Nypo4AK9ML7Ae6OA8W890Avjm7o3CtjADp5bdr6b2qNPLFFBAxfohfGd3Xjyij6xxAZ2MGzxu8XFKJ7HoiOsx4NVdITdGNejGwVsYAcHGHsRv3FclW40MGzxu8WF6cK4Mt0Ytjg6cW26sYMDnKCCBi7wtLXzmEVHWI8nI72+d90DFTRwFV5fuR6BDezgACeooIELjC07j070cyUK2MAOhkIDFYxg52kfLVg9HpWi2aqfHeU9mq16PB9Fs9WN52Unbk6j1+qmVtSLRtEs0iIrWkUhOc+/6LFKFLCBHRzgBBW0wsi4eP6KHqsezxXRYxU32dFidZMWWdEq8qTIqnj8ie6qxAZ2cIATjMMcwSJ/4uEulpJKPC+0sc3xodyLZpEWWdEqimMav2xkzo0CNrCDA4yjd54Q0RXV40Et1oqKO/roj7qpF50H1IJmkRZZ0SrypPhMdWx89EUlNnCC8TjaA70wUuPGczM1qBX1olE0i7QonnpH4AK9MC5YNwrYwA4OcIIKYuvYIu/iyTQanhIFDFsc9LiM3Ri2+M3iMjbjN4vLWDxtRsNT4gJPW+RitEElnrY42aMNql9HJz5dFmHj22UXzSItsqKVFBe769eOy9p10sRl7f4HChp4bmk8NUWr042RgDcK2MCIGzsYqRaPGdG/1OPZIvqXEgVsYAcHOEEFDQxbHLhIwwsjDW8MWxzOSMMbOzjAsMUxiwvYjQaehzd2Lb5bdtL18cCLHqo4BtfnAy/qRaNoFmlRSFbgAr0wUvbGDsZmeqCBZ4R4eov+qBsjZW+U6ytnvT4a2Ourgb0+G9jru4G9PhzY68uBvT4d2Ovbgb0+Htjr64G9Ph/Y6/uBvT4g2OsLgr0+IdjrG4K9PiLY6yuCvT4j2Os7gr0+JNjrS4I9GqH62SbboxEqUcHzkFn8dpGhN3phZGg8YUYjVOJ5Hlkc/7hE3jjACSoYtviB4lb1xtO24leJC+eKLYvsXXFmxK3qjR08bfHAG41QiQra9Sm5fn158CJPim8PXiRFrSgijsBzS+OxONqaejxWRltTooANjC2N3Y5svnGCChr4sF1naK6h3leux9ajIykemqIh6Sa/KdqRHiMpgQI2sIMDnKCCBi7QCwWbYBNsgi1uRON5MdqREhU0cIFeGKuwjaBW1Isifg+coIIGLtAL4yp7Hca4yt7YwNgbDRyg3j+S5zLp3XOZ9B4tRzH0EB1HN0lRBL+wgwOcoIIGxq6sQC+MlL3xPGpHUCvqRaNoFmmRFa0iT8r1VbtrObQcWg4th5ZDy6Hl0HJoOawcVg4rR9zxnu3WPTqLEid43rIe1781cIFeeKZzooAN7OAAJ4htYYtb5CNyYHmhH6CADezgACeoYNgiSXyBfuO4FjvrQVLUinrRKJpFETFQYktHYGzpDOzgACcYW2qBBi7QC9sBhs0DG9jBAU5QQQMXGOPkcmKPgfI4RD1G42N7ewM7OMAJKmjgAr1wHCC2gW1gG9gGtoFtYBvYBraJbWKb2Ca2iW1im9gmtoltYlNsik2xKTbFptgUm2JTbIrNsBk2w2bYDJthM2yGzbAZtoVtYVvYFraFbWFb2Ba2hW1hc2xRGc4hqBF9QolhixSJynDjBBWMJ/UjcIGeGH1CiQI2sIMDjFEBCVQwFC3QC+UABQxFD+zgACeoWXfkKiAXLtALrwJyoYAN7OAA7brpGtfnDy/ypPgsWvy7+CzaRa0otv/CAU5QQQMXeJriEMbH0S6SojhUM7CDA5zXF8ZGfQdx1HcQR30HcdR3EEd9B3HUdxBHfQdx1HcQR30HcdR3EEd9B3HUdxBHfQdxyCyHlkPLoeXQcmg5tBxajqgF5zjiiD6fRC+MWtDi30YtuLGBHRzgBBU0cIFhWydGLbhRwIdtxZkSn1G6aBTNIi2ypMj3cxx0RMPQ6Nd/e25pj58/MvtGBQ08t7RHpkRmB0bHUKKADQzbCBzgBPX6PNVo+VG00fKjaKPlR9FGy4+ijZYfRRstP4o2Wn4UbbT8KNpo+VG00aQcUg4ph5SjlaOVo5WjlaOVI24JztHOESupjXOQcUTrUOICvTBuCW4UsIEdHOAEsXVsHVvHFrcE55jniIaixAZ2cIATPOOek/0jWoOinkRr0E3nH434vePKfqOCBi7QC+PKfqOA5yaOUMSV/cYBhi0Of1zZbzRwgWE7szl6hsbZFjOiaShxgBOMuHEUIm/PwccRnUNjxgGJvJ2xvZG3M7Ys8naGOK7hN3ZwgKdtxpbFNfxGAxcYtvhZ48KtsTlx4dbYnEhvjZMz0ltjcyK9NXYo0vtGAxfoidFglChg2FZgB2eeI9FVlGjgqYhLXXQV3RgX7htPRVyNoqsosYMDnKCCBi7QC+PCfSO2hi0u3HHFjV6jxLD1QAXDdh7qaDsa55jViLajxAZ2MOJq4AQVNHBlse5XQgdeCX2hgA3s4AAnGEcnfs24m78w7uZvFDD2In7juJu/cYAT1HsQa0SHUuICvfAahLtQwAZ2MI6OBxq4QC+Ma/WNAp57ERfDWK0scYATVPCMu+LUiDyOsh9tSWPFSRB5fOMEI0KcO5HHN57be+1Q5PGFcW2+8dzeFb98pPSNHRzgBBU0MGzxE0ZKB8YKZIkCNrCD4x7oHtGxdB2HWGsssY5O9DGNc2xxxFpjiQ3s4LkX5+jKiJ6nRAVP2zkgN6LnKdELI49j6CB6nhIbGLbY9Mjjc/xuRM/TOMfZRvQ8jXNwbUTPU+IqjDz2OA6Rxzd2cIARN/YtMjbOkuhuujEy9kYBOxjTCxcauMCYoIh9i4G3GwVsYAcHOEEFrTAuwh7HLC7CNzawg+dk4xE/Vswy36iggTEnF0cnZroujJmuGwVsYAcHOEEFY2YxDtQ6wHO+9IjT80zexA4OMPbi+jMFDVygF57JmxjzmHEkY/7rxg4OcIIKGrjAnAse8zjA2IsLBzhBBWMvRuACvVAOMPbiCGxgBwc4QQUNXIUxdx1DdbHkV2IHBxh7oYEKGrhAL+wHKGADw2aBA5yggmFbgQv0wugcuTEbHcbViHVjBwc4QQUNXKAXXs0iLTD2wgMHOMFzLySO+pndU+IkOC/CiV545nyigA3s4ABPm8QJE20kMZR0NWLFc1+0XM0YSoqluRIVNDAixFE3L1wHKGADOzjAWdsQM183GrhAL7zaSS5kL652kgs7GHsRv7zHXsRR9wV6YrRcJZ57ESNbsQhXYgfPvYhBrmjPSlTQwAV6YeTxjWFrgQ3sYNh64AQVNHCBXtgOMGwjsIEdDNsMnKCCBi7QCyO7bwybBjawg2FbgactbnpjEa4ZoxnRFzYjnaIvLNELI7tvPG0xWHF1hsXj/tUaFrl59YbdOEEFwxabE/1h8VAdDWIzimM0iCUK2MDYNwsc4AQVzJ63EV8sTPTCuPG+UcAGdnCAE4wutziS0Tt2oR2ggLEXcSStgwOcoIIGLtALoz7cGHHjRIxKcOMEI278hHFFv3GBXhhX9BsjbvzckfMxehAtZIkL9MRoLEuUu+d42NWUfGEHBzhBBQ1coBdGdsdYRayxlTjACcZenCfi1UsW4xpXM9mNHYw2wiNwggpG1+D5G0fv2IwxkOgdmzEGEr1j93GI3LxxgBNUsI5vdInNGCSJLrHEBnZw3A34w66XAi5U0MAFemG8CnejgA0840byXsti3WhgtFRe/9YL4xo74x/ENfbGBkYPXxzUuMbeOMFo42uBBi7QCyMLb4x+wTg6kYU3dnCAE1TQwFUY12ONXyjeB4gaFb1iM0aIolcs0Qsjs2KwKHrFEmPL4jhEvt04wGi6DEVk4Y0GLtATo1ssUcDTFkM90TCWOMAJKmjgyj2OzwLOGACK7wImdnCAEbcHKmjgAs9zMi4z11JbNwrYwA4OcIIKxtE5czO6xxIFbGDsRfxZZOyNE1TwzIB2/dkCvfB6pfVCARvYwVEYvZiRetHolaiggQv0wjP1EgVsYAexKTYN2wo0cIFeGL1eNwp4xo1xjWj3SlTQwAV64YoesjgkS8AGdjBs8bOsCWqhHxXXBWxgB9l0Z9Ndy+YGLtATo1fsEkevWGIrjHmYGKiJNqwbYybmxnMqJsTRkrXOTq8RPVmJA5zgOecTg0XRlJW4QC/sEbcHRoTY9Oi5utFAr38bzVbXXkS31Y0N7OAAJ6hgKCxwgV44w7YCBWxg2DRwgBNUkB2aC/RCPUABG9jBAXL4lMN39UDGXlxNkBc2sIMDnKCCBi7QCxe2hW1hW9gWtoVtYVvYFraF7UqnOKhXOl3YwA4OcIIKGrhAv3EexwEK2MAODnCCChq4QGyCTbAJNsEm2ASbYBNsgk2wNWwNW8PWsDVsDVvD1rA1bA1bx9axdWwdW8fWsXVsHVvH1rENbAPbwDawDWwD28A2sA1sA9vENrFNbBPbxDaxTWwT28Q2sSk2xabYFJtiU2yKTbEpNsVm2AybYTNshs2wGTbDZtgM28K2sC1sC9vCtrAtbAvbwrawOTbH5tgcm2NzbI7NsTk2aolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSuWrICo7tPAr3wrCWJAjawgwOcoIIGYlvYHJtjc2yOzbE5Ng9bCzRwgZ4YfWCJAoZtBHZwgGGzwLCtQAMX6IVygAI2sIMDnCA2wSbYBFvD1rA1bA1bw9awNWwNW8PWsHVsHVvH1rF1bB1bx9axdWwd28A2sA1sA9vANrANbAPbwDawTWwT28Q2sU1sE9vENrFNbBObYlNsik2xKTbFptgUm2JTbIbNsBk2w2bYDJthM2yGzbAtbAvbwrawLWwL28K2sC1sC5tjc2yOzbE5Nsfm2BybY/Oy9eMABWxgBwc4QQUNXCA2akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5YMasmglgxqyaCWDGrJoJYMakn0wNnZVzGjBy7RC6OW3ChgAzt42s4Oihk9cIkKxr5ZYNgu9MKoJTcK2MAODnCCsW8aaOACvfCqJRcK2MAODnCC2Dq2jq1jG9gGtoFtYBvYBraBbWAb2Aa2iW1im9gmtoltYpvYJraJbWJTbIpNsSk2xabYFJtiU2yKzbAZNsNm2AybYTNshs2wGbaFbWFb2Ba2hW1hW9gWtoVtYXNsjs2xOTbH5tgcm2NzbF62eRyggA3s4AAnqKCBC8Qm2ASbYBNsgk2wCTbBJtgEW8PWsDVsDVvD1rBRSya1ZFJLJrVkUksmtWRSSya1ZFJLJrVkUksmtWRSSya1ZFJLJrVkUksmtWRSSya1ZFJLolHvKtDRqJfohbOqcqyYltjA2LL4t1fO98AODnCCChq4QC+8cv5CAbEZNsNm2AybYTNshm1hW9gWtoVtYVvYFraFbWFb2BybY3Nsjs2xOTbH5tgcm5dNjwMUsIEdHOAEFTRwgdgEm2ATbIJNsAk2wSbYBJtga9gatoatYWvYGraGrWFr2Bq2jq1j69g6tsj5s8FyRvuenR2NM9r3Eg1coBdGzt8oYAM7OEBsA9vANrBFzp+tlDPa9xIFbGAHBxh3Yh6ooBVetwcjsIEdHOAEFYxNv3CBXhil4uyqnNGzl9jA2HQLHOAEFTRwgV4YpeJGARsYttj5KBU3TlBBAxfohVEqztbPGUvEJTawgwOcoIIGnrYehy9KRWB0/SUK2MAODnCCChq4QGyCTbAJNsEm2ASbYBNsgk2wRak4e4hm9A0mNnCCEUEDvTDS/0YBG9jBAU5QQQPD5oFeGOl/o4AN7OAAT9vZMTqjbzDRwNM2Qhzpf2Gk/40CNrCDA8Q2sU1s8fgwYsvipuHCeHy48fxvz2bMGV1/iQLWg64xZGAMGRhDBsaQgTFkYAwZGEMGxpCBMWRgDBkYQwbGkIExZGAMGRhDBsaQgTFkYAwZGEMGxpCBMWRgDBkYQwbGkIExZBB9g3Y2sM7oG7ww+gYTBWxgBwc4wdN2dsPO6BtMXKAXRh7fKGDYRmAHBzhBBQ1coBdGHt8oILZWAxTrGjK4cIJhm4EGLtALI+dvFLCBHYx9W4ETVNDABXph5PyNAjawg9gGtoFtYBvYBraJbWKL7D57eme0JprGMYs81ji+kccXRh7fKGADOzjACSpoIDbFZtgMm2EzbIbNsBk2w2bYDFvUB40fNurDjQ2cYETQQC+MnL9RwAZ2cIATVNDAsMWPFTkfGF2KiQI2sIMDnGDYPNDABdYjol/DhBcKeNrOJuUZK9olDnCCChq4QC+MnD/7ime0UiY2sIMDnKCCBi7QCzu2jq1j69g6to6tY+vYIrstDlTk8dl4PKOr0iyO77U8zYUKGrhAL7zWqLlQwAZ2ENvENrFNbBPbxKbYFJtiU2yKTbFFzq/4YSPnb1yFkd03nhHOt7NntFImKmjgAr0w8vhGARvYwbDFjxV5vOLHijy+UcAGdnCAE1TQwNjeOAkij0/UaI9MFLCBHRzgBMPmgQYu0Asjj28UsIEdHOAEsQk2wSbYGraGrWFr2Bq2hq1ha9gij8/+ao32yBsjj2/s4Bnh7K/WaHlMXKAXRsbeKGADOzjACYatBxq4QC+MPD67jTVaHhMb2MEBTlBBAxcYtjhLIo9vFLCBHRzgBBUMW/wWkcc3emFcu28UsIEdHOAEFcRm2AzbwrawLWwL28K2sC1sC9vCdtaHdcQZddaHRAEHeHaqH3E+nDmf6InRxpgoYAM7OMAJKhhxzzMqmhDXOYqi0YSYqKCBC/TCeInhRgEbGFs2Awc4QQUNXKAX9gMMmwc2sIMDnKCCBi7QC+PdhxuxDWwD28A2sA1sA9vANrBNbBPbxBbvPpxPKBpNiIkTXIXxPoPEzx3vM9zYwQFOUEEDF+iFZ8Ymhi3OKGtgBwcYtjg1TEEDF+iF6wAFbGAHwxZnSawYd6OCBi7QCyNjbxQwbPFbeAcHOEEFDVygJ0ZjYaKADezgACeooIELxCbYBJtgE2zXQnNH4AQV9MJrETkJ7OAAJ6iggQv0wsj5GwWMuC1wggoauEAvjOy+UcAGdhDbwDawDWwD28A2sU1skd3nILVGW2DiACeooIEL9MJ4s+nGsFlg2GZgBwc4QQUNXKAXRiW4MacD9WoLvLGDYVuBE1TQwAV6YVSCGwU8963HQY1KcOMAJ6iggQv0wqgENwqIzbE5Nsfm2BybY/OyRVtgooAN7GDYeuAEFfTCyO5zmFuj1S9xgBNU0MAFemFc/W+UwrgenwPlGs13iQMMmwYqaOACvTAy9kYBG9jBAaKI1OsW2MAOxp+twAkqaOACvTBS70YBG9hBFJFD5wi9RjtcYgPPPztfydZoh0ucoIIGLtALI4duFLCBKCIZzmUuNPraEgWMP4tzMpLhxgFOUEEDF+iJ0deWKGAH4896oBfG9e3G+LMR2MAODnCCChq4QC+MDLgRRVzqzkU1NPrPEg2MYBrohXGpu1HABnZwgBNU0EBskTjnQhkanWbrXChDo9MscYATVNDABcYAUOzbNdx0oYAN7OAAJ6hgHJ0zA6KnLFHAcy/OmSCNnrLEAU5QQQMX6IWRkDcKiC1S75wM0egeWzPOyUi9GxfohZF6NwrYwBiGDUU8et44QQUNXKAXXkPMF8bUwIUDnGBOIOmoCSQd1XOqo3pOdVbPqc7qOdVZPac6q+dUZ/Wc6qyeU53Vc6qz+td1Vv+6zgObYBNsgk2wCTbBJtgEm2ATbA1bw9awNWwNW8vJMb36xG40cIFe2A9QwAbG79YDBzhBBQ1cYE6O6dUndqOADezgACeooIELxDazV1jvPrELG5iTYzqvaaULJ6iggQv0Qj3AnK7Sq//sxg4OcIIKGrhAL7QDxGbYDJthM2yGzbAZthiaOmfadFIJrp4yjeO7FDRwgV7oByhgAzs4QGyOzbE5Ni/b1VN2o4AN7OAAJ6hg2GbgAr1QGpiTY3r1id1o4AK9sB2ggA3s4ABzckyvPrEbDVygF/YDFLCBYfPAAU4we+j16hO7cYE5OaZXn9iNAjawgwOcoII5XaVXn9iNXjgPUMAGdnCAE1QQ28Q2sSk2xabYFJtii+y2OFBWdytXc5jF8bUGdnCAE1TQwAV64TpAbAvbwrawLWwL28K2sC1sjs2xObZrYip+2Gti6sIJ5qSbXg1f5zSYXg1fN3ZwgBNU0MAFeqEcYNh6YE6O6dXEdeMCvbAdoIAN7OAAa3LMrgmkCw1cYE3FXQ1fNwrYwJquuhq+bpygggYusCbHroavGwVsILaBbWAb2Aa2gW1gm9gmtoltYpvYrsmmOGGuyaYLrVAPsCbHTAc4QQUNXGBNxV3NYTcK2MCwxRl1TSBdOEEFa3Lsag670QvXAQrYwA4OcII1OXY1h924wJqKu5rDbhSwgR2s6aqrOexGBQ1cYE2OXc1hNwrYwA4OcIIKGrhAbIJNsAk2wSbYBNs1XXUEGrgKm4A1ObbaBBU0cIE1Fbf6AQrYwA5G3POMWqMmx9ZoYAcHOEEFDVxgTcWtWZNj65pAurCBHRzgBBU0sKarorXrRj1AARvYwQFOUEEDsSk2w2bYDJthM2yGzbAZNsNm2K7JpjhhrsmmCxs4wZocW6smx5YfoIAN7OAAJ6iggWGLM+qaQDrRrwmkCwWsyTE/OjjACSpo4AJrKs7lAGtyzK8JpAs7OMAJKmjgAmu66lol70YBG9jBAU5QQQMXiK1j69g6to6tY+vYOraOrWPr2Aa2awrqCGxgBxWsybFrwbwbBWxgBwc4QQUNrKm4a2m8mK66lsa7sYMDnKCCBi6wJsfcDhCbYTNshs2wGTbDZtisJsd8HaCADezgACeooIFhs8CaHIvmsEQBG9jBAU5QQQPjWS9sce0+0a7msBtzcsyiOSyxgwOcoIIGLjCnqyyawxIFbGAHBzhBBQ1cILaGrWFr2Bq2hq1ha9gatoatYevYohKcE2l2XFNbF3ZQwZwcs2McoIAN7OAAJ6iggaswsnteOMAJKmjgAr0wrug3CthAbIpNsSk2xabYFJthM2yGzbBFzp/fBrPjGnW/UEEDF+iF16j7hQI2MGxxgkfO3zjBsHmggQv0wsj5GwVsYAdPm8a5Ezl/o4IGLtATr+awGwVsYAcHOEEFDVwgNsEm2ASbYBNsgi1y/hzZs6u97MZVGNl9Y0SYgRNU0MAFemHk8Y0CNrCDYbPACSpo4AK9MHL+RgEbGDYPHOAET9s51mZXy9iNC/TCuPrfKGADO3jaLA5q1IcbFTRwgV4Y9eFGARvYQWyKTbEpNsWm2AybYTNshs2wGbaoDxY/bNSHG1dhVIIbI4IGTlBBAxfohZHzNwrYwA6GLc6HyG6LXz6y+8Yz7jnsZldz2I0CnnHPkTK7msNuHOAEFTRwgV4Y2X2jgNgEm2ATbIJNsAk2wdawNWwNW8PWsDVsUQnOr4vZ1Uh24wK9MCrBjQLGZN4MjD/rgV4YKX1j/NkIbGAHBzhBBQ1coBdGSt+IInJzxUZGbt7ohZGb5yfx7Gr4urGBHRzgBBU0cIFeaCgiyXpsQyTZjQvM/h27OrduFLCBHRzgBBU0cBU6iqsFywIVNDD7d+xuwTrxbsG6UMAGdnCAE1TQQBTXrbAHTlDB7N+xq+/qRi9sByhgAzs4wAkqiOLqL5HAAU4w+3fsate6cYFeOA5QwAZ2cIATRBHJcHb12NWudeMAs3/HrnatGw1coBfqAQrYwA4OEEXkxdnVY1cT140CZv+O3U1cFw5wggoauEAvXAcoILZInLPXx2L1sujUsVi9LHGBXnh1eV0oYAOzf8eu1ctunKCCBi4wu4XsWr3sxjg6HjjACWb/jsU6ZYkL9EI5QAEb2MEBThBbpN7ZjmFXw9fZqWOxIlliAzs4wAkqmP07dq1IdqMX9gMUsIEdHGDU6vOXH9fl60IB48qwAjs4wAkqaOACvfC6fF0oIIrzjPIYoIg1rBI7OE6Mn/s8oxIVNHCBnhi9SYkCNrCDA5xg2aLfyM9hN4vOIj/HxCzaifK/PTfnHGOyaCfy81txFu1EN54nTKKADezgAM/NOQeWLNqJEg0M2wwM25nz0U7k5yCURTuRx5hNtBPdm947yA6dFdyPEJ/nzo3nuZMoYAM7OMAJKmhg2GIvRthiL+YBCtjAsMVuzgFOUEEDF+iFeoARN46ZRoQ4Zhp/FieBxskVP7cdoIANnGCcnnF8zQtXRIgTZsWJGIdkxb+NQ7K80A8wbHEcrsS5sIMDjG2IfbsS50LjHyzQE/VKnAslj0M07SR2cICWexztOdduRnvOjXIUXl+L8cABTjB+gOvfGrjA+AnPw6fXCXOhFMaS6VG2Y72gRD0xIsSS6Tcu0AtjyfQo0NESktjADg5wggoauEAvXNji6wpnz55Fx0eiggYu0Avj6wo3CtjADmKLryvEWFssB5Ro4AI9MZYDShSwgR0c4AQVLFss5qMxWBSL+ahe/62CBi7w3LIYyYk+kEQBG9jBAU5QQQMXiK1j69g6to6tY4tvI5yNZBZ9IIl+fnMsMD4NeKOADewnWuAAJ6ignbgCF+iF8YHOGwVsYAcHOEEFsU1sE5tii08DxsDH9RHAGOK4vvwXT/nXl/8ujC//3ShgAzs4wHMj44H/+vLfjQYu0Gsb4vubNwrYwA4OcILsUHw78MIrNy9s4HmW3P9ggBNUsIqY+QKrrKzjAAVsYAcHOEEFDVwgNsEm2CJ546BGD0ZiAzs4wKc/U9DABXphZOGN2Dq2jq1j69g6to6tY+vYBraBbWAb2Aa2gW1gG9gGtoFtYpvYJraJbWKb2Ca2iW1im9gUm2JTbIpNsSk2xabYFJtiM2yGzbAZNsNm2AybYTNshm1hW9gWtoVtYVvYFraFbWFb2BybY3Nsjs2xOTbH5tgcm5ft+hDhjQI2sIMDnKCCBi4Qm2ATbIJNsAk2ikL0gSRiE2yCrWGjlji1xKklTi1xaolTS5xa4tQSp5Y4tcSpJU4tcWqJU0ucWuLUEqeWOLXEqSVOLXFqiVNLnFri1BKnlji1xKklTi1xaolTS5xa4tQSp5Y4tcSpJU4tcWqJU0ucWuLUEqeWOLXEqSVOLXFqiVNLnFri1BKnlji1xKklTi1xaolTS5xa4tQSp5ZcX2GMsfjrK4wXXrXkQgEb2MEBTlBBA7EtbI7NsTk2x+bYHJtj87StaP6YNypo4AK9UA4w7o1mYAPj3kgDBxg2C1QwbCtwgV7YwuaBAp62s5l4RfNH4mk7m35XNH8knrbzW6grmj8SF3jazv7fFc0fiafNYzfjy8E3hi12M74cfGPYYjfjy8E3Ghi22OO4zb8wbvM9djNu828MW+xm3ObfeP6wR+xmpP+NCp4/7BF7HOl/43kaHbGRkf43CtjADg5wggoauEBsik2xKTbFptgUm2JTbIpNsRk2w2bYDJthM2yGzbBF+h/xs0T6Xxjpf6OADezgACeooIHYFjbH5tgcm2NzbI4tbhrOEa11fQzxHLNZ18cQzzGmdX0M8cYBTlBBAxfohXF7cKOA2ASbYBNsgk2wCTbB1rA1bA1bw9awxe3BOeS1ro8h3miFcSNwY0TQwAFOUEEDF+iFccm/UcAGhs0CBzhBBQ1coBdGzt8oYNjifIicv3GAE1TQwAV6YeR8i5Mrcv7GBnZwgBNU0MDT1uJ3i5y/MHL+RgEb2MEBTlBBA7EZtoVtYVvYFraFbWFb2Ba2hW1hi5xvcfZFzt/YwAlGhDh34pEgMNpHEgVsYAcHOEEFDTxt51LhK9pHboyc7xJ42s7+yRXtI4mn7exdXNE+kjhBBQ1coBdGzt8oYAOxNWwNW8PWsDVsDVvH1rF1bB1b1IceByrqw40KGrhAL4z6cKOADexg2CxwggoauEAvjJwf8btFzt+ooIEL9MLI+RG/ceT8hZGb5/z8ip6RxFYYp/2IYxan/YVx2t8YfzYDG9jBAU5QQQMX6InR8ZHYwAimgQoaGMEs0AsjA24UsIEdHOAEFTQQW5zr50z8io4PPefGV3R8JA5wggoauMCo4Gce9+uqd6GADezgACeohXEqn+/drugDUYu9iFP5xg4OcIIKGrhAL4xL3Y3YJraJbWKb2Ca2iW1im9gUm2JTbHGps/ix4lJ34wQVNHCBXhjpdKOADcRm2AybYTNshs2wLWwL28K2sC1sC9vCtrAtbAubY3Nsji1y3uJMjZy/cYIKGrhAT4yuk0QBGxjj4DMwxsE10MAFeuE1Dn5hjINbYIyvr8AJKmjgAr0wLnU3RtzYyEj/Gzs4wAkqaGDMZx2BXnjNZ10oYAM7OMAJxpSZBC7QC6Mo3ChgAzs4wAkqiG1gi6Kg53Uo2lISBWxgBwc4QX6syY81+bEmP1Ykg8YvH6e9Xv/tAr0wTvsbpU65a1Lowg4OkNPzmrC90MAFeuK8JoUuFLCBHRzgBC33Ldbq0bNpfUWXTGLLHYpVeRIHOMHI2CPQwAVGxp6/ZrTRJAqIrWFr2Bq2a0b3QgMXWD/L7AcoILbrtF//9V//9Ie//v1f/vTvf/n73/753//x5z//4Y//Wf/Fv/3hj//jP//wr3/6x5//9u9/+OPf/uOvf/2nP/w/f/rrf8Q/+rd//dPf4j///U//ePyvj93989/+9+M/HwH/z1/++ueT/uuf+Ovj4z99PKCfdyTx548n9GNWCF8/xJCPY9jKCI+xovp7nT/8ffv47+f5DBJ/Pye78HjKfXUDoif32oDpH23A+Pjvx9k5G38/Hr/KOxtwDmVeG+Drow3Qj/8+Rori7x9PSO9sQDSRRYDHNMJHG7A2G7DyHLLj459gdx49Lqa5CY9BCZEPz6NNkBZtOhHjcd/8dCCO4+UYj3tvrRhuTzH66zHkyN/zcZfsH8fomwMSTQnX8Xg8vz7FsB9j7M7LVYkx+FUfAzKvb8Wq3HoMLqyPt2Jzcp4fM8vN0NUrxhyvh7AqMucXnj4MsTlD2zz3M0I8HijlwxC+ydKZ+/GY9OVQ9B9P0LY7QaUqzWPcgY0Y7ccQm0xti1P8wwC/OJbCsVwfHYi2PSusav5jevDDs6Jtzs3HCGGd39Pah5sxdum+vI5FPz7eDN1tho3aDHnalfXT5cd21Xf9d9V3vb4nj6KT58Xjyf3jNGubs/MxTN3qV3kM3j3ti/yY8P34+vHo8uXjsduXxxhgnqSPIfWnu4Lf7EvfZZu1yrb1VIbXj0e1784xOyqGNU5T/cS+9LVqX8bY/C6b87RpXZaa6lMx9x8zv9vustRWnWXzOcZP27Epo71bnamPp+KPY+y2o41Zl8f18XaMzXn6eNzI7Xg8WPiHMfa/jB6cZfacdz/9MqPtcterIrfnX+bnGLszlfunx3b4xzF2Z2o7sho+hqHtvRij10VyrI/P1LG7Fx2ZMI9HtYrwGEn6McLm/HDy5Xg6GL8JsbsflUUNenoo+E2M3elxviicG3K+QvthlLk5UZV70nPBmaci9GOI3dNBG/V40LR9FGJ7PFpdYM515z/ek+1VX+vsOHl8fFR3p7rVzjzw43TZJu6jCtXDwmOstn0YZe4u/Y9rWu3P45pwfFDcp/2ul4fHuN7kwWd8nLjTf9dL7oiR+Hs7dJP8urs77ZYb8phQevp114/nqravHtPtVgypcvoY7PtwK7a3ZF2fLnT64S3Z2U3/YQzlBtWenqvl8JdjPMZD82g8xjj14xj29Zs6Xb/rTe446sl6PGf+J54aHslOjM2vYrKr63WKPt0kt/XjjZRtztBVj/ePcf2PI/TdJS53w/3jCNsjMY86P5fKx0di7m6AatzpUVKfbrKPH/PEdLcdUr/IXMdbMR6TAs453j6Osb5+jtuXq+j2iPZ6uBZ9fgT7aU+WbG/kqF7946OxPTsWt+nexnu55r1u0319/JS/xldzbc2v5trS3zXX3HMjHhNnHw80rN34kzWuaj/kyU+DrLsBKOncCB76Vgw/NHPND/cPY7h8Pde8/Z7Xk8fEZf6wj3lJfescHzzwDNsMIe0H1A4G1J5+lZ9HFncDxq1XEX3cQX04YOy2vdk46mbDPz45tjGW1nYsly/H8KO9GePoFUM+ThY55KuVQ4721dKxD6GVKsfT0fg5xvZoxOoE99F4fkD4zdGYXx+F38Z49UzfxmjEeBqm+FyM16YDDt8OdSjPCO/GqAG1Rwx9L8askc429ePfRba1tO4Yzg8hvxXj/Cz1KzH2+/LaHItsr/c1GTz8w0mWfYiX5mlE7MsTNbKdcXpppma7FYczgP2Ubz/H2E05xephVwmT9vHB2E05PcZGaojz8Qj9tDPN7d2z48OJJ9nNPJlmCLOPj8cvascr01/S5jcU5F2QcbR66DmWb4JsL/rMNOvz/cvPc7zbLZEqhY/RhrHZEv/y1XY39/Ti1Xa/K4yWiGwO6nY7Xrtk7zdE+XXteZ7kNxsyvn5M55eP6TbEdxyOVRnzmFfYHY711eTfbcaUeqSdMjdn+tjerHtNo/WnK6V+IkSvh7Den4bjfw7Rdmd6bcXj6efDEK8ejba5U98HsRqHmmabjBtz93BcwxUPXB8ej/n1Z1IZX57J34eo6Q19um/4XAhlBm1tQuyOxpSaVJjPI3trfuaQMpg1n4evfw4yN+fpY4KaQUZv/t6ZGh8fuE4yn+vjk2yO7ZRx5f7zEZGfQsyvTk1st2Ly+DPWZit2IWoub67NjmwPqHteF84PE7+X+ufHSetcf7d+aK/hgvPLiB8H0a8/6uvXH/W1/b4XSqXt7/w44eZwbLPfa/zkwU/V8BM597jGSl1ud/enup0f1Ulh3/T+bWPwFLQ2T6a6bTmp5ojeNqMOv4hxfDnGkHooHO14L0bn/mPIxzF2809PT/uPUmBvxXh11OHF7djG2B/Tar9+TA9+POpg9g3Hw37vfbGn+c315RjPZflz51irJ9wpHx+PtbvyMyAtNjZjD9sNMUZRnp+jfrMh4+s/7i7Gqyf7i9vx/gnC8EXfFcPdVNRjlIa+l+dBg0/9MPHhoZwq+PhM9V0TXz06jLY5P7ZTURTD87WBCtJ/fvdhux39qGf1tTkc+0tu5/nD54f3hj72QdpTEH0nyIsPhr/amde2Y/cUE9/+uO4f+rGZw/HdGOpBU+NzB95vxre2z1M186HP3aafeiTjTndtHgz16/Me6+tTFuvrMxbryxMWbTcI+2I13cZ4tZr6V+cati90vDZC33bj4q+N0Lfd/PEnRuhffkXm4zdDdtNIL43RtW9442j7YsiqC1zzH0aBf4qxm0V6bZhvH+KlYb62mwJ6rZrvD0bdyjXfvSUjXx7db+3Lo/v7EK89YLcvD8+1L4/Obd85enFwbv/e0mtjc20b5MWxud28z7TOvfXTZrwcQERrPOvBT9PGv2kJ34V5MV23IV5L192rT6+l627y6bWh8O3rVy+d4tsIL53i29fIXjzF96+ivXiK7941evUU375H1mpaoLX23E5ur8eYo5o6f3hLfX3iDb8WNfral/b8WstvMmXIlzNlG+K1TNm9B/Lihe31w6EfF479i3XcEevzzOTPL9a9HMO+HuN5tOQzL/gdWiOUh25eitu+9rTs6Vby4zf82u6tJ+451pA3Q9R6AGvamyEG6zqsL4fQ/t4BbbPzwPTc3f65IFwWVOabP62TML75XbZT11qPK+frLW/FeDzH8k7L5hR78QXQx0Dpx7/uyy+z7mK8+mKufZy3Tb/61LTdCqPRfh19sxWbJwXvdan0x9Dchzdz21eeOq889eflM35+JX+3M/7UOfc8r/hzjN11X55eq3sMeK6P9mZ7VFc18bT1fLn9TF1f9dDyQP34l9le6WZ1asgPnZW/ufDvXnxyXpo8nkcafnq+374gHB2P93jH5l3Ftpv0WTX3/ENv988HZPv+FCPYx7E2MXaDUK+9mdt2by69+Grudl/kqOYGOcbugOzG9F1rHNx9UwB27z+9WgDW8fUCsH0D6sUCsJ19erUA7H+bXle7x0xDe+9k/TGIfxhk/3Z/rZnwmHv++M5/H6MO6+Mhdr0Xo1dzdfth/YefY9juzq7uqdZ7r/c/ZnzrtZ3xtCefifEY7KxZQVkfv8zefPukXFNHD5T3gpzf8q2Zkqe+s08GqcWezq+dvhlk1KTe+XXPN4OsmiCw55vmT/04o+Z95nOPw6diGMtfPQ+Jfy5GPVHN1XYnyXa5goOVeR4PZh8fkn7sxkMac78PVtmE2c2Yzsm8/NTjeHtrWA3isTW+CbOrjWNNJnCXrXcPMWvbPHi+e8Y8vxtg78VwuvP8abrxU6uXHHXmqsh726FST64quyz0L9/dbB85dXbWsZtPQT61FMtjiJj3qh+Z+GYUZSxQ7bA3o1hjj2zou1FqPuTBm4K9j7JqIvXBIu9uy9PRXfLx0e27qapP1KfdLORZn1gZ7nlS4dNhXixzv9ipV8vc9hWqsVhqamwP8S/CvFgtf/F7z6dzT98+9+oduQfPd7PJn1ZMcB3vRmGpJnXz96JYk6oPD57vRmFZIWvr4xNvt9jS9yzYZMzCLJvyZpRV92IPluPNKP60Lb65Vd4vHmWsk7YZBtnHcBagen5P/jMx1mC4bX78FLQf1HGuI+25L/G3axx++ZWVfYjXJgz7lyfFf7EaF/X6MQArH03U7ealnCUhXD6cl9qHaPWKhz8emN+Zl+pTWJ1sbh7W91HU63h0k4+j9PHlLpZ9iJcm+/r4ehfL64ejvX1Qubd4RNE3o1jN6Dx4biYe55fnYfchXvtp5u87D/vj4djMw/7qp1lPUTZr+vlXS9k2wmvtPduV9HoNCj14c4npuw15sRFkbm9FlHkD0/FmEHu6n7HnBfI/FaQmqOT8MPk759kYxBizfbwosG5vob9lncPmDKX+MFK+3ovxPB/zmRiTYeH5nHmfiPHY/laj7c/H4+cYX39HfLvQ4VHdp0PG85tvn1gsUVhI7pzE/ShG363u92Jd3oZ4rS7bl9v4twejsbZV+2FRqZ8Pxm5pvuVMsz+/pPGbILs3o17pEdxvBqNqw587Wz61L8wazqONt4O0CjLW20FqoPF4c1HPlxcGXV+9XG4jvHS53M7Uv9gquF/g9LVWwb6+oVVwu54c18qx2sfN1n19udm6+5ebrfchXmy23h2N1njBS9/r5R+91nUYP7wl9vMR3b0TpTU5rk/jMWcv53MI370SdTCM3Z7PsPFjtm0XonztiP7i1Mjz6/xk9dPR+MQqkvHB8CuGWXsvhtcI4uMCIW/FeDzj522yH21+GGM31/jyapbtq0VwG+GlIrh9jfHFIrhflfO1IhjLMH+1CO7eL33cNNULyM0+XolyHLvx+6cxatMPX+/ax2CVi/bcJvRzjN2rVS++qraN8eKrar/Yl7oDakdvH2/H7ln/pfdth2wX9HXhd/GnS9zPb5rtt+SlN263B6RJffSsPUryWwe1Cd+7kKfy8ZuDur5+ULdjH6+9xLzfjpcO6baMvfSe7D7CK6/Jbhv7XrtGblckH/UGYX9+x/VTq5p7zW2NH3rHPrWqOTHam6uav7wy+pfHxOzLY2Lb9sQXr2/7Fd5fvL71b1iOam3XHPiGRd5ZB+rHlwI+E4OFTx6DPx8vvT92/cmvPWyMbl992NiHePHWeHtEawq4Tf/4iI6xfW/ttZWTtm8wO+Olrh+vvT/G9iMoLy2c9IsYLy2ctI3x4sJJv4pxfDnGawsn7WO8tnDS2Ld3vbSWzNi3d712S/niduxjbI/pSwsnjdm+fjxejPGFfXlp4aSXY2wWTvrFOfbSwklj91GpVxdO2m/Iawsnjd2szcs/rn/9ZH9xO94/QV5bOGno9k2N1xZO2m/Iawsnjf1cyUvPHLuXrF5+5vjFx6leeYz7xRX3pYWThvo+yCsLFm2DvDbj8sudeWk7dpNHbfExENGPn1/G7jnq1YWTtrf9Lz0P7iO88jy4nV94aRv2EV7ahu2dZXUmPND/662JWutPnz083ouhTBir9/dirGqAaX7Mt2I8Jp7qGne0j49H32Xbq7PO2yCPc6KebZd92DK2DeE1jKTe7L0QPGH7/HCq9uWzY7x5hjVi9I8P6FhfXkVlH+Klue/h8ruGeHH6fHs89b/tv/ncb8Ibd+bvVo6n7Xg3Bp9EeeC7MUZ7Jcb88hVlfvmK8osOzxqL8tbebBKtjrcHftgR1b+8KOEvQrxyLPZ9zPXqcfthsbVP9ULXzehjlMHejMGX2p/favhcDBZiWPbxN7R/0es+6FJ/7uz+ZMf8c5TNO0+/ijKIYh+/jTBFtte3174/vfve6Wvvgf2i/7+xrIxv3nL9xTFx3kXw4+13EZ63pb8dhQeX5ePNN1esdRojHyO670bRp3dO3n7/pR/M7fXW3o0ynqLMd9+i6f05ir4b5Wkopa+3j4s9RfF3Pyc/nt4uGu3dX3ocz1HePutYksBG39SWtm276tWz+eDNCfOrMLQpj757T2nfH/zqy3G/2pp6qHjw5tXZz+zUF8LUoOTZTL67lvT/P46Ns1PjGN+xU18IM+qrUjJ26xXM7RKB33VsWJ75wWN+y06Nd8vncdD5fxzvvqTsvHRjzxNzn1xVotrvHuhvBtG6azdt9maQWZO/Nv3d3bEaBbb19pofz7vzfhDWDVN7d80PPupqJuPdLak28UeQ+e6WTJZBm+Mbfh3ZlITtR6s+sSrFdiWU6pXanin7BXdoFOjj47dV9guYVtdoa8+vq/60+OjcvaD52tDQPsRL4zpzrt81xItr9O6OZ+etm24fL+Y6d+Mpr70UsduKweDS+GF9q5+3on/98XC3buCLj4f75XEbS88/9wJ/aond5w8TfHw82m4G5+V1endBXhuW3od4aVj6FyFeGZbergP92hiVfHWIqn15nKx9eZhs175bDznzh9mOdwL8MPXzcoDXXvLfBXipB3AX4KUWwOOrv+PxO/6M0lmvpC+Owvrp2rG2fcv1MsrzXoz1eohZw5RT3w1RwxHzeaDzUyFqEYwfOhjfDPHUP/CpEM+/6fFmCJbK8vFeCKupcnteFfHNEM8J+qkQvJVzvLkjLNSy3t2RVQ3x67nz6M0Q880fle+r+7uH05mhGW+enbzj5KpfDmFv/qhyTJaH1Y8P6PZLCnxTZzy9kPNT5dNj17YkNZLa5WlNg6Y/vaa5W+3vMb5crfnH8yj1z6/eH5vbzccddzVQ2dNv+9sg2y1p1X4gT6/x/jaI7lK2BjbW84rKj8HVn4LsXo5uNfc129Nl6Rzzfj1IrwbqB853g9So3PxhrPw3Qbb95MIxeRr8/80xke1DfK3RYM9rNP02yO6MrQ8IDHkKcfwcYvdIIXTctMPfDMJk8eNBvL0ZxGooodnTjNVvgmxzuNOI3Z+mDn6bw9tu7vbfLpr/myC7l5XMV33d4XiaxvvtD7y+If12QV4+X9t3nK/t6+dr+47ztX3H+dp+9/N11B17H0+l8Ten2u7x71HRjUr/dMf9U1Fraz93V+Pgz3ft9lOMF1/D6u9FWNwtrzcj1Cc5j4+3Yf+TCO8MPK3D+pufZDdSM486Oebx/BUBfT3G8BrFm8dzO9LPMXbtyzzCDH1+Mn87Rv8wxusHdXNv1bevxx3MGz338vy8M9tm/UGjvX98QLY90IezxpocXb8lyoc/8Pa291iv3PZu61iv98EeZVHerag03fbj3TuAV7dEvmNL9veJ1Twwn+8APnmzyTo64/j4tvf4+p3z8ftuxYt3zdsdqddsNpfK/QIDNRQz3wkgPA49HjLfCyGsevf8RPWpEDXKKLLe24ruDPL5e1sx+R7LfLo6fSqEsoT18vd2hFV3e3tvRzoNhH2+tSOv3sbttkKVJcrtvR0xo1vJ21shnMP5vI7ZJ0JY9T8/L/r+iQBes4Y+3zoOfvx3w2KfCVD55Ta/uAvvBRisCDWev1L987pn25EoHgrahyF221DL8z5/Rf232zC+4YFv9wGqFx/4dmtMvPzAtw3y6k3BNsjXK8Xs9eA5+9Pt+GeupHyN7zFJ8vSg1uXHXdl/fsp5Nen562KfCfIo37w4L7st2c0JVMWheo9PlM16be3pae83a3KuuRsdeWV1CN2uevbS6hD6DQunbR8F/OmbEh++2q37tddqybPx9Djy08uu+xCTldf04xC7nqJHlterEnJ8+LFI3S3Ts+r+3aVtNmP7NMLSWuMp0X5+ffjV38Q+/E22J/jzysTPC6D89LP6tnDVOpqP54mPXj/e31rUXesPc03HJ3ak1noW/2Htkp935MvLRtrx5WUj9yG+nKtN6Gv6oXL+dDBs+12p8/s+3HZ+2Ob1qyD9+UMp/cMgmxL6uCVgzkv6Znd094BXXY2PkSQuST99qHYbQ8k3fe6x+kyM6TUZ+ajYmxi7F0RX7Uv3HxZ6/sSGWKuL29nA+uGG7GaZxJ56pJ8XFe4//TK7WaZ5/Le9Pb8J0X/nA/L0y9jzh6B+c0Dm7u6pvhk2l/WPN0T061M7uxt0RrqHSXunog4VQrSPLw0mX6+o7esVtX29ov6qkj2tWfbxIv7WvqMcti9/b2JfUedBj+bzrdjPv23bLnTKW2rPK9j+fJrug3An1Y62C/INc6G/CPLaXOg2yKtzoda/YS7U+pfnQq1/w1zoPsiLc6H7IC8+Gm+vM+vg0aF/fJ3Zvej02JdqWx99c7b27zhbt1debbzE+MOT0E+7s5siejyb85XotQsi33BMdks6vX5MXnook+f3tX67N9vPs7POw/PSBr/dm/kNe7P9cRh8+GHNv9/ujn3H7nzHCfvi3dU61nv3zmr1idrHOHj/8v23PX20+ucY25ebHjPnT0+bTwsJ/byEs8m+nfrpk7vm8nGY/dNADas/hhRkc/O7C+JP3315/hzPz0HmN3Tz2fyGbr59kBe7+X4R5LV5ye0xefmOQL/jjkC/fkeg33FHoN9xR6DfcUewfQSe/ell1o/HBHYfTum1XF1/bo366cliuyD862Vg/wz8YhnYBnm1DJh8QxnYzVG9XAa2QV4tA/sgL5aB3TF5uQzsZoheLgO7T0m9WAZsfUMZ2AZ5tQxsg3zHg8HkJHl+CfTn+6zVdpOyfLWoPd1V/DxX9YunC27Wutq7TxcvJl//jsfY9R1n6/r62bq+42xd33G2rt/7bGXlJZ/z47PVtyOu9UWoKc9trD+frbsnpSlCkOevp/0myPyGs3XMbzhb/TvOVv/62erfcbb6d5yt/h1n6/ZtcK8R4Obz42GXtevuHUdNEYzjh5lj+cw4xYvVdT9O8er52r5+vq7jG87XdXz5fF3HN5yv+yAvnq/7IN9xvnapjufHuNbHoy5rV6KH1dT+WD/MacnrQzev19fvuBsY33A3sOQ7zlf5+vkq33G+ynecr/ItdwO7CcdWk/SPGWndPPXtggw+6/rcr/tzkLWd25KD7uXnBYzkM1sya9Bz6vNSEb/Zkm1XYM2PPXUL/PTOwtrNSv33EWT8/Dj+HWNh8g2DR2v3ytLLmdePL2feblrr5czbBnk187ZBXsy8fZAX3yb5xe681ji6LySvbsm+pL24Jcd3bMnxDVuyv3l9cUt+cRv94pas79iS9R1bYt+xJfYtW7IdUnvt/adfBHntzaP9OPKrx0S/4Z2wX8w2vHhM5je8E/Z6v13/uN9u7Rd3flrb+ellptFe35DOC1Fd/NhsyPz6c98vgrw2yb12P86r86i/CPLafcU2yMv3FXp8w33F9ksor91X7Oa1Xr6v2AZ59b5iG+TlSandSd9qIb/e1sete2v3bapXHx63QV5tHlj6Dc0Dvwjy4kmv3/EYa98wE7vsyzOxy75hJnYf5NWT3vrvftLXiEnvmzcAtkHGUbszjrnJnO33gr8jyGvLV+5DvLR85S9CvLJ85f7HffWG3r7h9mhfW1/dkn2Vf/FGrX/HLWP/hmNybMdKssQ/zzgueTXAY4Kft8WP5/59/UQIlrM/lug7IVju7sFPC959IoTXwrUPVnkrBN+5+KF98DMhnj5ueTy90vV6COGjgw9uH23F2s1kvbor2yCvNZkf24r+wmLXuwAvrVPtx+8b4svHQdqsX7Q9vyLjr7/m1+g2bM/vtr0bQt8K0XlJrz+/0/uZEMrSEs892J8IMYVP2I/3jkXnrcnnFy/fDvHej/q8ouTTE+WnQrAuxFB9MwQ78vz+52dC1N2sjPXejzqcD9gex5vnBa/Ctrd+VL5d/byC1CcCcGrO9vFx8O0o7OKj9Ws9rzP98kbUPd8PMzmf2IvqDflhQa9PBJhM4Yy3AtQT4/T+XoBa3dnH1wL8sLbzZw4iq4C9VSq1VtjQ7l/cgp9/xv/5+H//9C9/+cc///Xv//Knf//L3//2b4+/+68z1D/+8qf/9dc/3//v//mPv/3L0//67//vv+b/8r/+8Ze//vUv//ef//Uff/+XP//v//jHn89I5//2h+P+P/8jvljzmFX2//lPf5DH/7/G41bzMQ54PP7/fv7v+nhqfNx+6vm/n3/wmCi3fxprtvO/kPgXj/vbx//x//lf5yb/fw==","names":["sync_private_state"],"brillig_names":["sync_private_state"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"GuardianBlocking::add_guardian_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"GuardianBlocking::add_guardian_parameters","fields":[{"name":"guardian","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"GuardianBlocking::approve_blocking_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"GuardianBlocking::approve_blocking_parameters","fields":[{"name":"user","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"GuardianBlocking::check_block_user_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"GuardianBlocking::check_block_user_parameters","fields":[{"name":"user","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"GuardianBlocking::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"GuardianBlocking::constructor_parameters","fields":[{"name":"portal","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"GuardianBlocking::decrement_guardian_count_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"GuardianBlocking::decrement_guardian_count_parameters","fields":[{"name":"user","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"GuardianBlocking::increment_approval_count_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"GuardianBlocking::increment_approval_count_parameters","fields":[{"name":"user","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"GuardianBlocking::increment_guardian_count_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"GuardianBlocking::increment_guardian_count_parameters","fields":[{"name":"user","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"GuardianBlocking::initiate_blocking_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"GuardianBlocking::initiate_blocking_parameters","fields":[{"name":"user","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"GuardianBlocking::is_user_blocked_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"GuardianBlocking::is_user_blocked_parameters","fields":[{"name":"user","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"boolean"}}]},{"kind":"struct","path":"GuardianBlocking::remove_guardian_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"GuardianBlocking::remove_guardian_parameters","fields":[{"name":"guardian","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"GuardianBlocking::set_public_block_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"GuardianBlocking::set_public_block_parameters","fields":[{"name":"user","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"GuardianBlocking::sync_private_state_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"GuardianBlocking::sync_private_state_parameters","fields":[]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"GuardianBlocking"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"config","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"user_guardians","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"approval_count","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"guardian_count","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"blocking_started","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"user_blocked","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}}]}}]}],"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"},{"kind":"string","value":"AddressNote"},{"kind":"struct","fields":[{"name":"address","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}}]}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"},{"kind":"string","value":"ValueNote"},{"kind":"struct","fields":[{"name":"value","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}}]}]}]}},"file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"12":{"source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n","path":"std/convert.nr"},"16":{"source":"use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n","path":"std/embedded_curve_ops.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"25":{"source":"//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n","path":"std/meta/expr.nr"},"42":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"43":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"51":{"source":"mod config;\n\nuse dep::aztec::macros::aztec;\n\n\n#[aztec]\npub contract GuardianBlocking {\n    use crate::config::Config;\n    use dep::value_note::value_note::ValueNote;\n    use dep::aztec::{\n        note::note_getter_options::NoteGetterOptions,\n        note::note_interface::NoteProperties,\n        note::note_viewer_options::NoteViewerOptions,\n        utils::comparison::Comparator,\n        macros::{functions::{initializer, internal, private, public, utility}, storage::storage},\n        prelude::{AztecAddress, EthAddress, Map, PrivateSet, SharedMutable, PublicImmutable, PrivateMutable},\n    };\n    use dep::aztec::protocol_types::traits::ToField;\n\n    global CHANGE_AUTHORIZED_DELAY_BLOCKS: u32 = 5;\n\n    #[storage]\n    struct Storage<Context> {\n        config: PublicImmutable<Config, Context>,\n        // Map user -> Set of guardians\n        user_guardians: Map<AztecAddress, PrivateSet<ValueNote, Context>, Context>,\n        // Map user -> number of guardian approvals\n        approval_count: Map<AztecAddress, SharedMutable<u32, CHANGE_AUTHORIZED_DELAY_BLOCKS, Context>, Context>,\n        // Map user -> total number of guardians\n        guardian_count: Map<AztecAddress, SharedMutable<u32, CHANGE_AUTHORIZED_DELAY_BLOCKS, Context>, Context>,\n        // Map user -> blocking initiated status\n        blocking_started: Map<AztecAddress, PrivateMutable<ValueNote, Context>, Context>,\n        // Map user -> final blocked status (1 = blocked, 0 = not blocked)\n        user_blocked: Map<AztecAddress, SharedMutable<u32, CHANGE_AUTHORIZED_DELAY_BLOCKS, Context>, Context>,\n    }\n\n    // ========== Init ==========\n    #[public]\n    #[initializer]\n    fn constructor(portal: EthAddress) {\n        storage.config.initialize(Config { portal });\n    }\n\n    // ========== Guardian Management ==========\n\n    #[private]\n    fn add_guardian(guardian: AztecAddress) {\n        let sender = context.msg_sender();\n        let note = ValueNote::new(1, guardian);\n        storage.user_guardians.at(sender).insert(note);\n        \n        // Schedule guardian count increment\n        GuardianBlocking::at(context.this_address()).increment_guardian_count(sender).enqueue(\n            &mut context\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn increment_guardian_count(user: AztecAddress) {\n        let current_count = storage.guardian_count.at(user).get_current_value();\n        storage.guardian_count.at(user).schedule_value_change(current_count + 1);\n    }\n\n    #[private]\n    fn remove_guardian(guardian: AztecAddress) {\n        let sender = context.msg_sender();\n\n        let removed_notes = storage.user_guardians.at(sender).pop_notes(NoteGetterOptions::new()\n            .select(ValueNote::properties().owner, Comparator.EQ, guardian)\n            .set_limit(1));\n            \n        if removed_notes.len() == 1 {\n            GuardianBlocking::at(context.this_address()).decrement_guardian_count(sender).enqueue(\n                &mut context\n            );\n        }\n    }\n\n    #[public]\n    #[internal]\n    fn decrement_guardian_count(user: AztecAddress) {\n        let current_count = storage.guardian_count.at(user).get_current_value();\n        storage.guardian_count.at(user).schedule_value_change(current_count - 1);\n    }\n\n    // ========== Blocking Flow ==========\n\n    #[private]\n    fn initiate_blocking(user: AztecAddress) {\n        let sender = context.msg_sender();\n        let notes = storage.user_guardians.at(user).pop_notes(NoteGetterOptions::new()\n            .select(ValueNote::properties().owner, Comparator.EQ, sender)\n            .set_limit(1));\n        assert(notes.len() == 1, \"Not a guardian\");\n\n        let is_user_blocked = storage.user_blocked.at(user).get_current_value();\n        assert(is_user_blocked == 0, \"Already blocked\");\n\n        let note = ValueNote::new(1, user);\n        storage.blocking_started.at(user).replace(note);\n\n        // Initialize approval count\n        GuardianBlocking::at(context.this_address()).set_public_block(user).enqueue(\n            &mut context\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn set_public_block(user: AztecAddress) {\n        storage.approval_count.at(user).schedule_value_change(1);\n    }\n\n    #[private]\n    fn approve_blocking(user: AztecAddress) {\n        let sender = context.msg_sender();\n\n        let notes = storage.user_guardians.at(user).pop_notes(NoteGetterOptions::new()\n            .select(ValueNote::properties().owner, Comparator.EQ, sender)\n            .set_limit(1));\n        assert(notes.len() == 1, \"Not a guardian\");\n\n        let is_user_blocked = storage.user_blocked.at(user).get_current_value();\n        assert(is_user_blocked == 0, \"Already blocked\");\n\n        GuardianBlocking::at(context.this_address()).increment_approval_count(user).enqueue(\n            &mut context\n        );\n\n        GuardianBlocking::at(context.this_address()).check_block_user(user).enqueue(\n            &mut context\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn check_block_user(user: AztecAddress) {\n        let total_guardians = storage.guardian_count.at(user).get_current_value();\n        let scheduled_approvals = storage.approval_count.at(user).get_current_value();\n        if scheduled_approvals == total_guardians {\n            storage.user_blocked.at(user).schedule_value_change(1);\n        }\n    }\n\n    #[public]\n    #[internal]\n    fn increment_approval_count(user: AztecAddress) {\n        let current_approvals = storage.approval_count.at(user).get_current_value();\n        storage.approval_count.at(user).schedule_value_change(current_approvals + 1);\n    }\n\n    // ========== Utility ==========\n\n    #[utility]\n    unconstrained fn is_user_blocked(user: AztecAddress) -> bool {\n        storage.user_blocked.at(user).get_current_value() == 1\n    }\n}\n","path":"/home/dsotnyk/Desktop/bridge/packages/aztec-guardians/src/main.nr"},"54":{"source":"use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/capsules/mod.nr"},"55":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let N: u32, T> UtilityCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\n// UtilityVoidCallInterface\n\npub struct UtilityVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n}\n\nimpl<let N: u32> UtilityVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: () }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"62":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"63":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"65":{"source":"use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/context/utility_context.nr"},"69":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/hash.nr"},"81":{"source":"use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/history/public_storage.nr"},"86":{"source":"use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"90":{"source":"use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_private_state = generate_sync_private_state();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/macros/aztec.nr"},"91":{"source":"use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr"},"95":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr"},"98":{"source":"use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n\n    fn_abi\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr"},"100":{"source":"use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/macros/notes.nr"},"101":{"source":"use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/macros/storage.nr"},"103":{"source":"use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr"},"104":{"source":"use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr"},"105":{"source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr"},"107":{"source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::fetch_tagged_logs},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr"},"108":{"source":"use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr"},"109":{"source":"// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/messages/encoding.nr"},"110":{"source":"use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr"},"123":{"source":"use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr"},"128":{"source":"use crate::{\n    context::PrivateContext,\n    note::{\n        note_getter_options::{\n            NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder,\n        },\n        note_interface::{NoteHash, NoteType},\n        note_viewer_options::NoteViewerOptions,\n        retrieved_note::RetrievedNote,\n        utils::compute_note_hash_for_read_request,\n    },\n    oracle,\n    utils::{array, comparison::compare},\n};\n\nuse protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, traits::{Packable, ToField}};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/note/note_getter.nr"},"131":{"source":"use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr"},"133":{"source":"use crate::{note::note_metadata::NoteMetadata, utils::array::subarray::subarray};\nuse protocol_types::{\n    address::AztecAddress,\n    traits::{FromField, Packable, Serialize, ToField},\n    utils::arrays::array_concat,\n};\n\n// Number of fields a RetrievedNote adds to the packed or serialized representation of a note\n// +1 for the contract address\n// +2 for the note metadata\npub global RETRIEVED_NOTE_OVERHEAD: u32 = 1 + 2;\n\n/// A container of a note and the metadata required to prove its existence, regardless of whether the note is\n/// pending (created in the current transaction) or settled (created in a previous transaction).\n#[derive(Eq)]\npub struct RetrievedNote<NOTE> {\n    pub note: NOTE,\n    pub contract_address: AztecAddress,\n    pub metadata: NoteMetadata,\n}\n\nimpl<NOTE, let N: u32> Serialize<N + RETRIEVED_NOTE_OVERHEAD> for RetrievedNote<NOTE>\nwhere\n    NOTE: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + RETRIEVED_NOTE_OVERHEAD] {\n        array_concat(\n            array_concat(self.note.serialize(), [self.contract_address.to_field()]),\n            self.metadata.serialize(),\n        )\n    }\n}\n\n// This function is not part of the Packable trait implementation because in the case of the retrieved note, the pack\n// functionality resides in TS (oracle.ts and txe_service.ts).\npub fn unpack_retrieved_note<NOTE, let N: u32>(\n    packed_retrieved_note: [Field; N + RETRIEVED_NOTE_OVERHEAD],\n) -> RetrievedNote<NOTE>\nwhere\n    NOTE: Packable<N>,\n{\n    let contract_address = AztecAddress::from_field(packed_retrieved_note[0]);\n    let nonce = packed_retrieved_note[1];\n    let nonzero_note_hash_counter = packed_retrieved_note[2] as bool;\n\n    let packed_note = subarray(packed_retrieved_note, RETRIEVED_NOTE_OVERHEAD);\n    let note = NOTE::unpack(packed_note);\n\n    RetrievedNote {\n        note,\n        contract_address,\n        metadata: NoteMetadata::from_raw_data(nonzero_note_hash_counter, nonce),\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/note/retrieved_note.nr"},"134":{"source":"use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"138":{"source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr"},"139":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"140":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"141":{"source":"/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr"},"142":{"source":"use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"146":{"source":"use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr"},"147":{"source":"use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"148":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"149":{"source":"use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, length, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/logs.nr"},"150":{"source":"use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(fetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    // The log fields length is PUBLIC_LOG_SIZE_IN_FIELDS. + 1 because the contract address is prepended to the content.\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_SIZE_IN_FIELDS + 1>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr"},"152":{"source":"use crate::note::{\n    note_interface::NoteType,\n    retrieved_note::{RETRIEVED_NOTE_OVERHEAD, RetrievedNote, unpack_retrieved_note},\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> {}\n\npub unconstrained fn get_notes<Note, let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<NOTE_PCKD_LEN>,\n{\n    // N + 3 because of the contract address, nonce, and note_hash_counter that are stored out of the packed note.\n    let packed_retrieved_notes: BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> = get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        MAX_NOTES,\n        NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD,\n    );\n\n    let mut notes = BoundedVec::<_, MAX_NOTES>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = unpack_retrieved_note(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MAX_NOTES];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"153":{"source":"/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/random.nr"},"154":{"source":"use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr"},"156":{"source":"use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/storage.nr"},"158":{"source":"use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only\n// used to derive the storage slots of nested state variables, which is expected to never result in collisions or slots\n// being close to one another due to these being hashes. This mirrors the strategy adopted by Solidity mappings.\nimpl<K, T, Context> Storage<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"162":{"source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateMutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nmod test;\n\n// Private storage slots are not really 'slots' but rather a value in the note hash preimage, so there is no notion of a\n// value spilling over multiple slots. For this reason PrivateMutable (and all other private state variables) needs just\n// one slot to be reserved, regardless of what it stores.\nimpl<T, Context> Storage<1> for PrivateMutable<T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateMutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateMutable>` type (for example), because the storage slot often also identifies an actor. e.g.\n    // the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    // Note: subsequent nullification of this state variable, via the `replace` method will not be leaky, if the `compute_nullifier()` method of the underlying note is designed to ensure privacy.\n    // For example, if the `compute_nullifier()` method injects the secret key of a note owner into the computed nullifier's preimage.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateMutable<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash,\n{\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace<let N: u32>(self, new_note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        let (prev_retrieved_note, note_hash_for_read_request): (RetrievedNote<Note>, Field) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify previous note.\n        destroy_note_unsafe(\n            self.context,\n            prev_retrieved_note,\n            note_hash_for_read_request,\n        );\n\n        // Add replacement note.\n        create_note(self.context, self.storage_slot, new_note)\n    }\n    // docs:end:replace\n\n    pub fn initialize_or_replace<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        // Safety: `check_nullifier_exists` is an unconstrained function - we can constrain a true value\n        // by providing an inclusion proof of the nullifier, but cannot constrain a false value since\n        // a non-inclusion proof would only be valid if done in public.\n        // Ultimately, this is not an issue given that we'll either:\n        //  - initialize the state variable, which would fail if it was already initialized due to the duplicate\n        //    nullifier, or\n        //  - replace the current value, which would fail if it was not initialized since we wouldn't be able\n        //    to produce an inclusion proof for the current note\n        // This means that an honest oracle will assist the prover to produce a valid proof, while a malicious\n        // oracle (i.e. one that returns an incorrect value for is_initialized) will simply fail to produce\n        // a proof.\n        let is_initialized =\n            unsafe { check_nullifier_exists(self.compute_initialization_nullifier()) };\n\n        if (!is_initialized) {\n            self.initialize(note)\n        } else {\n            self.replace(note)\n        }\n    }\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        let mut (retrieved_note, note_hash_for_read_request) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note_unsafe(self.context, retrieved_note, note_hash_for_read_request);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(self.context, self.storage_slot, retrieved_note.note)\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateMutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/state_vars/private_mutable.nr"},"164":{"source":"use crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    abis::read_request::ReadRequest, constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    traits::Packable,\n};\n\nmod test;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    pub context: Context,\n    pub storage_slot: Field,\n}\n// docs:end:struct\n\n// Private storage slots are not really 'slots' but rather a value in the note hash preimage, so there is no notion of a\n// value spilling over multiple slots. For this reason PrivateSet (and all other private state variables) needs just one\n// slot to be reserved, regardless of what it stores.\nimpl<T, Context> Storage<1> for PrivateSet<T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:insert\n    pub fn insert<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS, let N: u32>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N>,\n    {\n        let (retrieved_notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < retrieved_notes.len() {\n                let retrieved_note = retrieved_notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, retrieved_note, note_hash);\n            }\n        }\n\n        // Since the notes were already destroyed, we no longer need the additional data in RetrievedNote and can\n        // discard it.\n        retrieved_notes.map(|retrieved_note| retrieved_note.note)\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, retrieved_note: RetrievedNote<Note>) {\n        let note_hash = compute_note_hash_for_read_request(retrieved_note, self.storage_slot);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, retrieved_note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS, let N: u32>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N>,\n    {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note> PrivateSet<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes<let N: u32>(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\n    where\n        Note: Packable<N>,\n    {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr"},"166":{"source":"use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr"},"169":{"source":"use dep::protocol_types::{\n    shared_mutable::{\n        ScheduledDelayChange,\n        ScheduledValueChange,\n        shared_mutable_values::{unpack_delay_change, unpack_value_change},\n        SharedMutableValues,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u32, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change<let N: u32>(self, new_value: T)\n    where\n        T: Packable<N>,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change<let N: u32>(\n        self,\n        new_value: T,\n    ) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change<let N: u32>(self, new_delay: u32)\n    where\n        T: Packable<N>,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay<let N: u32>(self) -> u32\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value<let N: u32>(self) -> (T, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay<let N: u32>(self) -> (u32, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change<let N: u32>(self) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.block_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, N>(packed)\n    }\n\n    fn read_delay_change<let N: u32>(self) -> ScheduledDelayChange<INITIAL_DELAY>\n    where\n        T: Packable<N>,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because\n        // ScheduledValueChange and ScheduledDelayChange are packed together (sdc and svc.block_of_change are\n        // stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<INITIAL_DELAY>(packed)\n    }\n\n    fn write<let N: u32>(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    )\n    where\n        T: Packable<N>,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_block_number) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon =\n            value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage<let N: u32>(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32)\n    where\n        T: Packable<N>,\n    {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_block_number)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let block_number = self.context.block_number() as u32;\n        smv.svc.get_current_at(block_number)\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr"},"181":{"source":"/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/utils/array/append.nr"},"182":{"source":"/// Collapses an array of `Option`s with sparse `Some` values into a `BoundedVec`, essentially unwrapping the `Option`s\n/// and removing the `None` values.\n///\n/// For example, given:\n///   `input: [some(3), none(), some(1)]`\n/// this returns\n///   `collapsed: [3, 1]`\npub fn collapse<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>\nwhere\n    T: Eq,\n{\n    // Computing the collapsed BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n\n    // Safety: The hints are verified by the `verify_collapse_hints` function.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\nfn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>,\n)\nwhere\n    T: Eq,\n{\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(\n        collapsed.len(),\n        collapsed_to_input_index_mapping.len(),\n        \"Collapse hint vec length mismatch\",\n    );\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(\n                collapsed.get_unchecked(i),\n                input[input_index].unwrap(),\n                \"Wrong collapsed vec content\",\n            );\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(\n                collapsed.get_unchecked(i),\n                std::mem::zeroed(),\n                \"Dirty collapsed vec storage\",\n            );\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n\nmod test {\n    use super::{collapse, verify_collapse_hints};\n\n    #[test]\n    unconstrained fn collapse_empty_array() {\n        let original: [Option<Field>; 2] = [Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn collapse_non_sparse_array() {\n        let original = [Option::some(7), Option::some(3), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_sparse_array() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_front_padding() {\n        let original =\n            [Option::none(), Option::none(), Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_back_padding() {\n        let original =\n            [Option::some(7), Option::none(), Option::some(3), Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn verify_collapse_hints_good_hints() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec length\")]\n    unconstrained fn verify_collapse_hints_wrong_length() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Collapse hint vec length mismatch\")]\n    unconstrained fn verify_collapse_hints_hint_length_mismatch() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Out of bounds index hint\")]\n    unconstrained fn verify_collapse_hints_out_of_bounds_index_hint() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 5]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn verify_collapse_hints_hint_to_none() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 0]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 1]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec content\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_content() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 42]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec order\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_order() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([3, 7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([2, 0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Dirty collapsed vec storage\")]\n    unconstrained fn verify_collapse_hints_dirty_storage() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n\n        let mut collapsed: BoundedVec<u32, 3> = BoundedVec::from_array([7, 3]);\n        // We have to use the unchecked setter as we're knowingly writing past the length, breaking its invariants.\n        collapsed.set_unchecked(2, 1);\n\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/utils/array/collapse.nr"},"184":{"source":"/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr"},"185":{"source":"use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr"},"186":{"source":"struct ComparatorEnum {\n    pub EQ: u8,\n    pub NEQ: u8,\n    pub LT: u8,\n    pub LTE: u8,\n    pub GT: u8,\n    pub GTE: u8,\n}\n\npub global Comparator: ComparatorEnum =\n    ComparatorEnum { EQ: 1, NEQ: 2, LT: 3, LTE: 4, GT: 5, GTE: 6 };\n\npub fn compare(lhs: Field, operation: u8, rhs: Field) -> bool {\n    // Values are computed ahead of time because circuits evaluate all branches\n    let is_equal = lhs == rhs;\n    let is_lt = lhs.lt(rhs);\n\n    if (operation == Comparator.EQ) {\n        is_equal\n    } else if (operation == Comparator.NEQ) {\n        !is_equal\n    } else if (operation == Comparator.LT) {\n        is_lt\n    } else if (operation == Comparator.LTE) {\n        is_lt | is_equal\n    } else if (operation == Comparator.GT) {\n        !is_lt & !is_equal\n    } else if (operation == Comparator.GTE) {\n        !is_lt\n    } else {\n        panic(f\"Invalid operation\")\n    }\n}\n\nmod test {\n    use super::Comparator;\n    use super::compare;\n\n    #[test]\n    unconstrained fn test_compare() {\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.LT, rhs), \"Expected lhs to be less than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.LTE, rhs), \"Expected lhs to be less than or equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.GT, rhs), \"Expected lhs to be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(!compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to not be not equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.LT, rhs), \"Expected lhs to not be less than rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            !compare(lhs, Comparator.LTE, rhs),\n            \"Expected lhs to not be less than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.GT, rhs), \"Expected lhs to not be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/utils/comparison.nr"},"187":{"source":"use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr"},"188":{"source":"// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr"},"190":{"source":"use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/utils/field.nr"},"192":{"source":"use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"196":{"source":"use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr"},"203":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr"},"220":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr"},"222":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"265":{"source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"266":{"source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH,\n    traits::{Deserialize, Empty, Packable, Serialize, ToField},\n};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl Packable<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn pack(self) -> [Field; ETH_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn to_be_bytes(self) -> [u8; 20] {\n        let field_bytes: [u8; 32] = self.inner.to_be_bytes();\n        let mut bytes = [0; 20];\n        for i in 0..20 {\n            bytes[i] = field_bytes[i + 12];\n        }\n        bytes\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr"},"280":{"source":"use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr"},"282":{"source":"/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"283":{"source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"293":{"source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr"},"297":{"source":"use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr"},"299":{"source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"300":{"source":"use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr"},"310":{"source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr"},"314":{"source":"use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u32>,\n    pub(crate) post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), block_of_change: 0 }\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr"},"316":{"source":"use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the block of change. Note that this value\n    // might not be the current anymore since block of change might have already passed.\n    pub fn get_previous(self) -> (T, u32) {\n        (self.pre, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32,\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), block_of_change: 0 }\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr"},"318":{"source":"use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.block_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u32> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let N: u32>(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, N + 1);\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        packed[0] as u32,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u32>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc block_of_change. We'll discard the svc component.\n    let svc_block_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_block_of_change as Field) / TWO_POW_32;\n    let sdc_block_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_block_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner)\n        } else {\n            Option::none()\n        },\n        block_of_change: sdc_block_of_change,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the block_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.block_of_change and svc.block_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.block_of_change: u32 | svc.block_of_change: u32 ]\n        result[0] = self.svc.block_of_change as Field\n            + ((self.sdc.block_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = unpack_value_change::<T, N>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr"},"321":{"source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"339":{"source":"use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr"},"340":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"356":{"source":"pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::sort_by_counter_asc;\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\n// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr"},"357":{"source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"359":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"369":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr"},"378":{"source":"use aztec::{macros::notes::note, oracle::random::random, protocol_types::address::AztecAddress};\n\n// docs:start:value-note-def\n#[note]\n#[derive(Eq)]\npub struct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        ValueNote { value, owner, randomness }\n    }\n\n    pub fn value(self) -> Field {\n        self.value\n    }\n}\n","path":"/home/dsotnyk/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/value-note/src/value_note.nr"}}}