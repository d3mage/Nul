{"noir_version":"1.0.0-beta.5+0000000000000000000000000000000000000000","name":"GuardianBlocking","functions":[{"name":"add_guardian","hash":"15434961780200846797","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"address_note::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"guardian","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"address_note::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"vb3druTMbbB7Lz7OgVg/rGJu5UMQOI6/wIBhB46zgY3A975bVJFPz5p0jVav9e6TzOM3M3zUapEtVVFV//O7f//jv/33f/zrn/7yf//6X7/75//zP7/7t7/96c9//tN//Ouf//qH3//9T3/9y+O//s/vjvP/SJHf/bP80+PPsv6s68+2/uzrT11/jvXnXH/a9Wc91p8rXl3x6opXV7y64tUVr654dcWrK15b8dqK11a8tuK1Fa+teG3FayteW/HaitdXvL7i9RWvr3h9xesrXl/x+orXV7y+4umKpyuerni64umKpyuerni64umKpyveWPHGijdWvLHijRVvrHhjxRsr3ljxxoo3V7y54s0Vbz7ilfPPtv7s609df47151x/PuL1x5/2iDfOP2X9Wdafdf3Z1p99/anrz7H+nOtP8z/Lcaw/z+MrJ5SAGtACeoAGjIAZYAvkCIjIEpElIktElogsEVkiskRkicglIpeIXCJyicglIpeIXCJyicglInvuPE5u8eRxkIASUANaQA/QgBEwAyJyi8gtIreI3CJyi8gtIreI3CJyi8gtIveI3CNyj8g9IveI3CNyj8g9IveI3COyRmSNyBqRNSJrRNaIrBFZI7JGZI3IIyKPiDwi8ojIIyKPiDwi8ojIIyKPiDwj8ozIMyLPiDwj8ozIMyLPiDwj8pl3Mh9wJt4FElACakAL6AEaMAJmwIpcjyNAAkrAWSXKCS2gB2jACJgBtuDMwQskoAREZInIEpElIp85WPoJM8AWnDl4gQSUgBrQAnqABkTkEpFLRK4R+czBYieUgBrQAnqABoyAGWALzhy8ICK3iNwicovILSK3iNwicovILSL3iNwjco/IPSL3iNwjco/IPSL3iNwjskZkjcgakTUia0TWiKwRWSOyRmSNyCMij4g8IvKIyCMij4g8IvKIyCMij4g8I/KMyDMiz4g8I/KMyDMiz4g8I/KMyBaRLSJbRLaIbBHZIrJFZIvIFpFtRW7HESABJaAGtIAeoAEjYAZEZInIEpElIktElogsEVkiskRkicgSkUtELhG5ROQSkUtELhG5ROQSkUtELhG5RuTIwRY52CIH25mDVU7oARowAmaALThz8AIJKAE1ICK3iNwicovILSK3iNwjco/IPSL3iNwjco/IPSL3iNwjco/IGpE1ImtE1oisEVkjskZkjcgakTUi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","names":["add_guardian"],"brillig_names":["discover_new_messages","random","notify_created_note_oracle_wrapper","directive_invert"]},{"name":"approve_blocking","hash":"16952677900357198456","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"address_note::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"user","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"address_note::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"855401245733623969":{"error_kind":"string","string":"Obtained invalid key validation request"},"1186437190978851533":{"error_kind":"string","string":"Non-zero hint for zero hash"},"1433889167918961673":{"error_kind":"fmtstring","length":17,"item_types":[]},"1589673740894288059":{"error_kind":"string","string":"Hint values do not match hash"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5641381842727637878":{"error_kind":"string","string":"Got more notes than limit."},"5672954975036048158":{"error_kind":"string","string":"Collapse hint vec length mismatch"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7506220854563469239":{"error_kind":"string","string":"Dirty collapsed vec storage"},"7764445047318889914":{"error_kind":"string","string":"Public data tree index doesn't match witness"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"9199403315589104763":{"error_kind":"string","string":"Proving public value inclusion failed"},"10583567252049806039":{"error_kind":"string","string":"Wrong collapsed vec order"},"11091894166229312484":{"error_kind":"fmtstring","length":20,"item_types":[]},"11499495063250795588":{"error_kind":"string","string":"Wrong collapsed vec content"},"11553125913047385813":{"error_kind":"string","string":"Wrong collapsed vec length"},"11873158822563704285":{"error_kind":"string","string":"Mismatch return note field."},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13488305543605632947":{"error_kind":"string","string":"Already blocked"},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"15431201120282223247":{"error_kind":"string","string":"Out of bounds index hint"},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17022728796570737336":{"error_kind":"string","string":"Not a guardian"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"18313900523101689315":{"error_kind":"string","string":"Note contract address mismatch."},"18387306374501297453":{"error_kind":"string","string":"Blocking not started"}}},"bytecode":"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","debug_symbols":"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PdEctrVBO/T2fd9Nse6p5qu3b5zX7NGHV1dv3/e9Cesebb56+9Z+j4dXVzv09j13GxxeXb19a+d2eFU7n8Orq7dv7TE5vLp6+/bO4fDqaofevn1+3JvQb1957Rw2r44+h50fvba2rQVat46tDfrtK+8b69Y58vzohN6+73sB1jn1fPXmlbx/277OuWeRncPm1aMVevvun7mes8+P3r5yXjOhC3r77p+yngPQj96+7y9+1jkC/WiF3r6289y8evT2tZ3b5pXYzmfz6tHb1/ZYbV49evtuDpzD0I9W6O37voJknfPQj96+sXPYvHp0QW/f/Rk5h6IfvX335+Ici3709s3zy26Ddujtm3tON68efT6/53W2776d4xyPfvSC3r6989m8erRBb98+/z6gE/rtq6c+N6+u3rx69Np618Dm1aPfvn9W5lvb/t/3mG9e6anJzatHJ/7N9tU9F5tXV29ePXr7njrZvHr09rXzA3mD3r6+3/vmle7vj87JaT1ju3n16B69efXoBb19Y9fw5tWjDdqhAzqhC7pHb149ekHDt+Hb8G34Nnw3r/6sJLcu6O1b77k7B6ofvX03986Rau1zt4BCb99dM+dU9aO377sB0Trnqh9d0G9fe98wuc7R6kevrXtrgVbot++fldjWDh1bn4sPcuv9XjavHt2jN68evX3Xzm3z6tEKbdDb996sENDbd//2/xy2fvTx3flvXtnm5zlv/WiB1k+9nSPXj3bo836PTuiC3r6yc7YX9PbV7bV5ZZuf5+z1ow16v187/z6gt68fvX33WuKcwL5688piz9HmlcX53wVaoQ16++a5oCKgt2/u3A6v9uf6nMXet6atcxjbTg1vXj16+55a3bx69PY99bl59ejt2+c1377+vh9unUPZfuph8+rqzatHv31dtu/m1aMV+u3ruut/82rfXrXO4WzffwfP6Ww/c7F59egevXn16O2715DniPajFdqgHTqgj+9+71XQPbpf0AtaoBXaoLfvXtOeA9uP3r6nzjevHt0ffQ5t//mLs/X23evPc2zb99/Qc27bdz2cg9uPduiATujt2+d1evTm1aMXtEArtEE7dEAnNHwXfAW+m1ex/xafo9yPfvvGOv/Gtt7vZfNq3yC/znHuuPe05NZ73DavYvPhnOi+evMqNivOme5Hb1/dr7959ejta+fyl+1r598HdEIX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l05cOnHpxLXdRN6znUsnLp24tpvoz1iWTlw6cenEpROXTlz+jMU+llw6cenEpRO3Ttw6cetE+1jSPpa0jyXtY0n7WNI+lrSPJe1jyU2XaW6duHXi1olbJ26duP0Zi30suXXi1olbJ26duHXi1on2saR9LGkfS266THPTZZpbJ26duHXi1olbJ246qtI+ltw6cevETW9fbnr7cuvErRO3Ttw6cevETUdV2seSWydunbh14taJWydunWgfS9rHkvaxpH0saR9L2seS9rGkfSy56TLNrRO3Ttw6cevErRN3u4n0seTWiVsnbp24deLWiVsn2seS9rGkfSy5l5tIl2lunbh14taJWydunbi3m0j3QG6duHXi9ufO2587b524deLWiVsnbp24/bmzfSy5deLRiUcnHp14dOLRifaxpH0saR9L2seS9rGkfSxpH0vax5KHLtM8OvHoxKMTj048OvH4c2f7WPLoxKMTj048OvHoxKMT7WNJ+1jSPpY8dJnmocs0j048OvHoxKMTj048dFSlfSx5dOLRiYfevjz09uXRiUcnHp14dOLRiYeOqrSPJY9OPDrx6MSjE49OPDrRPpa0jyXtY0n7WNI+lrSPJe1jSftY8tBlmkcnHp14dOLRiUcnnuUm0seSRycenXh04tGJRycenWgfS9rHkvax5NluIl2meXTi0Yn2saR9LGkfS9rHkvax5NGJRycefxfn0NuXRycenXh04tGJRycefhenPnRU1Qcn1gcn1gcn1gcn1gcn1gcn1gcn1gcn1gcn1gcn1mdIMCQYEgwJ6DKtD06sD06sD06sD06sD06sD7+LUx9+F6c+OLE+OLE+OLE+OLE+OLE+OLE+OLE+dFTVh46q+tBlWh+6TOuDE+uDE+uDE+uDE+uDE+tDR1V96KiqD06sD06sD7199aG3rz44sT44sT44sT44sT7pJpabSEdVfco9KPeg3INyE8tNLDex3MRyE9tNbDexJWgJWoKWgC7T+rSb2G5iu4nLTVxu4nIT6aiqz3ITl5u43MTlJi43cbmJ203kOrE+XCfWByfWZ7uJ203cbuJ2E18n3gG/TlxPeN8pez+5952yb5iGMKShDG1Yhm04f2HQUVWDjqoadFTVoKOqBh1VNeioqkFHVQ06qmrQUVXjI8GQYEgwJBgSDAmGBEOCIcGQYEgwJZgSTAmmBLxnuwbv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","names":["approve_blocking"],"brillig_names":["discover_new_messages","get_notes_internal","get_collapse_hints","field_less_than","decompose_hint","lte_hint","get_public_keys_and_partial_address","get_key_validation_request","notify_nullified_note_oracle_wrapper","get_note_internal","notify_created_note_oracle_wrapper","random","storage_read","get_public_data_witness","directive_invert","directive_integer_quotient","directive_to_radix"]},{"name":"constructor","hash":"8609517660282271418","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"parameters":[{"name":"portal","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2236649814169388962":{"error_kind":"string","string":"PublicImmutable already initialized"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["constructor"],"brillig_names":["constructor"]},{"name":"initiate_blocking","hash":"6927251112323172906","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"address_note::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"user","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"address_note::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"855401245733623969":{"error_kind":"string","string":"Obtained invalid key validation request"},"1433889167918961673":{"error_kind":"fmtstring","length":17,"item_types":[]},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"3810909342811161572":{"error_kind":"string","string":"Block already started"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5641381842727637878":{"error_kind":"string","string":"Got more notes than limit."},"5672954975036048158":{"error_kind":"string","string":"Collapse hint vec length mismatch"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7506220854563469239":{"error_kind":"string","string":"Dirty collapsed vec storage"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"10583567252049806039":{"error_kind":"string","string":"Wrong collapsed vec order"},"11091894166229312484":{"error_kind":"fmtstring","length":20,"item_types":[]},"11499495063250795588":{"error_kind":"string","string":"Wrong collapsed vec content"},"11553125913047385813":{"error_kind":"string","string":"Wrong collapsed vec length"},"11873158822563704285":{"error_kind":"string","string":"Mismatch return note field."},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13488305543605632947":{"error_kind":"string","string":"Already blocked"},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"15431201120282223247":{"error_kind":"string","string":"Out of bounds index hint"},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17022728796570737336":{"error_kind":"string","string":"Not a guardian"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"18313900523101689315":{"error_kind":"string","string":"Note contract address mismatch."}}},"bytecode":"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tR9P7XVT+8jUHi21/0ntLVL7dj6QpPabqL0cap+EGvOq9f1q7bxal67Waas10Godr1rXqtZ5qnWPah2gWhen1ompdVNqHZFaV6PWmah1F2odgrovr+5Tq/u26j6muq+n7nOp+z7qPoi6L6DmydW8sZpHVfOKap5NzTupeRg1L6HydJW3qjxO5TVqnN/q32FDTK1TVmXjWGNxQ4pi+0+9Wter1rmqdZ9qHaRaF6jWyal1Y2odlVpXpNbZqHUnah2GWpeg7tOr+9bqPq66r6nu86n7Xuo+kLovou4TqHlzNY+s5lXVPKOad+spqZekdSSpvF3lsSqvU3mOWju/UWzFovpjr3RwPzsv2777yc9ctbN+XCefuu7u54UdhjZseJJCuLEc43Nef5+6k3zqTvWpO92nbrxP3Zk+dbN96ub71F3sU7fAp+4Gn7rbferu86l70P187Ylp0174/oBL9LqH3M8e2S9uP7r63r30uqfcz5nrFDjXXL7B63rd0+5nq1hxu8MeO+FxvW6x+7nTHyfs/Npx51ys173lU/e2T907PnXv+tS951P3vk/dBz51S9zPu0778NduQzY5Vq/70KduqU/dMp+6j3zqPvap+9r9tOH3jftpw+9v99Omu7cByVaX5VPXyqcu26cux6eutVv3xiMfDj64+oM5el1bt85ml3Y+de196op96lbzqevgU7eGW2fDaE23zobRpj522cynbnOfui186hyfOuFTt7UPRtv52KWPT932PnU7+NTt6FO3k0/dnj4Y7eWD0VE+djnap+4Yn7oqn7pqn7oan7qTfDA62ccug33qTvGpG+JTd6pP3VCfujE+GDX4YDTLxy6zferm+NSd5VM316fubJ+6S3wwutzHLlf41F3pU7fAp+4qn7qrfepu8cHoVh+MHvGxy6M+dY/51D3uU/eET92TPnWv+GD0mo9dXvepe8On7k2fusU+dW/51C31wWiZD0Y/+tjlJ5+6n33qlvvU/eJT96vfeMLNUGwY5bt1NrsU+NQV+tQV+dS19qlr41PX2a2zYdTFrbNhtIFbZ7PLhj51G/nUbexT19unbhOfujIfjCp97LKlT91WPnVb+9Rt41O3rU/drj4Y7eaD0SE+djnUp+4wn7rDfeqO8Kk70qfuWB+MTvCxywCfuhN96k7yqRvoUzfIp264D0YjfDA608cuU33qpvnU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","debug_symbols":"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","names":["initiate_blocking"],"brillig_names":["discover_new_messages","get_notes_internal","get_collapse_hints","field_less_than","decompose_hint","lte_hint","get_public_keys_and_partial_address","get_key_validation_request","notify_nullified_note_oracle_wrapper","get_note_internal","notify_created_note_oracle_wrapper","random","directive_invert","directive_integer_quotient","directive_to_radix"]},{"name":"is_user_blocked","hash":"16916450340551953986","is_unconstrained":true,"custom_attributes":["utility"],"abi":{"parameters":[{"name":"user","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5672954975036048158":{"error_kind":"string","string":"Collapse hint vec length mismatch"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7506220854563469239":{"error_kind":"string","string":"Dirty collapsed vec storage"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"10583567252049806039":{"error_kind":"string","string":"Wrong collapsed vec order"},"11499495063250795588":{"error_kind":"string","string":"Wrong collapsed vec content"},"11553125913047385813":{"error_kind":"string","string":"Wrong collapsed vec length"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"15431201120282223247":{"error_kind":"string","string":"Out of bounds index hint"},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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","names":["is_user_blocked"],"brillig_names":["is_user_blocked"]},{"name":"public_dispatch","hash":"1111872628485949257","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2236649814169388962":{"error_kind":"string","string":"PublicImmutable already initialized"},"2830029349304997821":{"error_kind":"fmtstring","length":27,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["public_dispatch"],"brillig_names":["public_dispatch"]},{"name":"remove_guardian","hash":"3431203250005622624","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"address_note::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"guardian","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"address_note::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"855401245733623969":{"error_kind":"string","string":"Obtained invalid key validation request"},"1433889167918961673":{"error_kind":"fmtstring","length":17,"item_types":[]},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5641381842727637878":{"error_kind":"string","string":"Got more notes than limit."},"5672954975036048158":{"error_kind":"string","string":"Collapse hint vec length mismatch"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7506220854563469239":{"error_kind":"string","string":"Dirty collapsed vec storage"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"10583567252049806039":{"error_kind":"string","string":"Wrong collapsed vec order"},"11499495063250795588":{"error_kind":"string","string":"Wrong collapsed vec content"},"11553125913047385813":{"error_kind":"string","string":"Wrong collapsed vec length"},"11873158822563704285":{"error_kind":"string","string":"Mismatch return note field."},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"15431201120282223247":{"error_kind":"string","string":"Out of bounds index hint"},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"18313900523101689315":{"error_kind":"string","string":"Note contract address mismatch."}}},"bytecode":"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","debug_symbols":"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","names":["remove_guardian"],"brillig_names":["discover_new_messages","random","get_notes_internal","get_collapse_hints","field_less_than","decompose_hint","lte_hint","get_public_keys_and_partial_address","get_key_validation_request","notify_nullified_note_oracle_wrapper","directive_invert","directive_integer_quotient","directive_to_radix"]},{"name":"sync_private_state","hash":"2151940112491694678","is_unconstrained":true,"custom_attributes":["utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"vb3dru3MbWD7Lr7OhVg/ZNGv0mgE7rS7YcCwAyc5wEGQdz9TlMgx9/6yas811/rOTTxi78UhaYqUVEWV/vMP//vP/+s//u8//+Vv/+fv//aHP/6P//zD//rHX/7617/833/+69//5U///pe//+3x3/7nH47z/4isP/yx/9PjP/0Pf5yP/2yP/9rO/5Q//NHP/2x/+KPICT1hJMwETbCEleA39CNBEjJyz8g9I/eM3DNyz8g9I/eMPDLyyMgjI4+MPDLyyMgjI4+MPDLyyMgzI8+MPDPyzMgzI8+MPDPyzMgzI8+MrBlZM7JmZM3ImpE1I2tG1oysGVkzsmVky8iWkS0jW0a2jGwZ2TKyZWTLyCsjr4y8MvLKyOuM3E6YCZpgCSvBb/Az8nny+Rn5PPu8JfSEkTATNMESVoJf0I4jQRIekVs7oSeMhJmgCZawEvwGORIkISNLRpaMLBlZMrJkZMnIkpFbRm4ZuWXklpFbRm4ZuWXklpFbRm4Z+czBNk+QhJbQE0bCTNAES1gJfsPIyCMjj4w8MvLIyCMjj4w8MvLIyCMjz4w8M/LMyDMjz4w8M/LMyDMjz4w8M7JmZM3ImpE1I2tG1oysGVkzsmZkzciWkS0jW0a2jGwZ2TKyZWTLyJaRLSOvjLwy8srIKyOvjLwy8srIKyOvjLwy8pmDbZ0gCS2hJ4yEmaAJlrAS/IJ+HAmS0BJ6wiNybyfMBE2whJXgN5w5eIEktISekJElI0tGlowc18B5gt9w5uAFktASesJImAmaYAkZuWXknpF7Rj5zsPsJPWEkzARNsISV4DecOXiBJGTkkZFHRh4ZeWTkkZFHRh4ZeWbkmZFnRp4ZeWbkmZFnRp4ZeWbkmZE1I2tG1oysGVkzsmZkzciakTUja0a2jGwZ2TKyZWTLyJaRLSNbRraMbBl5ZeSVkVdGXhl5ZeSVkVdGXhl5ZeSVkT0je0b2jOwZ2TOyZ2TPyJ6RPSP7HXkcR4IktISeMBJmgiZYwkrIyJKRJSNLRpaMLBlZMrJkZMnIkpElI7eM3DJyy8gtI7eM3DJyy8gtI7eM3DJyz8g9I2cOjszBkTk4zhwccoImWMJK8BvOHLxAElpCTxgJGXlk5JGRR0YeGXlm5JmRZ0aeGXlm5JmRZ0aeGXlm5JmRNSNrRtaMrBlZM7JmZM3ImpE1I2tGtoxsGdkysmVky8iWkS0jW0a2jGwZeWXklZFXRl4ZeWXklZFXRl4ZeWXklZE9I3tG9ozsGdkzsmdkz8iekT0j+x15HkeCJLSEnjASZoImWMJKyMiSkSUjS0aWjCwZWTKyZGTJyJKRJSO3jNwycsvILSO3jNwycsvILSO3jNwycs/IPSP3jNwzcs/ImYMzc3BmDs7MwZk5ODMHZ+bgzBycmYMzc3BmDs7MwZk5ODMHZ+bgzBycmYMzc3BmDs7MwZk5ODMHZ+bgzBycmYMzc3BmDs7IwXlCTxgJM0ETLGEl+A2RgwGSkJEtI1tGtox85uBsJ1jCSvAbzhy8QBJaQk8YCTMhI6+MvDLyysiekT0je0b2jOwZ2TOyZ2TPyGcOznGCX6BnDl4gCS2hJ4yEmaAJlrASMrJkZMnIZw7OeUJPGAkzQRMsYSX4DWcOXiAJGbll5JaRW0Y+c3CuEyxhJTwi6/GAMwcvkISW0BNGwkzQBEtYCRl5ZOSRkUdGPnNQ+wkjYSZogiWsBL/hzMELJKElZOSZkWdGnhn5zEE9f50zBy/wG84cvEASWkJPGAkzQRMysmZkzciWkS0jW0a2jGwZ2TKyZWTLyJaRLSOvjLwy8srIKyOvjLwy8srIKyOvjLwysmdkz8iekT0je0b2jOwZ2TOyZ2S/I9txJEhCS+gJI2EmaIIlrISMLBlZMrJkZMnIkpElI0tGlowsGVkycsvILSO3jNwycsvILSO3jNwycsvILSP3jNwzcs/IPSP3jNwzcs/IPSP3jNwz8sjIIyOPjDwy8sjIIyOPjDwy8sjIIyPPjBw5qCe0hJ4wEmaCJljCSvAbIgcDMrJmZM3ImpE1I2tG1oysGVkzsmVky8iWkS0jW0a2jGwZ2TKyZWTLyCsjr4y8MvLKyCsjr4y8MvLKyCsjr4zsGdkzsmdkz8iekT0je0b2jOwZ2e/I6zgSJKEl9ISRMBM0wRJWQkaWjCwZWTKyZGTJyJKRJSNLRpaMLBm5ZeSWkVtGbhm5ZeSWkVtGbhm5ZeSWkXtG7hm5Z+SekXtG7hm5Z+SekXtG7hl5ZOSRkUdGHhl5ZOSRkUdGHhl5ZOSRkWdGzhxcmYMrc3BlDq7MwZU5uDIHV+bgyhxcmYMrc3BlDq7MwZU5uDIHV+bgyhxcmYMrc3BlDq7MwZU5uDIHV+bgyhxcmYMrc3BlDq7MwZU5uDIHV+bgyhxcmYMrc3BlDq7MwZU5uDIHV+bgyhxcmYMrc3BlDq7MwZU5uDIHV+bgyhz0zEHPHPTMQc8c9MxBzxz0zEHPHPTMQc8c9MxBzxz0zEHPHPTMQc8c9MhBP8ESVoLfEDkYIAktoSeMhJmQkVtGbhm5ZeQzB+04QRJaQk8YCTNBEyxhJfgNIyOPjDwy8sjIIyOPjDwy8sjIIyOPjDwz8szIMyPPjDwz8szIMyPPjDwz8szImpE1I2tG1oysGVkzsmZkzciakTUjW0a2jGwZ2TKyZWTLyJaRLSNbRraMvDLyysgrI6+MvDLyysgrI6+MvDLymYP2uM3wMwcvkISW0BNGwkzQBEtYCXdkOY6j6IxtQa2oF42iWaRFVrSKPOlMx5vKIeWQckg5pBxSDimHlEPK0crRytHK0crRytHK0crRytHK0crRy9HL0cvRy9HL0cvRy9HL0cvRyzHKMcoxyjHKMcoxyjHKMcoxyjHKMcsxyzHLMcsxyzHLMcsxyzHLMcuh5dByaDm0HFoOLYeWQ8uh5dByWDmsHFYOK4eVw8ph5bByWDmsHKscqxyrHKscqxyrHKscqxyrHKscXg4vh5fDy+Hl8HJ4ObwcXg5PhxxHkRS1ol40imaRFlnRKipH5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ5L5blUnkvluVSeS+W5VJ63yvNWed4qz1vleas8b5XnrfK8VZ63yvNWed4qz1vleas8b5XnrfK8VZ63yvNWed4qz1vleas8b5XnrfK8VZ63yvNWed4qz1vleas8b5XnrfK8VZ63yvNWed4qz1vleas8b5XnrfK8VZ63yvNWed4qz1vleas8b5XnrfK8VZ63yvNWed4qz1vleas8b5XnrfK8VZ63yvNWed4qz1vleas8b5XnrfK8VZ63yvPoGFpHkBZZ0SrypDPPb5KiVtSLRlE5rBxWDivHmefr7LSLBqKbpKgV9aJRNIu0yIpWUTm8HF4OL4eXw8vh5fByeDm8HJ6OaCq6SYpaUS8aRbNIi6xoFZVDyiHlkHJIOaQcUg4ph5RDyiHlaOVo5WjlaOVo5WjlaOVo5WjlaOXo5ejl6OXo5ejl6OXo5ejl6OXo5RjlGOUY5RjlGOUY5RjlGOUY5RjlmOWY5ZjlmOWY5ZjlmOWY5ZjlmOXQcmg5tBxaDi2HlkPLoeXQcmg5Is97kBS1ol40imaRFlnRKvKkVY5VjlWOVY5VjlWOVY5VjlWOVQ4vh5fDy+Hl8HJ4ObwcXg4vh6cjGpdukqJW1ItG0SzSIitaReWQckg5pBxSDimHlEPKIeWQckg5WjlaOVo5WjlaOVo5WjlaOVo5Wjl6OXo5ejl6OXo5ejl6OXo5ejl6OUY5RjlGOUY5Rjkizy1Ii6zo4fAjyJPOPL9JilpRLxpFs0iLrKgcsxxaDi2HlkPLoeXQcmg5tBxaDi2HlcPKYeWwclg5rBxWDiuHlcPKscqxyrHKscqxyrHKscqxyrHKscrh5fByeDm8HF4OL4eXw8vh5fB0RHPUTVLUinrRKJpFWmRFq6gcUg4ph5RDyiHlkHJIOaQcUg4pRytHK0crRytHK0crRytHK0crRytHL0cvRy9HL0cvRy9HL0cvRy9HL8coxyjHKMcoxyjHKMcoxyhH5fmsPJ+V57PyfFaez8rzWXk+K89n5fmsPJ+V57PyfFaez8rzWXk+K89n5fmsPJ+V57PyfFaez8rzWXk+K89n5fmsPJ+V57PyfFaez8rzWXk+K89n5fmsPJ+V57PyfFaez8rzWXk+K89n5fmsPJ+V57PyfFaez8rzWXk+K89n5fmsPJ+V57PyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18lwrz7XyXCvPtfJcK8+18twqz63y3CrPrfLcKs+t8twqz63y3CrPrfLcKs+t8twqz63y3CrPrfLcKs+t8twqz63y3CrPrfLcKs+t8twqz63y3CrPrfLcKs+t8twqz63y3CrPrfLcKs+t8twqz63y3CrPrfLcKs+jG8x7UCvqRaNoFmmRFa0iT4o8v6gcsxyzHLMckecjSIusaBV5UuT5RVLUinrRKCqHlkPLoeXQclg5rBxWDiuHlcPKYeWwclg5rByrHKscqxyrHKscqxyrHKscqxyrHF4OL4eXw8vh5fByeDm8HF4OT0c0kt0kRa2oF42iWaRFVrSKyiHlkHJIOaQcUg4pR+T5DLKiVeRJkecXSVEr6kWjaBaVo5WjlaOVo5ejl6OXo5ejl6OXo5ejl6OXo5djlGOUY5RjlGOUY5RjlGOUY5RjlGOWY5ZjlmOWY5ZjlmOWY5ZjlmOWQ8uh5dByaDm0HFoOLYemI7p47vfIT5ueFFu/glpRLxpFs0iLrGgVeVJs/UXl0HJoObQcWg4th5ZDy6HlsHJYOawcVg4rh5XDymHlsHJYOVY5VjlWOVY5VjlWOVY5VjlWOVY5vBxeDi+Hl8PL4eXwcng5vBx+O1p0+dwkRa2oF50OD5pFWmRFq8iTokpdJEUPhxxHYD+xBw5wggoauEAvPKtVooANxNawNWwNWyzacYzABXphLN1xo4ANDJsGDnCCChq4QC+M5TxuFLCB2AaKWM/jsBNj2Y4bI0L8trF0x40dHOAEz2ASv9u1iMeFC/TCaymPCwVsYAdP27lQRjuuRT0uVDBs8bNcS3vE8b0W94jdvJb3uFDABnZwgBE3zslrYY8LvfBalKMFemEszHGjgA3s4AAnqKCB2Lxs0aOTKGADOzjACSpo4AKxCTbBJtgEm2ATbIJNsAk2wdawNWwNW8PWsDVsDVvD1rA1bB1bx9axdWwdW8fWsXVsHVvHNrANbAPbwDawDWwD28A2sA1skYVtBHphZOGNsQ0a2MAODnCCChq4QC+MLLwRm2GLLIxlMK7Fdm6coIIGLtALY+GdGwVsILZrAR4LnKCCBi7QCyPnuwQK2MAODnCCChq4QE+8Fui5UcAGdjDitkADF+iFkd03CtjADg5wgtgEm2ATbA1bw9awNWwNW8PWsDVsDVvD1rF1bB1bx9axdWwdW8fWsXVsA9vANrANbAPbwDawDWwD28A2sU1sE9vENrFNbBPbxDaxTWyKTbEpNsWm2BSbYlNsik2xGTbDZtgMm2EzbIbNsBk2w7awLWwL28K2sC1sC9vCtrAtbI7NsTk2x+bYHJtjc2yOzcvWjwMUsIEdHOAEFTRwgdioJZ1a0qklnVrSqSWdWtKpJf2qJT1wgV541ZILBWxglHgPnKCCBi7QC6/bgwsFbGAHsXVsHVvH1rF1bAPbwDawDWwD28A2sA1sA9vANrFNbBPbxDaxTWwT28Q2sU1sik2xKTbFptgUm2JTbIpNsRk2w2bYDJthM2yGzbAZNsO2sC1sC9vCtrAtbAvbwrawLWyOzbE5Nsfm2BybY3Nsjs3LNo4DFLCBHRzgBBU0cIHYBJtgE2yCTbAJNsEm2ASbYGvYGraGrWGjlgxqyaCWjOtmRAMX6IXXzYgFCtjADg5wglEcw3bdjFy4wLCdt7fjuhm5UMDTdq6a0qIDKXGAp230QAVP2xiBC/TCqCUjdjNqyY0NDFtsQ9SSGyeooIGrMKrGiN2M+jCPwDPCjE2P+nCjgQs8t3fGDkV9uFHABnYwtncGTlDBsMVuRn240QujPsz4t1EfbmxgBwc4wdi3OAmiPty4QC+81gi9UMAGdnCAYYtDHfXhRgMX6InRjpQoYAM7OMAJhm0EGrhAL4z6cKOADexg2DxwggoauEAvjPpwo4AN7CC2hq1ha9gatoatY+vYOraOrWPr2Dq2jq1j69gGtoFtYBvYBraBbWAb2Aa2gW1im9gmtoltYpvYJraJbWKb2BSbYlNsik2xKTbFptgUm2IzbIbNsBk2w2bYDJthM2yGbWFb2Ba2hW1hW9gWtoVtYVvYHJtjc2yOzbE5Nsfm2Bybl02PAxSwgR0c4AQVNHCB2ASbYBNsgo1aotQSpZYotUSpJUotUWqJUkuUWqLUEqWWKLVEqSVKLVFqiVJLlFqi1BKllii1RKkl0RUl59pTLdqi5FwIqkVfVOICvTBqyY0CNrCDA5wgtoFtYBvYJraJLWrJudROiz6pxAFOUEErjKpxru/QogvqMeIZOMCIsAIVNHCBXhj14UYBGxi2+AGiPtw4wdNm8bNEfbhxgV4Y9cEk8IxrLXCAE1Qw4sZxiEpgscdRCSwOSVQCi+291h6PLYtKsEIcleDGAU7wtK3YsqgENy7QE6MpSs6u+Ba9UI8R2sBQaGAoLDAUHngqvAUauEAvjPS/UcAGnjaPbYj0v1HzLIl+qMQFemE7QAEb2MEBThBbwxY579dq2V4YOX9j7FD828j5Gzs4wAkqaOACvTBy/kZsA1vkfEzuRqtUYthWoIJhi18zVjGPieDojUpsYAfHiXHCxHrmNypoYNTJ68+88LpTuFDABnZwgBNU0K9+iRZ9UY+h+UABG9jBAcZOxGkWS5zfaOACvTCWOr9RwAaGbQQOcIJhi02Phc9jSjg6pVpM80ar1I2x/PmNAjawg3qvpx+9UTetIr8peqNukqT4NkDM9Ua7UuIEFTRwgV4YXwq4UcAGYmvYGraGrWFr2Bq2jq1j69g6to6tY+vYOraOrWMb2Aa2gW1gG9gGtoFtYBvYBraJbWKb2Ca2iW1im9gmtoltYlNsik2xKTbFptgUm2JTbIrNsBk2w2bYDJthM2yGzbAZtoVtYVvYFraFbWFb2Ba2hW1hc2yOzbE5Nsfm2BybY3NsXrZYsStRwAZ2cIATVNDABWITbIJNsFFLnFri1BKnlji1xKklTi1xaolTS5xa4tQSp5Y4tcSpJU4tcWqJU0ucWuLUEqeWOLXEqSVOLXFqiVNLnFri1BKnlji1xKklTi1xaolTS5xa4tQSp5Y4tcSpJU4tcWqJU0ucWuLUEqeWOLXEqSVOLXFqiVNLnFri1BKnlji1xKklTi1xaolTS5xa4tQSp5Y4tcSpJU4tcWqJU0ucWuLUEqeWOLXEqSVOLXFqiVNLnFri1BKnlji1xKklTi1xaolTS5xa4tQSp5Y4tcSpJV61pB9VS/pRtaQfVUv6UbWkH1VL+lG1pB9VS/pRtaQfVUv6cWATbIJNsAk2wSbYBJtgE2yCrWFr2Bq2hq1ha9gatoatYWvYOraOrWPr2Dq2jq1j69g6to5tYBvYBraBbWAb2Aa2gW1gG9gmtoltYpvYJraJbWKb2Ca2iU2xKTbFptgUm2JTbIpNsSk2w2bYDJthM2yGzbAZNsNm2Ba2hW1hW9gWtoVtYVvYFraFzbE5Nsfm2BybY3Nsjs2xUUuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJXCndAzs4wFCMQAUNXKAXXil94blD1/fCWlEvCpUGTlDBUK3ABca4wbkL7Ro4uFDABnZwgBNU0MAFYhNsgk2wXd8zbIEDnKCCBi7wtJ17eX3c8CIpakW9aBRFxPOXu75feDb59usLhu36HlsDOzjA2FILVNDABXphZOe1DZGdNzbwtPUjcIATPG3xhbnrC4c3nrYeOxTZeWFk541yf5cu+h5v6kWjaBZpUUSMQxS5dn+XLrZUAwc4QQVjS2MHI9du9MLItRsFbPXtu140is5Nja2KL6xdZEWryJPiK2sXhcQDG9hBBc/NHHHwI19vPA9oHNr4ntpFveg8IiOOXuTrjQqeR2TEtkS+3hiq65N+ByjgubFnn0i/vnM4LDBsK/C0nU0cPdoREw1coBdGvt4oYAOjFLXA03Y2fPRoR2xnD0GPxsM2r48QRtzYyEjNGwVsYAcHOMEIFrt5fWr0QgEb2MEBzsLrS6JxoK5viV7YwQHGn3ngeSTPyb7e80tOveennHrPbzn1nh9z6j2/5tR7fs6p9/yeU+/5Qafe84tOvecnnXqf5ZjlmOXQcmg5tBxaDi2HlkPLoeXQcmg5rBxxk6wXzvpepBZZ0Sry+pzkUSRFragXjaJy1LcN+bghXzfk84Z835APHPKFQz5xyDcO+cghXznkM4d85zA699o5Zdqjcy9xgOcZck5M9ujca+fkaI/OvaYRIbLqnGzs0XfXzgnEHn13zeLfxpXtxgWep/y54GOPvrtEARvYwQFOUMGwzcAFemEk2Ip9i1RasTmRSjeecdf1bxU0cIFefxZXvRsFbCC2gS0y8EYFF+jXp8X69SXDi6SoFfWiURTBNVBBK4ybzRtj8+IYxqVuxW8el7obFTRwgV4Yl7obBYyDEWdNPKLeOMDT5nEuxSPqjQaeNo8zLB5RL4xH1BsFbGAHBzhBBQ3EtrA5Nsfm2BybY4tLpMd5F5fIGy0xWufa+fJ9j365ds7d9uiMS4zN0cDYnPPHih64RAEjwgrs4FkfzsnFHn1t/QhbfOfzCEV86fPC+NbnjQKeVeeIbYgvft44wAkqaOAqjO/tHrG98cXdGzsYcWPT47u7Nypo4AK9ML7Ae6OA8W890Avjm7o3CtjADp5bdr6b2qNPLFFBAxfohfGd3Xjyij6xxAZ2MGzxu8XFKJ7HoiOsx4NVdITdGNejGwVsYAcHGHsRv3FclW40MGzxu8WF6cK4Mt0Ytjg6cW26sYMDnKCCBi7wtLXzmEVHWI8nI72+d90DFTRwFV5fuR6BDezgACeooIELjC07j070cyUK2MAOhkIDFYxg52kfLVg9HpWi2aqfHeU9mq16PB9Fs9WN52Unbk6j1+qmVtSLRtEs0iIrWkUhOc+/6LFKFLCBHRzgBBW0wsi4eP6KHqsezxXRYxU32dFidZMWWdEq8qTIqnj8ie6qxAZ2cIATjMMcwSJ/4uEulpJKPC+0sc3xodyLZpEWWdEqimMav2xkzo0CNrCDA4yjd54Q0RXV40Et1oqKO/roj7qpF50H1IJmkRZZ0SrypPhMdWx89EUlNnCC8TjaA70wUuPGczM1qBX1olE0i7QonnpH4AK9MC5YNwrYwA4OcIIKYuvYIu/iyTQanhIFDFsc9LiM3Ri2+M3iMjbjN4vLWDxtRsNT4gJPW+RitEElnrY42aMNql9HJz5dFmHj22UXzSItsqKVFBe769eOy9p10sRl7f4HChp4bmk8NUWr042RgDcK2MCIGzsYqRaPGdG/1OPZIvqXEgVsYAcHOEEFDQxbHLhIwwsjDW8MWxzOSMMbOzjAsMUxiwvYjQaehzd2Lb5bdtL18cCLHqo4BtfnAy/qRaNoFmlRSFbgAr0wUvbGDsZmeqCBZ4R4eov+qBsjZW+U6ytnvT4a2Ourgb0+G9jru4G9PhzY68uBvT4d2Ovbgb0+Htjr64G9Ph/Y6/uBvT4g2OsLgr0+IdjrG4K9PiLY6yuCvT4j2Os7gr0+JNjrS4I9GqH62SbboxEqUcHzkFn8dpGhN3phZGg8YUYjVOJ5Hlkc/7hE3jjACSoYtviB4lb1xtO24leJC+eKLYvsXXFmxK3qjR08bfHAG41QiQra9Sm5fn158CJPim8PXiRFrSgijsBzS+OxONqaejxWRltTooANjC2N3Y5svnGCChr4sF1naK6h3leux9ajIykemqIh6Sa/KdqRHiMpgQI2sIMDnKCCBi7QCwWbYBNsgi1uRON5MdqREhU0cIFeGKuwjaBW1Isifg+coIIGLtAL4yp7Hca4yt7YwNgbDRyg3j+S5zLp3XOZ9B4tRzH0EB1HN0lRBL+wgwOcoIIGxq6sQC+MlL3xPGpHUCvqRaNoFmmRFa0iT8r1VbtrObQcWg4th5ZDy6Hl0HJoOawcVg4rR9zxnu3WPTqLEid43rIe1781cIFeeKZzooAN7OAAJ4htYYtb5CNyYHmhH6CADezgACeoYNgiSXyBfuO4FjvrQVLUinrRKJpFETFQYktHYGzpDOzgACcYW2qBBi7QC9sBhs0DG9jBAU5QQQMXGOPkcmKPgfI4RD1G42N7ewM7OMAJKmjgAr1wHCC2gW1gG9gGtoFtYBvYBraJbWKb2Ca2iW1im9gmtoltYlNsik2xKTbFptgUm2JTbIrNsBk2w2bYDJthM2yGzbAZtoVtYVvYFraFbWFb2Ba2hW1hc2xRGc4hqBF9QolhixSJynDjBBWMJ/UjcIGeGH1CiQI2sIMDjFEBCVQwFC3QC+UABQxFD+zgACeoWXfkKiAXLtALrwJyoYAN7OAA7brpGtfnDy/ypPgsWvy7+CzaRa0otv/CAU5QQQMXeJriEMbH0S6SojhUM7CDA5zXF8ZGfQdx1HcQR30HcdR3EEd9B3HUdxBHfQdx1HcQR30HcdR3EEd9B3HUdxBHfQdxyCyHlkPLoeXQcmg5tBxajqgF5zjiiD6fRC+MWtDi30YtuLGBHRzgBBU0cIFhWydGLbhRwIdtxZkSn1G6aBTNIi2ypMj3cxx0RMPQ6Nd/e25pj58/MvtGBQ08t7RHpkRmB0bHUKKADQzbCBzgBPX6PNVo+VG00fKjaKPlR9FGy4+ijZYfRRstP4o2Wn4UbbT8KNpo+VG00aQcUg4ph5SjlaOVo5WjlaOVI24JztHOESupjXOQcUTrUOICvTBuCW4UsIEdHOAEsXVsHVvHFrcE55jniIaixAZ2cIATPOOek/0jWoOinkRr0E3nH434vePKfqOCBi7QC+PKfqOA5yaOUMSV/cYBhi0Of1zZbzRwgWE7szl6hsbZFjOiaShxgBOMuHEUIm/PwccRnUNjxgGJvJ2xvZG3M7Ys8naGOK7hN3ZwgKdtxpbFNfxGAxcYtvhZ48KtsTlx4dbYnEhvjZMz0ltjcyK9NXYo0vtGAxfoidFglChg2FZgB2eeI9FVlGjgqYhLXXQV3RgX7htPRVyNoqsosYMDnKCCBi7QC+PCfSO2hi0u3HHFjV6jxLD1QAXDdh7qaDsa55jViLajxAZ2MOJq4AQVNHBlse5XQgdeCX2hgA3s4AAnGEcnfs24m78w7uZvFDD2In7juJu/cYAT1HsQa0SHUuICvfAahLtQwAZ2MI6OBxq4QC+Ma/WNAp57ERfDWK0scYATVPCMu+LUiDyOsh9tSWPFSRB5fOMEI0KcO5HHN57be+1Q5PGFcW2+8dzeFb98pPSNHRzgBBU0MGzxE0ZKB8YKZIkCNrCD4x7oHtGxdB2HWGsssY5O9DGNc2xxxFpjiQ3s4LkX5+jKiJ6nRAVP2zkgN6LnKdELI49j6CB6nhIbGLbY9Mjjc/xuRM/TOMfZRvQ8jXNwbUTPU+IqjDz2OA6Rxzd2cIARN/YtMjbOkuhuujEy9kYBOxjTCxcauMCYoIh9i4G3GwVsYAcHOEEFrTAuwh7HLC7CNzawg+dk4xE/Vswy36iggTEnF0cnZroujJmuGwVsYAcHOEEFY2YxDtQ6wHO+9IjT80zexA4OMPbi+jMFDVygF57JmxjzmHEkY/7rxg4OcIIKGrjAnAse8zjA2IsLBzhBBWMvRuACvVAOMPbiCGxgBwc4QQUNXIUxdx1DdbHkV2IHBxh7oYEKGrhAL+wHKGADw2aBA5yggmFbgQv0wugcuTEbHcbViHVjBwc4QQUNXKAXXs0iLTD2wgMHOMFzLySO+pndU+IkOC/CiV545nyigA3s4ABPm8QJE20kMZR0NWLFc1+0XM0YSoqluRIVNDAixFE3L1wHKGADOzjAWdsQM183GrhAL7zaSS5kL652kgs7GHsRv7zHXsRR9wV6YrRcJZ57ESNbsQhXYgfPvYhBrmjPSlTQwAV6YeTxjWFrgQ3sYNh64AQVNHCBXtgOMGwjsIEdDNsMnKCCBi7QCyO7bwybBjawg2FbgactbnpjEa4ZoxnRFzYjnaIvLNELI7tvPG0xWHF1hsXj/tUaFrl59YbdOEEFwxabE/1h8VAdDWIzimM0iCUK2MDYNwsc4AQVzJ63EV8sTPTCuPG+UcAGdnCAE4wutziS0Tt2oR2ggLEXcSStgwOcoIIGLtALoz7cGHHjRIxKcOMEI278hHFFv3GBXhhX9BsjbvzckfMxehAtZIkL9MRoLEuUu+d42NWUfGEHBzhBBQ1coBdGdsdYRayxlTjACcZenCfi1UsW4xpXM9mNHYw2wiNwggpG1+D5G0fv2IwxkOgdmzEGEr1j93GI3LxxgBNUsI5vdInNGCSJLrHEBnZw3A34w66XAi5U0MAFemG8CnejgA0840byXsti3WhgtFRe/9YL4xo74x/ENfbGBkYPXxzUuMbeOMFo42uBBi7QCyMLb4x+wTg6kYU3dnCAE1TQwFUY12ONXyjeB4gaFb1iM0aIolcs0Qsjs2KwKHrFEmPL4jhEvt04wGi6DEVk4Y0GLtATo1ssUcDTFkM90TCWOMAJKmjgyj2OzwLOGACK7wImdnCAEbcHKmjgAs9zMi4z11JbNwrYwA4OcIIKxtE5czO6xxIFbGDsRfxZZOyNE1TwzIB2/dkCvfB6pfVCARvYwVEYvZiRetHolaiggQv0wjP1EgVsYAexKTYN2wo0cIFeGL1eNwp4xo1xjWj3SlTQwAV64YoesjgkS8AGdjBs8bOsCWqhHxXXBWxgB9l0Z9Ndy+YGLtATo1fsEkevWGIrjHmYGKiJNqwbYybmxnMqJsTRkrXOTq8RPVmJA5zgOecTg0XRlJW4QC/sEbcHRoTY9Oi5utFAr38bzVbXXkS31Y0N7OAAJ6hgKCxwgV44w7YCBWxg2DRwgBNUkB2aC/RCPUABG9jBAXL4lMN39UDGXlxNkBc2sIMDnKCCBi7QCxe2hW1hW9gWtoVtYVvYFraF7UqnOKhXOl3YwA4OcIIKGrhAv3EexwEK2MAODnCCChq4QGyCTbAJNsEm2ASbYBNsgk2wNWwNW8PWsDVsDVvD1rA1bA1bx9axdWwdW8fWsXVsHVvH1rENbAPbwDawDWwD28A2sA1sA9vENrFNbBPbxDaxTWwT28Q2sSk2xabYFJtiU2yKTbEpNsVm2AybYTNshs2wGTbDZtgM28K2sC1sC9vCtrAtbAvbwrawOTbH5tgcm2NzbI7NsTk2aolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSuWrICo7tPAr3wrCWJAjawgwOcoIIGYlvYHJtjc2yOzbE5Ng9bCzRwgZ4YfWCJAoZtBHZwgGGzwLCtQAMX6IVygAI2sIMDnCA2wSbYBFvD1rA1bA1bw9awNWwNW8PWsHVsHVvH1rF1bB1bx9axdWwd28A2sA1sA9vANrANbAPbwDawTWwT28Q2sU1sE9vENrFNbBObYlNsik2xKTbFptgUm2JTbIbNsBk2w2bYDJthM2yGzbAtbAvbwrawLWwL28K2sC1sC5tjc2yOzbE5Nsfm2BybY/Oy9eMABWxgBwc4QQUNXCA2akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5Z0akmnlnRqSaeWdGpJp5YMasmglgxqyaCWDGrJoJYMakn0wNnZVzGjBy7RC6OW3ChgAzt42s4Oihk9cIkKxr5ZYNgu9MKoJTcK2MAODnCCsW8aaOACvfCqJRcK2MAODnCC2Dq2jq1jG9gGtoFtYBvYBraBbWAb2Aa2iW1im9gmtoltYpvYJraJbWJTbIpNsSk2xabYFJtiU2yKzbAZNsNm2AybYTNshs2wGbaFbWFb2Ba2hW1hW9gWtoVtYXNsjs2xOTbH5tgcm2NzbF62eRyggA3s4AAnqKCBC8Qm2ASbYBNsgk2wCTbBJtgEW8PWsDVsDVvD1rBRSya1ZFJLJrVkUksmtWRSSya1ZFJLJrVkUksmtWRSSya1ZFJLJrVkUksmtWRSSya1ZFJLolHvKtDRqJfohbOqcqyYltjA2LL4t1fO98AODnCCChq4QC+8cv5CAbEZNsNm2AybYTNshm1hW9gWtoVtYVvYFraFbWFb2BybY3Nsjs2xOTbH5tgcm5dNjwMUsIEdHOAEFTRwgdgEm2ATbIJNsAk2wSbYBJtga9gatoatYWvYGraGrWFr2Bq2jq1j69g6tsj5s8FyRvuenR2NM9r3Eg1coBdGzt8oYAM7OEBsA9vANrBFzp+tlDPa9xIFbGAHBxh3Yh6ooBVetwcjsIEdHOAEFYxNv3CBXhil4uyqnNGzl9jA2HQLHOAEFTRwgV4YpeJGARsYttj5KBU3TlBBAxfohVEqztbPGUvEJTawgwOcoIIGnrYehy9KRWB0/SUK2MAODnCCChq4QGyCTbAJNsEm2ASbYBNsgk2wRak4e4hm9A0mNnCCEUEDvTDS/0YBG9jBAU5QQQPD5oFeGOl/o4AN7OAAT9vZMTqjbzDRwNM2Qhzpf2Gk/40CNrCDA8Q2sU1s8fgwYsvipuHCeHy48fxvz2bMGV1/iQLWg64xZGAMGRhDBsaQgTFkYAwZGEMGxpCBMWRgDBkYQwbGkIExZGAMGRhDBsaQgTFkYAwZGEMGxpCBMWRgDBkYQwbGkIExZBB9g3Y2sM7oG7ww+gYTBWxgBwc4wdN2dsPO6BtMXKAXRh7fKGDYRmAHBzhBBQ1coBdGHt8oILZWAxTrGjK4cIJhm4EGLtALI+dvFLCBHYx9W4ETVNDABXph5PyNAjawg9gGtoFtYBvYBraJbWKL7D57eme0JprGMYs81ji+kccXRh7fKGADOzjACSpoIDbFZtgMm2EzbIbNsBk2w2bYDFvUB40fNurDjQ2cYETQQC+MnL9RwAZ2cIATVNDAsMWPFTkfGF2KiQI2sIMDnGDYPNDABdYjol/DhBcKeNrOJuUZK9olDnCCChq4QC+MnD/7ime0UiY2sIMDnKCCBi7QCzu2jq1j69g6to6tY+vYIrstDlTk8dl4PKOr0iyO77U8zYUKGrhAL7zWqLlQwAZ2ENvENrFNbBPbxKbYFJtiU2yKTbFFzq/4YSPnb1yFkd03nhHOt7NntFImKmjgAr0w8vhGARvYwbDFjxV5vOLHijy+UcAGdnCAE1TQwNjeOAkij0/UaI9MFLCBHRzgBMPmgQYu0Asjj28UsIEdHOAEsQk2wSbYGraGrWFr2Bq2hq1ha9gij8/+ao32yBsjj2/s4Bnh7K/WaHlMXKAXRsbeKGADOzjACYatBxq4QC+MPD67jTVaHhMb2MEBTlBBAxcYtjhLIo9vFLCBHRzgBBUMW/wWkcc3emFcu28UsIEdHOAEFcRm2AzbwrawLWwL28K2sC1sC9vCdtaHdcQZddaHRAEHeHaqH3E+nDmf6InRxpgoYAM7OMAJKhhxzzMqmhDXOYqi0YSYqKCBC/TCeInhRgEbGFs2Awc4QQUNXKAX9gMMmwc2sIMDnKCCBi7QC+PdhxuxDWwD28A2sA1sA9vANrBNbBPbxBbvPpxPKBpNiIkTXIXxPoPEzx3vM9zYwQFOUEEDF+iFZ8Ymhi3OKGtgBwcYtjg1TEEDF+iF6wAFbGAHwxZnSawYd6OCBi7QCyNjbxQwbPFbeAcHOEEFDVygJ0ZjYaKADezgACeooIELxCbYBJtgE2zXQnNH4AQV9MJrETkJ7OAAJ6iggQv0wsj5GwWMuC1wggoauEAvjOy+UcAGdhDbwDawDWwD28A2sU1skd3nILVGW2DiACeooIEL9MJ4s+nGsFlg2GZgBwc4QQUNXKAXRiW4MacD9WoLvLGDYVuBE1TQwAV6YVSCGwU8963HQY1KcOMAJ6iggQv0wqgENwqIzbE5Nsfm2BybY/OyRVtgooAN7GDYeuAEFfTCyO5zmFuj1S9xgBNU0MAFemFc/W+UwrgenwPlGs13iQMMmwYqaOACvTAy9kYBG9jBAaKI1OsW2MAOxp+twAkqaOACvTBS70YBG9hBFJFD5wi9RjtcYgPPPztfydZoh0ucoIIGLtALI4duFLCBKCIZzmUuNPraEgWMP4tzMpLhxgFOUEEDF+iJ0deWKGAH4896oBfG9e3G+LMR2MAODnCCChq4QC+MDLgRRVzqzkU1NPrPEg2MYBrohXGpu1HABnZwgBNU0EBskTjnQhkanWbrXChDo9MscYATVNDABcYAUOzbNdx0oYAN7OAAJ6hgHJ0zA6KnLFHAcy/OmSCNnrLEAU5QQQMX6IWRkDcKiC1S75wM0egeWzPOyUi9GxfohZF6NwrYwBiGDUU8et44QQUNXKAXXkPMF8bUwIUDnGBOIOmoCSQd1XOqo3pOdVbPqc7qOdVZPac6q+dUZ/Wc6qyeU53Vc6qz+td1Vv+6zgObYBNsgk2wCTbBJtgEm2ATbA1bw9awNWwNW8vJMb36xG40cIFe2A9QwAbG79YDBzhBBQ1cYE6O6dUndqOADezgACeooIELxDazV1jvPrELG5iTYzqvaaULJ6iggQv0Qj3AnK7Sq//sxg4OcIIKGrhAL7QDxGbYDJthM2yGzbAZthiaOmfadFIJrp4yjeO7FDRwgV7oByhgAzs4QGyOzbE5Ni/b1VN2o4AN7OAAJ6hg2GbgAr1QGpiTY3r1id1o4AK9sB2ggA3s4ABzckyvPrEbDVygF/YDFLCBYfPAAU4we+j16hO7cYE5OaZXn9iNAjawgwOcoII5XaVXn9iNXjgPUMAGdnCAE1QQ28Q2sSk2xabYFJtii+y2OFBWdytXc5jF8bUGdnCAE1TQwAV64TpAbAvbwrawLWwL28K2sC1sjs2xObZrYip+2Gti6sIJ5qSbXg1f5zSYXg1fN3ZwgBNU0MAFeqEcYNh6YE6O6dXEdeMCvbAdoIAN7OAAa3LMrgmkCw1cYE3FXQ1fNwrYwJquuhq+bpygggYusCbHroavGwVsILaBbWAb2Aa2gW1gm9gmtoltYpvYrsmmOGGuyaYLrVAPsCbHTAc4QQUNXGBNxV3NYTcK2MCwxRl1TSBdOEEFa3Lsag670QvXAQrYwA4OcII1OXY1h924wJqKu5rDbhSwgR2s6aqrOexGBQ1cYE2OXc1hNwrYwA4OcIIKGrhAbIJNsAk2wSbYBNs1XXUEGrgKm4A1ObbaBBU0cIE1Fbf6AQrYwA5G3POMWqMmx9ZoYAcHOEEFDVxgTcWtWZNj65pAurCBHRzgBBU0sKarorXrRj1AARvYwQFOUEEDsSk2w2bYDJthM2yGzbAZNsNm2K7JpjhhrsmmCxs4wZocW6smx5YfoIAN7OAAJ6iggWGLM+qaQDrRrwmkCwWsyTE/OjjACSpo4AJrKs7lAGtyzK8JpAs7OMAJKmjgAmu66lol70YBG9jBAU5QQQMXiK1j69g6to6tY+vYOraOrWPr2Aa2awrqCGxgBxWsybFrwbwbBWxgBwc4QQUNrKm4a2m8mK66lsa7sYMDnKCCBi6wJsfcDhCbYTNshs2wGTbDZtisJsd8HaCADezgACeooIFhs8CaHIvmsEQBG9jBAU5QQQPjWS9sce0+0a7msBtzcsyiOSyxgwOcoIIGLjCnqyyawxIFbGAHBzhBBQ1cILaGrWFr2Bq2hq1ha9gatoatYevYohKcE2l2XFNbF3ZQwZwcs2McoIAN7OAAJ6iggaswsnteOMAJKmjgAr0wrug3CthAbIpNsSk2xabYFJthM2yGzbBFzp/fBrPjGnW/UEEDF+iF16j7hQI2MGxxgkfO3zjBsHmggQv0wsj5GwVsYAdPm8a5Ezl/o4IGLtATr+awGwVsYAcHOEEFDVwgNsEm2ASbYBNsgi1y/hzZs6u97MZVGNl9Y0SYgRNU0MAFemHk8Y0CNrCDYbPACSpo4AK9MHL+RgEbGDYPHOAET9s51mZXy9iNC/TCuPrfKGADO3jaLA5q1IcbFTRwgV4Y9eFGARvYQWyKTbEpNsWm2AybYTNshs2wGbaoDxY/bNSHG1dhVIIbI4IGTlBBAxfohZHzNwrYwA6GLc6HyG6LXz6y+8Yz7jnsZldz2I0CnnHPkTK7msNuHOAEFTRwgV4Y2X2jgNgEm2ATbIJNsAk2wdawNWwNW8PWsDVsUQnOr4vZ1Uh24wK9MCrBjQLGZN4MjD/rgV4YKX1j/NkIbGAHBzhBBQ1coBdGSt+IInJzxUZGbt7ohZGb5yfx7Gr4urGBHRzgBBU0cIFeaCgiyXpsQyTZjQvM/h27OrduFLCBHRzgBBU0cBU6iqsFywIVNDD7d+xuwTrxbsG6UMAGdnCAE1TQQBTXrbAHTlDB7N+xq+/qRi9sByhgAzs4wAkqiOLqL5HAAU4w+3fsate6cYFeOA5QwAZ2cIATRBHJcHb12NWudeMAs3/HrnatGw1coBfqAQrYwA4OEEXkxdnVY1cT140CZv+O3U1cFw5wggoauEAvXAcoILZInLPXx2L1sujUsVi9LHGBXnh1eV0oYAOzf8eu1ctunKCCBi4wu4XsWr3sxjg6HjjACWb/jsU6ZYkL9EI5QAEb2MEBThBbpN7ZjmFXw9fZqWOxIlliAzs4wAkqmP07dq1IdqMX9gMUsIEdHGDU6vOXH9fl60IB48qwAjs4wAkqaOACvfC6fF0oIIrzjPIYoIg1rBI7OE6Mn/s8oxIVNHCBnhi9SYkCNrCDA5xg2aLfyM9hN4vOIj/HxCzaifK/PTfnHGOyaCfy81txFu1EN54nTKKADezgAM/NOQeWLNqJEg0M2wwM25nz0U7k5yCURTuRx5hNtBPdm947yA6dFdyPEJ/nzo3nuZMoYAM7OMAJKmhg2GIvRthiL+YBCtjAsMVuzgFOUEEDF+iFeoARN46ZRoQ4Zhp/FieBxskVP7cdoIANnGCcnnF8zQtXRIgTZsWJGIdkxb+NQ7K80A8wbHEcrsS5sIMDjG2IfbsS50LjHyzQE/VKnAslj0M07SR2cICWexztOdduRnvOjXIUXl+L8cABTjB+gOvfGrjA+AnPw6fXCXOhFMaS6VG2Y72gRD0xIsSS6Tcu0AtjyfQo0NESktjADg5wggoauEAvXNji6wpnz55Fx0eiggYu0Avj6wo3CtjADmKLryvEWFssB5Ro4AI9MZYDShSwgR0c4AQVLFss5qMxWBSL+ahe/62CBi7w3LIYyYk+kEQBG9jBAU5QQQMXiK1j69g6to6tY4tvI5yNZBZ9IIl+fnMsMD4NeKOADewnWuAAJ6ignbgCF+iF8YHOGwVsYAcHOEEFsU1sE5tii08DxsDH9RHAGOK4vvwXT/nXl/8ujC//3ShgAzs4wHMj44H/+vLfjQYu0Gsb4vubNwrYwA4OcILsUHw78MIrNy9s4HmW3P9ggBNUsIqY+QKrrKzjAAVsYAcHOEEFDVwgNsEm2CJ546BGD0ZiAzs4wKc/U9DABXphZOGN2Dq2jq1j69g6to6tY+vYBraBbWAb2Aa2gW1gG9gGtoFtYpvYJraJbWKb2Ca2iW1im9gUm2JTbIpNsSk2xabYFJtiM2yGzbAZNsNm2AybYTNshm1hW9gWtoVtYVvYFraFbWFb2BybY3Nsjs2xOTbH5tgcm5ft+hDhjQI2sIMDnKCCBi4Qm2ATbIJNsAk2ikL0gSRiE2yCrWGjlji1xKklTi1xaolTS5xa4tQSp5Y4tcSpJU4tcWqJU0ucWuLUEqeWOLXEqSVOLXFqiVNLnFri1BKnlji1xKklTi1xaolTS5xa4tQSp5Y4tcSpJU4tcWqJU0ucWuLUEqeWOLXEqSVOLXFqiVNLnFri1BKnlji1xKklTi1xaolTS5xa4tQSp5ZcX2GMsfjrK4wXXrXkQgEb2MEBTlBBA7EtbI7NsTk2x+bYHJtj87StaP6YNypo4AK9UA4w7o1mYAPj3kgDBxg2C1QwbCtwgV7YwuaBAp62s5l4RfNH4mk7m35XNH8knrbzW6grmj8SF3jazv7fFc0fiafNYzfjy8E3hi12M74cfGPYYjfjy8E3Ghi22OO4zb8wbvM9djNu828MW+xm3ObfeP6wR+xmpP+NCp4/7BF7HOl/43kaHbGRkf43CtjADg5wggoauEBsik2xKTbFptgUm2JTbIpNsRk2w2bYDJthM2yGzbBF+h/xs0T6Xxjpf6OADezgACeooIHYFjbH5tgcm2NzbI4tbhrOEa11fQzxHLNZ18cQzzGmdX0M8cYBTlBBAxfohXF7cKOA2ASbYBNsgk2wCTbB1rA1bA1bw9awxe3BOeS1ro8h3miFcSNwY0TQwAFOUEEDF+iFccm/UcAGhs0CBzhBBQ1coBdGzt8oYNjifIicv3GAE1TQwAV6YeR8i5Mrcv7GBnZwgBNU0MDT1uJ3i5y/MHL+RgEb2MEBTlBBA7EZtoVtYVvYFraFbWFb2Ba2hW1hi5xvcfZFzt/YwAlGhDh34pEgMNpHEgVsYAcHOEEFDTxt51LhK9pHboyc7xJ42s7+yRXtI4mn7exdXNE+kjhBBQ1coBdGzt8oYAOxNWwNW8PWsDVsDVvH1rF1bB1b1IceByrqw40KGrhAL4z6cKOADexg2CxwggoauEAvjJwf8btFzt+ooIEL9MLI+RG/ceT8hZGb5/z8ip6RxFYYp/2IYxan/YVx2t8YfzYDG9jBAU5QQQMX6InR8ZHYwAimgQoaGMEs0AsjA24UsIEdHOAEFTQQW5zr50z8io4PPefGV3R8JA5wggoauMCo4Gce9+uqd6GADezgACeohXEqn+/drugDUYu9iFP5xg4OcIIKGrhAL4xL3Y3YJraJbWKb2Ca2iW1im9gUm2JTbHGps/ix4lJ34wQVNHCBXhjpdKOADcRm2AybYTNshs2wLWwL28K2sC1sC9vCtrAtbAubY3Nsji1y3uJMjZy/cYIKGrhAT4yuk0QBGxjj4DMwxsE10MAFeuE1Dn5hjINbYIyvr8AJKmjgAr0wLnU3RtzYyEj/Gzs4wAkqaGDMZx2BXnjNZ10oYAM7OMAJxpSZBC7QC6Mo3ChgAzs4wAkqiG1gi6Kg53Uo2lISBWxgBwc4QX6syY81+bEmP1Ykg8YvH6e9Xv/tAr0wTvsbpU65a1Lowg4OkNPzmrC90MAFeuK8JoUuFLCBHRzgBC33Ldbq0bNpfUWXTGLLHYpVeRIHOMHI2CPQwAVGxp6/ZrTRJAqIrWFr2Bq2a0b3QgMXWD/L7AcoILbrtF//9V//9Ie//v1f/vTvf/n73/753//x5z//4Y//Wf/Fv/3hj//jP//wr3/6x5//9u9/+OPf/uOvf/2nP/w/f/rrf8Q/+rd//dPf4j///U//ePyvj93989/+9+M/HwH/z1/++ueT/uuf+Ovj4z99PKCfdyTx548n9GNWCF8/xJCPY9jKCI+xovp7nT/8ffv47+f5DBJ/Pye78HjKfXUDoif32oDpH23A+Pjvx9k5G38/Hr/KOxtwDmVeG+Drow3Qj/8+Rori7x9PSO9sQDSRRYDHNMJHG7A2G7DyHLLj459gdx49Lqa5CY9BCZEPz6NNkBZtOhHjcd/8dCCO4+UYj3tvrRhuTzH66zHkyN/zcZfsH8fomwMSTQnX8Xg8vz7FsB9j7M7LVYkx+FUfAzKvb8Wq3HoMLqyPt2Jzcp4fM8vN0NUrxhyvh7AqMucXnj4MsTlD2zz3M0I8HijlwxC+ydKZ+/GY9OVQ9B9P0LY7QaUqzWPcgY0Y7ccQm0xti1P8wwC/OJbCsVwfHYi2PSusav5jevDDs6Jtzs3HCGGd39Pah5sxdum+vI5FPz7eDN1tho3aDHnalfXT5cd21Xf9d9V3vb4nj6KT58Xjyf3jNGubs/MxTN3qV3kM3j3ti/yY8P34+vHo8uXjsduXxxhgnqSPIfWnu4Lf7EvfZZu1yrb1VIbXj0e1784xOyqGNU5T/cS+9LVqX8bY/C6b87RpXZaa6lMx9x8zv9vustRWnWXzOcZP27Epo71bnamPp+KPY+y2o41Zl8f18XaMzXn6eNzI7Xg8WPiHMfa/jB6cZfacdz/9MqPtcterIrfnX+bnGLszlfunx3b4xzF2Z2o7sho+hqHtvRij10VyrI/P1LG7Fx2ZMI9HtYrwGEn6McLm/HDy5Xg6GL8JsbsflUUNenoo+E2M3elxviicG3K+QvthlLk5UZV70nPBmaci9GOI3dNBG/V40LR9FGJ7PFpdYM515z/ek+1VX+vsOHl8fFR3p7rVzjzw43TZJu6jCtXDwmOstn0YZe4u/Y9rWu3P45pwfFDcp/2ul4fHuN7kwWd8nLjTf9dL7oiR+Hs7dJP8urs77ZYb8phQevp114/nqravHtPtVgypcvoY7PtwK7a3ZF2fLnT64S3Z2U3/YQzlBtWenqvl8JdjPMZD82g8xjj14xj29Zs6Xb/rTe446sl6PGf+J54aHslOjM2vYrKr63WKPt0kt/XjjZRtztBVj/ePcf2PI/TdJS53w/3jCNsjMY86P5fKx0di7m6AatzpUVKfbrKPH/PEdLcdUr/IXMdbMR6TAs453j6Osb5+jtuXq+j2iPZ6uBZ9fgT7aU+WbG/kqF7946OxPTsWt+nexnu55r1u0319/JS/xldzbc2v5trS3zXX3HMjHhNnHw80rN34kzWuaj/kyU+DrLsBKOncCB76Vgw/NHPND/cPY7h8Pde8/Z7Xk8fEZf6wj3lJfescHzzwDNsMIe0H1A4G1J5+lZ9HFncDxq1XEX3cQX04YOy2vdk46mbDPz45tjGW1nYsly/H8KO9GePoFUM+ThY55KuVQ4721dKxD6GVKsfT0fg5xvZoxOoE99F4fkD4zdGYXx+F38Z49UzfxmjEeBqm+FyM16YDDt8OdSjPCO/GqAG1Rwx9L8askc429ePfRba1tO4Yzg8hvxXj/Cz1KzH2+/LaHItsr/c1GTz8w0mWfYiX5mlE7MsTNbKdcXpppma7FYczgP2Ubz/H2E05xephVwmT9vHB2E05PcZGaojz8Qj9tDPN7d2z48OJJ9nNPJlmCLOPj8cvascr01/S5jcU5F2QcbR66DmWb4JsL/rMNOvz/cvPc7zbLZEqhY/RhrHZEv/y1XY39/Ti1Xa/K4yWiGwO6nY7Xrtk7zdE+XXteZ7kNxsyvn5M55eP6TbEdxyOVRnzmFfYHY711eTfbcaUeqSdMjdn+tjerHtNo/WnK6V+IkSvh7Den4bjfw7Rdmd6bcXj6efDEK8ejba5U98HsRqHmmabjBtz93BcwxUPXB8ej/n1Z1IZX57J34eo6Q19um/4XAhlBm1tQuyOxpSaVJjPI3trfuaQMpg1n4evfw4yN+fpY4KaQUZv/t6ZGh8fuE4yn+vjk2yO7ZRx5f7zEZGfQsyvTk1st2Ly+DPWZit2IWoub67NjmwPqHteF84PE7+X+ufHSetcf7d+aK/hgvPLiB8H0a8/6uvXH/W1/b4XSqXt7/w44eZwbLPfa/zkwU/V8BM597jGSl1ud/enup0f1Ulh3/T+bWPwFLQ2T6a6bTmp5ojeNqMOv4hxfDnGkHooHO14L0bn/mPIxzF2809PT/uPUmBvxXh11OHF7djG2B/Tar9+TA9+POpg9g3Hw37vfbGn+c315RjPZflz51irJ9wpHx+PtbvyMyAtNjZjD9sNMUZRnp+jfrMh4+s/7i7Gqyf7i9vx/gnC8EXfFcPdVNRjlIa+l+dBg0/9MPHhoZwq+PhM9V0TXz06jLY5P7ZTURTD87WBCtJ/fvdhux39qGf1tTkc+0tu5/nD54f3hj72QdpTEH0nyIsPhr/amde2Y/cUE9/+uO4f+rGZw/HdGOpBU+NzB95vxre2z1M186HP3aafeiTjTndtHgz16/Me6+tTFuvrMxbryxMWbTcI+2I13cZ4tZr6V+cati90vDZC33bj4q+N0Lfd/PEnRuhffkXm4zdDdtNIL43RtW9442j7YsiqC1zzH0aBf4qxm0V6bZhvH+KlYb62mwJ6rZrvD0bdyjXfvSUjXx7db+3Lo/v7EK89YLcvD8+1L4/Obd85enFwbv/e0mtjc20b5MWxud28z7TOvfXTZrwcQERrPOvBT9PGv2kJ34V5MV23IV5L192rT6+l627y6bWh8O3rVy+d4tsIL53i29fIXjzF96+ivXiK7941evUU375H1mpaoLX23E5ur8eYo5o6f3hLfX3iDb8WNfral/b8WstvMmXIlzNlG+K1TNm9B/Lihe31w6EfF479i3XcEevzzOTPL9a9HMO+HuN5tOQzL/gdWiOUh25eitu+9rTs6Vby4zf82u6tJ+451pA3Q9R6AGvamyEG6zqsL4fQ/t4BbbPzwPTc3f65IFwWVOabP62TML75XbZT11qPK+frLW/FeDzH8k7L5hR78QXQx0Dpx7/uyy+z7mK8+mKufZy3Tb/61LTdCqPRfh19sxWbJwXvdan0x9Dchzdz21eeOq889eflM35+JX+3M/7UOfc8r/hzjN11X55eq3sMeK6P9mZ7VFc18bT1fLn9TF1f9dDyQP34l9le6WZ1asgPnZW/ufDvXnxyXpo8nkcafnq+374gHB2P93jH5l3Ftpv0WTX3/ENv988HZPv+FCPYx7E2MXaDUK+9mdt2by69+Grudl/kqOYGOcbugOzG9F1rHNx9UwB27z+9WgDW8fUCsH0D6sUCsJ19erUA7H+bXle7x0xDe+9k/TGIfxhk/3Z/rZnwmHv++M5/H6MO6+Mhdr0Xo1dzdfth/YefY9juzq7uqdZ7r/c/ZnzrtZ3xtCefifEY7KxZQVkfv8zefPukXFNHD5T3gpzf8q2Zkqe+s08GqcWezq+dvhlk1KTe+XXPN4OsmiCw55vmT/04o+Z95nOPw6diGMtfPQ+Jfy5GPVHN1XYnyXa5goOVeR4PZh8fkn7sxkMac78PVtmE2c2Yzsm8/NTjeHtrWA3isTW+CbOrjWNNJnCXrXcPMWvbPHi+e8Y8vxtg78VwuvP8abrxU6uXHHXmqsh726FST64quyz0L9/dbB85dXbWsZtPQT61FMtjiJj3qh+Z+GYUZSxQ7bA3o1hjj2zou1FqPuTBm4K9j7JqIvXBIu9uy9PRXfLx0e27qapP1KfdLORZn1gZ7nlS4dNhXixzv9ipV8vc9hWqsVhqamwP8S/CvFgtf/F7z6dzT98+9+oduQfPd7PJn1ZMcB3vRmGpJnXz96JYk6oPD57vRmFZIWvr4xNvt9jS9yzYZMzCLJvyZpRV92IPluPNKP60Lb65Vd4vHmWsk7YZBtnHcBagen5P/jMx1mC4bX78FLQf1HGuI+25L/G3axx++ZWVfYjXJgz7lyfFf7EaF/X6MQArH03U7ealnCUhXD6cl9qHaPWKhz8emN+Zl+pTWJ1sbh7W91HU63h0k4+j9PHlLpZ9iJcm+/r4ehfL64ejvX1Qubd4RNE3o1jN6Dx4biYe55fnYfchXvtp5u87D/vj4djMw/7qp1lPUTZr+vlXS9k2wmvtPduV9HoNCj14c4npuw15sRFkbm9FlHkD0/FmEHu6n7HnBfI/FaQmqOT8MPk759kYxBizfbwosG5vob9lncPmDKX+MFK+3ovxPB/zmRiTYeH5nHmfiPHY/laj7c/H4+cYX39HfLvQ4VHdp0PG85tvn1gsUVhI7pzE/ShG363u92Jd3oZ4rS7bl9v4twejsbZV+2FRqZ8Pxm5pvuVMsz+/pPGbILs3o17pEdxvBqNqw587Wz61L8wazqONt4O0CjLW20FqoPF4c1HPlxcGXV+9XG4jvHS53M7Uv9gquF/g9LVWwb6+oVVwu54c18qx2sfN1n19udm6+5ebrfchXmy23h2N1njBS9/r5R+91nUYP7wl9vMR3b0TpTU5rk/jMWcv53MI370SdTCM3Z7PsPFjtm0XonztiP7i1Mjz6/xk9dPR+MQqkvHB8CuGWXsvhtcI4uMCIW/FeDzj522yH21+GGM31/jyapbtq0VwG+GlIrh9jfHFIrhflfO1IhjLMH+1CO7eL33cNNULyM0+XolyHLvx+6cxatMPX+/ax2CVi/bcJvRzjN2rVS++qraN8eKrar/Yl7oDakdvH2/H7ln/pfdth2wX9HXhd/GnS9zPb5rtt+SlN263B6RJffSsPUryWwe1Cd+7kKfy8ZuDur5+ULdjH6+9xLzfjpcO6baMvfSe7D7CK6/Jbhv7XrtGblckH/UGYX9+x/VTq5p7zW2NH3rHPrWqOTHam6uav7wy+pfHxOzLY2Lb9sQXr2/7Fd5fvL71b1iOam3XHPiGRd5ZB+rHlwI+E4OFTx6DPx8vvT92/cmvPWyMbl992NiHePHWeHtEawq4Tf/4iI6xfW/ttZWTtm8wO+Olrh+vvT/G9iMoLy2c9IsYLy2ctI3x4sJJv4pxfDnGawsn7WO8tnDS2Ld3vbSWzNi3d712S/niduxjbI/pSwsnjdm+fjxejPGFfXlp4aSXY2wWTvrFOfbSwklj91GpVxdO2m/Iawsnjd2szcs/rn/9ZH9xO94/QV5bOGno9k2N1xZO2m/Iawsnjf1cyUvPHLuXrF5+5vjFx6leeYz7xRX3pYWThvo+yCsLFm2DvDbj8sudeWk7dpNHbfExENGPn1/G7jnq1YWTtrf9Lz0P7iO88jy4nV94aRv2EV7ahu2dZXUmPND/662JWutPnz083ouhTBir9/dirGqAaX7Mt2I8Jp7qGne0j49H32Xbq7PO2yCPc6KebZd92DK2DeE1jKTe7L0QPGH7/HCq9uWzY7x5hjVi9I8P6FhfXkVlH+Klue/h8ruGeHH6fHs89b/tv/ncb8Ibd+bvVo6n7Xg3Bp9EeeC7MUZ7Jcb88hVlfvmK8osOzxqL8tbebBKtjrcHftgR1b+8KOEvQrxyLPZ9zPXqcfthsbVP9ULXzehjlMHejMGX2p/favhcDBZiWPbxN7R/0es+6FJ/7uz+ZMf8c5TNO0+/ijKIYh+/jTBFtte3174/vfve6Wvvgf2i/7+xrIxv3nL9xTFx3kXw4+13EZ63pb8dhQeX5ePNN1esdRojHyO670bRp3dO3n7/pR/M7fXW3o0ynqLMd9+i6f05ir4b5Wkopa+3j4s9RfF3Pyc/nt4uGu3dX3ocz1HePutYksBG39SWtm276tWz+eDNCfOrMLQpj757T2nfH/zqy3G/2pp6qHjw5tXZz+zUF8LUoOTZTL67lvT/P46Ns1PjGN+xU18IM+qrUjJ26xXM7RKB33VsWJ75wWN+y06Nd8vncdD5fxzvvqTsvHRjzxNzn1xVotrvHuhvBtG6azdt9maQWZO/Nv3d3bEaBbb19pofz7vzfhDWDVN7d80PPupqJuPdLak28UeQ+e6WTJZBm+Mbfh3ZlITtR6s+sSrFdiWU6pXanin7BXdoFOjj47dV9guYVtdoa8+vq/60+OjcvaD52tDQPsRL4zpzrt81xItr9O6OZ+etm24fL+Y6d+Mpr70UsduKweDS+GF9q5+3on/98XC3buCLj4f75XEbS88/9wJ/aond5w8TfHw82m4G5+V1endBXhuW3od4aVj6FyFeGZbergP92hiVfHWIqn15nKx9eZhs175bDznzh9mOdwL8MPXzcoDXXvLfBXipB3AX4KUWwOOrv+PxO/6M0lmvpC+Owvrp2rG2fcv1MsrzXoz1eohZw5RT3w1RwxHzeaDzUyFqEYwfOhjfDPHUP/CpEM+/6fFmCJbK8vFeCKupcnteFfHNEM8J+qkQvJVzvLkjLNSy3t2RVQ3x67nz6M0Q880fle+r+7uH05mhGW+enbzj5KpfDmFv/qhyTJaH1Y8P6PZLCnxTZzy9kPNT5dNj17YkNZLa5WlNg6Y/vaa5W+3vMb5crfnH8yj1z6/eH5vbzccddzVQ2dNv+9sg2y1p1X4gT6/x/jaI7lK2BjbW84rKj8HVn4LsXo5uNfc129Nl6Rzzfj1IrwbqB853g9So3PxhrPw3Qbb95MIxeRr8/80xke1DfK3RYM9rNP02yO6MrQ8IDHkKcfwcYvdIIXTctMPfDMJk8eNBvL0ZxGooodnTjNVvgmxzuNOI3Z+mDn6bw9tu7vbfLpr/myC7l5XMV33d4XiaxvvtD7y+If12QV4+X9t3nK/t6+dr+47ztX3H+dp+9/N11B17H0+l8Ten2u7x71HRjUr/dMf9U1Fraz93V+Pgz3ft9lOMF1/D6u9FWNwtrzcj1Cc5j4+3Yf+TCO8MPK3D+pufZDdSM486Oebx/BUBfT3G8BrFm8dzO9LPMXbtyzzCDH1+Mn87Rv8wxusHdXNv1bevxx3MGz338vy8M9tm/UGjvX98QLY90IezxpocXb8lyoc/8Pa291iv3PZu61iv98EeZVHerag03fbj3TuAV7dEvmNL9veJ1Twwn+8APnmzyTo64/j4tvf4+p3z8ftuxYt3zdsdqddsNpfK/QIDNRQz3wkgPA49HjLfCyGsevf8RPWpEDXKKLLe24ruDPL5e1sx+R7LfLo6fSqEsoT18vd2hFV3e3tvRzoNhH2+tSOv3sbttkKVJcrtvR0xo1vJ21shnMP5vI7ZJ0JY9T8/L/r+iQBes4Y+3zoOfvx3w2KfCVD55Ta/uAvvBRisCDWev1L987pn25EoHgrahyF221DL8z5/Rf232zC+4YFv9wGqFx/4dmtMvPzAtw3y6k3BNsjXK8Xs9eA5+9Pt+GeupHyN7zFJ8vSg1uXHXdl/fsp5Nen562KfCfIo37w4L7st2c0JVMWheo9PlM16be3pae83a3KuuRsdeWV1CN2uevbS6hD6DQunbR8F/OmbEh++2q37tddqybPx9Djy08uu+xCTldf04xC7nqJHlterEnJ8+LFI3S3Ts+r+3aVtNmP7NMLSWuMp0X5+ffjV38Q+/E22J/jzysTPC6D89LP6tnDVOpqP54mPXj/e31rUXesPc03HJ3ak1noW/2Htkp935MvLRtrx5WUj9yG+nKtN6Gv6oXL+dDBs+12p8/s+3HZ+2Ob1qyD9+UMp/cMgmxL6uCVgzkv6Znd094BXXY2PkSQuST99qHYbQ8k3fe6x+kyM6TUZ+ajYmxi7F0RX7Uv3HxZ6/sSGWKuL29nA+uGG7GaZxJ56pJ8XFe4//TK7WaZ5/Le9Pb8J0X/nA/L0y9jzh6B+c0Dm7u6pvhk2l/WPN0T061M7uxt0RrqHSXunog4VQrSPLw0mX6+o7esVtX29ov6qkj2tWfbxIv7WvqMcti9/b2JfUedBj+bzrdjPv23bLnTKW2rPK9j+fJrug3An1Y62C/INc6G/CPLaXOg2yKtzoda/YS7U+pfnQq1/w1zoPsiLc6H7IC8+Gm+vM+vg0aF/fJ3Zvej02JdqWx99c7b27zhbt1debbzE+MOT0E+7s5siejyb85XotQsi33BMdks6vX5MXnook+f3tX67N9vPs7POw/PSBr/dm/kNe7P9cRh8+GHNv9/ujn3H7nzHCfvi3dU61nv3zmr1idrHOHj/8v23PX20+ucY25ebHjPnT0+bTwsJ/byEs8m+nfrpk7vm8nGY/dNADas/hhRkc/O7C+JP3315/hzPz0HmN3Tz2fyGbr59kBe7+X4R5LV5ye0xefmOQL/jjkC/fkeg33FHoN9xR6DfcUewfQSe/ell1o/HBHYfTum1XF1/bo366cliuyD862Vg/wz8YhnYBnm1DJh8QxnYzVG9XAa2QV4tA/sgL5aB3TF5uQzsZoheLgO7T0m9WAZsfUMZ2AZ5tQxsg3zHg8HkJHl+CfTn+6zVdpOyfLWoPd1V/DxX9YunC27Wutq7TxcvJl//jsfY9R1n6/r62bq+42xd33G2rt/7bGXlJZ/z47PVtyOu9UWoKc9trD+frbsnpSlCkOevp/0myPyGs3XMbzhb/TvOVv/62erfcbb6d5yt/h1n6/ZtcK8R4Obz42GXtevuHUdNEYzjh5lj+cw4xYvVdT9O8er52r5+vq7jG87XdXz5fF3HN5yv+yAvnq/7IN9xvnapjufHuNbHoy5rV6KH1dT+WD/MacnrQzev19fvuBsY33A3sOQ7zlf5+vkq33G+ynecr/ItdwO7CcdWk/SPGWndPPXtggw+6/rcr/tzkLWd25KD7uXnBYzkM1sya9Bz6vNSEb/Zkm1XYM2PPXUL/PTOwtrNSv33EWT8/Dj+HWNh8g2DR2v3ytLLmdePL2feblrr5czbBnk187ZBXsy8fZAX3yb5xe681ji6LySvbsm+pL24Jcd3bMnxDVuyv3l9cUt+cRv94pas79iS9R1bYt+xJfYtW7IdUnvt/adfBHntzaP9OPKrx0S/4Z2wX8w2vHhM5je8E/Z6v13/uN9u7Rd3flrb+ellptFe35DOC1Fd/NhsyPz6c98vgrw2yb12P86r86i/CPLafcU2yMv3FXp8w33F9ksor91X7Oa1Xr6v2AZ59b5iG+TlSandSd9qIb/e1sete2v3bapXHx63QV5tHlj6Dc0Dvwjy4kmv3/EYa98wE7vsyzOxy75hJnYf5NWT3vrvftLXiEnvmzcAtkHGUbszjrnJnO33gr8jyGvLV+5DvLR85S9CvLJ85f7HffWG3r7h9mhfW1/dkn2Vf/FGrX/HLWP/hmNybMdKssQ/zzgueTXAY4Kft8WP5/59/UQIlrM/lug7IVju7sFPC959IoTXwrUPVnkrBN+5+KF98DMhnj5ueTy90vV6COGjgw9uH23F2s1kvbor2yCvNZkf24r+wmLXuwAvrVPtx+8b4svHQdqsX7Q9vyLjr7/m1+g2bM/vtr0bQt8K0XlJrz+/0/uZEMrSEs892J8IMYVP2I/3jkXnrcnnFy/fDvHej/q8ouTTE+WnQrAuxFB9MwQ78vz+52dC1N2sjPXejzqcD9gex5vnBa/Ctrd+VL5d/byC1CcCcGrO9vFx8O0o7OKj9Ws9rzP98kbUPd8PMzmf2IvqDflhQa9PBJhM4Yy3AtQT4/T+XoBa3dnH1wL8sLbzZw4iq4C9VSq1VtjQ7l/cgp9/xv/5+H//9C9/+cc///Xv//Knf//L3//2b4+/+68z1D/+8qf/9dc/3//v//mPv/3L0//67//vv+b/8r/+8Ze//vUv//ef//Uff/+XP//v//jHn89I5//2h+P+P/8jvljzmFX2//lPf5DH/7/G41bzMQ54PP7/fv7v+nhqfNx+6vm/n3/wmCi3fxprtvO/kPgXj/vbx//x//lf5yb/fw==","names":["sync_private_state"],"brillig_names":["sync_private_state"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"GuardianBlocking::add_guardian_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"GuardianBlocking::add_guardian_parameters","fields":[{"name":"guardian","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"GuardianBlocking::approve_blocking_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"GuardianBlocking::approve_blocking_parameters","fields":[{"name":"user","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"GuardianBlocking::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"GuardianBlocking::constructor_parameters","fields":[{"name":"portal","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"GuardianBlocking::initiate_blocking_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"GuardianBlocking::initiate_blocking_parameters","fields":[{"name":"user","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"GuardianBlocking::is_user_blocked_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"GuardianBlocking::is_user_blocked_parameters","fields":[{"name":"user","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"boolean"}}]},{"kind":"struct","path":"GuardianBlocking::remove_guardian_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"GuardianBlocking::remove_guardian_parameters","fields":[{"name":"guardian","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"GuardianBlocking::sync_private_state_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"GuardianBlocking::sync_private_state_parameters","fields":[]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"GuardianBlocking"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"config","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"user_guardians","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"user_approvals","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"blocking_started","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"user_blocked","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}}]}}]}],"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"},{"kind":"string","value":"AddressNote"},{"kind":"struct","fields":[{"name":"address","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}}]}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"},{"kind":"string","value":"ValueNote"},{"kind":"struct","fields":[{"name":"value","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}}]}]}]}},"file_map":{"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"12":{"source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n","path":"std/convert.nr"},"16":{"source":"use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n","path":"std/embedded_curve_ops.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"25":{"source":"//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n","path":"std/meta/expr.nr"},"42":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"43":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"51":{"source":"mod config;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract GuardianBlocking {\n    use crate::config::Config;\n    use dep::value_note::value_note::ValueNote;\n    use dep::aztec::{\n        note::note_getter_options::NoteGetterOptions,\n        note::note_interface::NoteProperties,\n        note::note_viewer_options::NoteViewerOptions,\n        utils::comparison::Comparator,\n        macros::{functions::{initializer, internal, private, public, utility}, storage::storage},\n        prelude::{AztecAddress, EthAddress, Map, PrivateSet, PublicMutable, PublicImmutable, PrivateMutable},\n    };\n    use dep::aztec::protocol_types::traits::ToField;\n\n    #[storage]\n    struct Storage<Context> {\n        config: PublicImmutable<Config, Context>,\n        // Map user -> Set of guardians\n        user_guardians: Map<AztecAddress, PrivateSet<ValueNote, Context>, Context>,\n        // Map user -> Map of guardian -> approval\n        user_approvals: Map<AztecAddress, PrivateSet<ValueNote, Context>, Context>,\n        // Map user -> blocking initiated status\n        blocking_started: Map<AztecAddress, PrivateMutable<ValueNote, Context>, Context>,\n        // Map user -> final blocked status\n        user_blocked: Map<AztecAddress, PrivateMutable<ValueNote, Context>, Context>,\n    }\n\n    // ========== Init ==========\n    #[public]\n    #[initializer]\n    fn constructor(portal: EthAddress) {\n        storage.config.initialize(Config { portal });\n    }\n\n    // ========== Guardian Management ==========\n\n    #[private]\n    fn add_guardian(guardian: AztecAddress) {\n        let sender = context.msg_sender();\n        let note = ValueNote::new(1, guardian);\n        storage.user_guardians.at(sender).insert(note);\n    }\n\n    #[private]\n    fn remove_guardian(guardian: AztecAddress) {\n        let sender = context.msg_sender();\n        let note = ValueNote::new(1, guardian);\n\n        storage.user_guardians.at(sender).pop_notes(NoteGetterOptions::new()\n            .select(ValueNote::properties().owner, Comparator.EQ, guardian)\n            .set_limit(1));\n    }\n\n    // ========== Blocking Flow ==========\n\n    #[private]\n    fn initiate_blocking(user: AztecAddress) {\n        let sender = context.msg_sender();\n        let notes = storage.user_guardians.at(user).pop_notes(NoteGetterOptions::new()\n            .select(ValueNote::properties().owner, Comparator.EQ, sender)\n            .set_limit(1));\n        assert(notes.len() == 1, \"Not a guardian\");\n\n        let is_user_blocked = storage.user_blocked.at(user).get_note();\n        assert(is_user_blocked.note.value == 1, \"Already blocked\");\n        \n        let is_blocking_started = storage.blocking_started.at(user).get_note();\n        assert(is_blocking_started.note.value == 1, \"Block already started\");\n\n        let note = ValueNote::new(1, user);\n        storage.blocking_started.at(user).replace(note);\n\n        let note = ValueNote::new(1, sender);\n        storage.user_approvals.at(user).insert(note);\n    }\n\n    #[private]\n    fn approve_blocking(user: AztecAddress) {\n        let sender = context.msg_sender();\n\n        let notes = storage.user_guardians.at(user).pop_notes(NoteGetterOptions::new()\n            .select(ValueNote::properties().owner, Comparator.EQ, sender)\n            .set_limit(1));\n        assert(notes.len() == 1, \"Not a guardian\");\n\n        let is_blocking_started = storage.blocking_started.at(user).get_note();\n        assert(is_blocking_started.note.value == 1, \"Blocking not started\");\n\n        let is_user_blocked = storage.user_blocked.at(user).get_note();\n        assert(is_user_blocked.note.value == 1, \"Already blocked\");\n\n        let note = ValueNote::new(1, sender);\n        storage.user_approvals.at(user).insert(note);\n\n        let mut all_approved = true;\n        let all_notes = storage.user_guardians.at(user).get_notes(NoteGetterOptions::new());\n        for i in 0..10 {\n            if i < all_notes.len() {\n              let note2 = all_notes.get_unchecked(i).note;\n              storage.user_approvals.at(user);\n              let user_approval_note = storage.user_approvals.at(user).pop_notes(NoteGetterOptions::new()\n                .select(ValueNote::properties().owner, Comparator.EQ, sender)\n                .set_limit(1));\n              if user_approval_note.len() != 1 {\n                  all_approved = false;\n              }\n            }\n        }\n\n        if all_approved {\n            let new_user_blocked_note = ValueNote::new(1, user);\n            storage.user_blocked.at(user).replace(new_user_blocked_note);\n            context.message_portal(storage.config.read().portal, user.to_field());\n        }\n    }\n\n    // ========== Utility ==========\n\n    #[utility]\n    unconstrained fn is_user_blocked(user: AztecAddress) -> bool {\n      let is_user_blocked = storage.user_blocked.at(user).view_note();\n      is_user_blocked.value == 1\n    }\n}\n","path":"/Users/oleksiiandriushchenko/Work/aztec/Nul/packages/aztec-guardians/src/main.nr"},"54":{"source":"use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/capsules/mod.nr"},"62":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"63":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"65":{"source":"use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/context/utility_context.nr"},"69":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/hash.nr"},"81":{"source":"use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/history/public_storage.nr"},"86":{"source":"use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"90":{"source":"use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_private_state = generate_sync_private_state();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/macros/aztec.nr"},"91":{"source":"use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr"},"95":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr"},"98":{"source":"use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n\n    fn_abi\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr"},"100":{"source":"use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/macros/notes.nr"},"101":{"source":"use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/macros/storage.nr"},"103":{"source":"use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr"},"104":{"source":"use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr"},"105":{"source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr"},"107":{"source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::fetch_tagged_logs},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr"},"108":{"source":"use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr"},"109":{"source":"// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/messages/encoding.nr"},"110":{"source":"use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr"},"123":{"source":"use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr"},"128":{"source":"use crate::{\n    context::PrivateContext,\n    note::{\n        note_getter_options::{\n            NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder,\n        },\n        note_interface::{NoteHash, NoteType},\n        note_viewer_options::NoteViewerOptions,\n        retrieved_note::RetrievedNote,\n        utils::compute_note_hash_for_read_request,\n    },\n    oracle,\n    utils::{array, comparison::compare},\n};\n\nuse protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, traits::{Packable, ToField}};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/note/note_getter.nr"},"131":{"source":"use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr"},"133":{"source":"use crate::{note::note_metadata::NoteMetadata, utils::array::subarray::subarray};\nuse protocol_types::{\n    address::AztecAddress,\n    traits::{FromField, Packable, Serialize, ToField},\n    utils::arrays::array_concat,\n};\n\n// Number of fields a RetrievedNote adds to the packed or serialized representation of a note\n// +1 for the contract address\n// +2 for the note metadata\npub global RETRIEVED_NOTE_OVERHEAD: u32 = 1 + 2;\n\n/// A container of a note and the metadata required to prove its existence, regardless of whether the note is\n/// pending (created in the current transaction) or settled (created in a previous transaction).\n#[derive(Eq)]\npub struct RetrievedNote<NOTE> {\n    pub note: NOTE,\n    pub contract_address: AztecAddress,\n    pub metadata: NoteMetadata,\n}\n\nimpl<NOTE, let N: u32> Serialize<N + RETRIEVED_NOTE_OVERHEAD> for RetrievedNote<NOTE>\nwhere\n    NOTE: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + RETRIEVED_NOTE_OVERHEAD] {\n        array_concat(\n            array_concat(self.note.serialize(), [self.contract_address.to_field()]),\n            self.metadata.serialize(),\n        )\n    }\n}\n\n// This function is not part of the Packable trait implementation because in the case of the retrieved note, the pack\n// functionality resides in TS (oracle.ts and txe_service.ts).\npub fn unpack_retrieved_note<NOTE, let N: u32>(\n    packed_retrieved_note: [Field; N + RETRIEVED_NOTE_OVERHEAD],\n) -> RetrievedNote<NOTE>\nwhere\n    NOTE: Packable<N>,\n{\n    let contract_address = AztecAddress::from_field(packed_retrieved_note[0]);\n    let nonce = packed_retrieved_note[1];\n    let nonzero_note_hash_counter = packed_retrieved_note[2] as bool;\n\n    let packed_note = subarray(packed_retrieved_note, RETRIEVED_NOTE_OVERHEAD);\n    let note = NOTE::unpack(packed_note);\n\n    RetrievedNote {\n        note,\n        contract_address,\n        metadata: NoteMetadata::from_raw_data(nonzero_note_hash_counter, nonce),\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/note/retrieved_note.nr"},"134":{"source":"use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"138":{"source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr"},"140":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"142":{"source":"use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"146":{"source":"use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr"},"147":{"source":"use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"148":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"149":{"source":"use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, length, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/logs.nr"},"150":{"source":"use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(fetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    // The log fields length is PUBLIC_LOG_SIZE_IN_FIELDS. + 1 because the contract address is prepended to the content.\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_SIZE_IN_FIELDS + 1>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr"},"152":{"source":"use crate::note::{\n    note_interface::NoteType,\n    retrieved_note::{RETRIEVED_NOTE_OVERHEAD, RetrievedNote, unpack_retrieved_note},\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> {}\n\npub unconstrained fn get_notes<Note, let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<NOTE_PCKD_LEN>,\n{\n    // N + 3 because of the contract address, nonce, and note_hash_counter that are stored out of the packed note.\n    let packed_retrieved_notes: BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> = get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        MAX_NOTES,\n        NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD,\n    );\n\n    let mut notes = BoundedVec::<_, MAX_NOTES>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = unpack_retrieved_note(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MAX_NOTES];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"153":{"source":"/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/random.nr"},"154":{"source":"use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr"},"156":{"source":"use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/storage.nr"},"158":{"source":"use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only\n// used to derive the storage slots of nested state variables, which is expected to never result in collisions or slots\n// being close to one another due to these being hashes. This mirrors the strategy adopted by Solidity mappings.\nimpl<K, T, Context> Storage<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"162":{"source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateMutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nmod test;\n\n// Private storage slots are not really 'slots' but rather a value in the note hash preimage, so there is no notion of a\n// value spilling over multiple slots. For this reason PrivateMutable (and all other private state variables) needs just\n// one slot to be reserved, regardless of what it stores.\nimpl<T, Context> Storage<1> for PrivateMutable<T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateMutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateMutable>` type (for example), because the storage slot often also identifies an actor. e.g.\n    // the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    // Note: subsequent nullification of this state variable, via the `replace` method will not be leaky, if the `compute_nullifier()` method of the underlying note is designed to ensure privacy.\n    // For example, if the `compute_nullifier()` method injects the secret key of a note owner into the computed nullifier's preimage.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateMutable<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash,\n{\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace<let N: u32>(self, new_note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        let (prev_retrieved_note, note_hash_for_read_request): (RetrievedNote<Note>, Field) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify previous note.\n        destroy_note_unsafe(\n            self.context,\n            prev_retrieved_note,\n            note_hash_for_read_request,\n        );\n\n        // Add replacement note.\n        create_note(self.context, self.storage_slot, new_note)\n    }\n    // docs:end:replace\n\n    pub fn initialize_or_replace<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        // Safety: `check_nullifier_exists` is an unconstrained function - we can constrain a true value\n        // by providing an inclusion proof of the nullifier, but cannot constrain a false value since\n        // a non-inclusion proof would only be valid if done in public.\n        // Ultimately, this is not an issue given that we'll either:\n        //  - initialize the state variable, which would fail if it was already initialized due to the duplicate\n        //    nullifier, or\n        //  - replace the current value, which would fail if it was not initialized since we wouldn't be able\n        //    to produce an inclusion proof for the current note\n        // This means that an honest oracle will assist the prover to produce a valid proof, while a malicious\n        // oracle (i.e. one that returns an incorrect value for is_initialized) will simply fail to produce\n        // a proof.\n        let is_initialized =\n            unsafe { check_nullifier_exists(self.compute_initialization_nullifier()) };\n\n        if (!is_initialized) {\n            self.initialize(note)\n        } else {\n            self.replace(note)\n        }\n    }\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        let mut (retrieved_note, note_hash_for_read_request) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note_unsafe(self.context, retrieved_note, note_hash_for_read_request);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(self.context, self.storage_slot, retrieved_note.note)\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateMutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/state_vars/private_mutable.nr"},"164":{"source":"use crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    abis::read_request::ReadRequest, constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    traits::Packable,\n};\n\nmod test;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    pub context: Context,\n    pub storage_slot: Field,\n}\n// docs:end:struct\n\n// Private storage slots are not really 'slots' but rather a value in the note hash preimage, so there is no notion of a\n// value spilling over multiple slots. For this reason PrivateSet (and all other private state variables) needs just one\n// slot to be reserved, regardless of what it stores.\nimpl<T, Context> Storage<1> for PrivateSet<T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:insert\n    pub fn insert<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS, let N: u32>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N>,\n    {\n        let (retrieved_notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < retrieved_notes.len() {\n                let retrieved_note = retrieved_notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, retrieved_note, note_hash);\n            }\n        }\n\n        // Since the notes were already destroyed, we no longer need the additional data in RetrievedNote and can\n        // discard it.\n        retrieved_notes.map(|retrieved_note| retrieved_note.note)\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, retrieved_note: RetrievedNote<Note>) {\n        let note_hash = compute_note_hash_for_read_request(retrieved_note, self.storage_slot);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, retrieved_note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS, let N: u32>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N>,\n    {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note> PrivateSet<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes<let N: u32>(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\n    where\n        Note: Packable<N>,\n    {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr"},"166":{"source":"use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr"},"181":{"source":"/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/utils/array/append.nr"},"182":{"source":"/// Collapses an array of `Option`s with sparse `Some` values into a `BoundedVec`, essentially unwrapping the `Option`s\n/// and removing the `None` values.\n///\n/// For example, given:\n///   `input: [some(3), none(), some(1)]`\n/// this returns\n///   `collapsed: [3, 1]`\npub fn collapse<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>\nwhere\n    T: Eq,\n{\n    // Computing the collapsed BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n\n    // Safety: The hints are verified by the `verify_collapse_hints` function.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\nfn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>,\n)\nwhere\n    T: Eq,\n{\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(\n        collapsed.len(),\n        collapsed_to_input_index_mapping.len(),\n        \"Collapse hint vec length mismatch\",\n    );\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(\n                collapsed.get_unchecked(i),\n                input[input_index].unwrap(),\n                \"Wrong collapsed vec content\",\n            );\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(\n                collapsed.get_unchecked(i),\n                std::mem::zeroed(),\n                \"Dirty collapsed vec storage\",\n            );\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n\nmod test {\n    use super::{collapse, verify_collapse_hints};\n\n    #[test]\n    unconstrained fn collapse_empty_array() {\n        let original: [Option<Field>; 2] = [Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn collapse_non_sparse_array() {\n        let original = [Option::some(7), Option::some(3), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_sparse_array() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_front_padding() {\n        let original =\n            [Option::none(), Option::none(), Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_back_padding() {\n        let original =\n            [Option::some(7), Option::none(), Option::some(3), Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn verify_collapse_hints_good_hints() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec length\")]\n    unconstrained fn verify_collapse_hints_wrong_length() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Collapse hint vec length mismatch\")]\n    unconstrained fn verify_collapse_hints_hint_length_mismatch() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Out of bounds index hint\")]\n    unconstrained fn verify_collapse_hints_out_of_bounds_index_hint() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 5]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn verify_collapse_hints_hint_to_none() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 0]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 1]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec content\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_content() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 42]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec order\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_order() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([3, 7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([2, 0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Dirty collapsed vec storage\")]\n    unconstrained fn verify_collapse_hints_dirty_storage() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n\n        let mut collapsed: BoundedVec<u32, 3> = BoundedVec::from_array([7, 3]);\n        // We have to use the unchecked setter as we're knowingly writing past the length, breaking its invariants.\n        collapsed.set_unchecked(2, 1);\n\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/utils/array/collapse.nr"},"184":{"source":"/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr"},"185":{"source":"use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr"},"186":{"source":"struct ComparatorEnum {\n    pub EQ: u8,\n    pub NEQ: u8,\n    pub LT: u8,\n    pub LTE: u8,\n    pub GT: u8,\n    pub GTE: u8,\n}\n\npub global Comparator: ComparatorEnum =\n    ComparatorEnum { EQ: 1, NEQ: 2, LT: 3, LTE: 4, GT: 5, GTE: 6 };\n\npub fn compare(lhs: Field, operation: u8, rhs: Field) -> bool {\n    // Values are computed ahead of time because circuits evaluate all branches\n    let is_equal = lhs == rhs;\n    let is_lt = lhs.lt(rhs);\n\n    if (operation == Comparator.EQ) {\n        is_equal\n    } else if (operation == Comparator.NEQ) {\n        !is_equal\n    } else if (operation == Comparator.LT) {\n        is_lt\n    } else if (operation == Comparator.LTE) {\n        is_lt | is_equal\n    } else if (operation == Comparator.GT) {\n        !is_lt & !is_equal\n    } else if (operation == Comparator.GTE) {\n        !is_lt\n    } else {\n        panic(f\"Invalid operation\")\n    }\n}\n\nmod test {\n    use super::Comparator;\n    use super::compare;\n\n    #[test]\n    unconstrained fn test_compare() {\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.LT, rhs), \"Expected lhs to be less than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.LTE, rhs), \"Expected lhs to be less than or equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.GT, rhs), \"Expected lhs to be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(!compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to not be not equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.LT, rhs), \"Expected lhs to not be less than rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            !compare(lhs, Comparator.LTE, rhs),\n            \"Expected lhs to not be less than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.GT, rhs), \"Expected lhs to not be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/utils/comparison.nr"},"187":{"source":"use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr"},"188":{"source":"// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr"},"190":{"source":"use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/utils/field.nr"},"192":{"source":"use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"196":{"source":"use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr"},"203":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr"},"220":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr"},"222":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"265":{"source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"266":{"source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH,\n    traits::{Deserialize, Empty, Packable, Serialize, ToField},\n};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl Packable<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn pack(self) -> [Field; ETH_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn to_be_bytes(self) -> [u8; 20] {\n        let field_bytes: [u8; 32] = self.inner.to_be_bytes();\n        let mut bytes = [0; 20];\n        for i in 0..20 {\n            bytes[i] = field_bytes[i + 12];\n        }\n        bytes\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr"},"280":{"source":"use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr"},"282":{"source":"/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"283":{"source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"293":{"source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr"},"297":{"source":"use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr"},"299":{"source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"300":{"source":"use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr"},"310":{"source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr"},"321":{"source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"340":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"356":{"source":"pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::sort_by_counter_asc;\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\n// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr"},"357":{"source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"359":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"369":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr"},"378":{"source":"use aztec::{macros::notes::note, oracle::random::random, protocol_types::address::AztecAddress};\n\n// docs:start:value-note-def\n#[note]\n#[derive(Eq)]\npub struct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        ValueNote { value, owner, randomness }\n    }\n\n    pub fn value(self) -> Field {\n        self.value\n    }\n}\n","path":"/Users/oleksiiandriushchenko/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/value-note/src/value_note.nr"}}}